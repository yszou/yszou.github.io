Racket 语言学习参考
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/racket.html
%!format: !email
%%toc


# 安装与简介 #

*racket* 是一个比较现代化的 *scheme* 语言。它的 Hello World 是这样的：

```racket
#lang racket  

(display "helloworld")
```

可以直接使用：

```bash
sudo apt-get install racket
```

进行安装，完成之后，有一个 ``racket`` 的可执行程序/REPL ，及 ``drracket`` 这个开发环境/IDE。

``racket`` 可以直接执行一个文件，如：

```bash
racket /home/zys/temp/demo.rkt
```

*racket* 提供了编译器，可以直接编译得到可执行程序。


# 基本语法 #

## 圆括号和方括号 ##

*scheme* 是用 S 表达式来组成的， *racket* 中这点并没有变化，但是 *racket* 中的 S 表达式，同时支持圆括号 ``()`` 和方括号 ``[]`` ，这个机制，在括号嵌套场景下，可以提供更好的视觉识别，如：

```racket
#lang racket  

(define [add1 a b] [+ a b])
(define (add2 a b) (+ a b))

(add1 1 2)
(add2 1 2)
```

## 注释 ##

```racket
#lang racket  

;这是传统的单行注释

#| 
这是 racket 的，可以多行的，
    #|
        可以嵌套的注释
    |#
|#

#; 注释一个 "单语法单元"
#;(display
    123) (display "1\n")
#;1 2 (display "2\n")
```

``#;`` 的行为比较特殊，其它语言中是没有的。


## 基本数据类型 ##

```racket
#lang racket  

1
3.14
1/3
(+ 1/3 1/3)
6.02e+23
1+2i
#t
#f
"string"
"string\"ss\""
(display "string\"ss\"\n")
"λx:(μα.α→α).xx"
"』▶😀😂"
(display "』▶😀😂\n")
```

基本数据类型有：整数，小数，实数，复数，布尔量，Unicode 字符串。

后面还会专门对内置的数据类型作介绍。


## 逻辑运算，条件判断 ##

TODO


## 定义与函数，匿名函数 ##

*定义* ，这里指的是 ``define`` ，其实应该说 *绑定* 的：

```racket
#lang racket  

(define a 1)
(define b 2)
(+ a b)
```

像是赋值，但是不能对同一个 *标识* ，进行重复的 ``define`` 。

``define`` 也可以用于函数的定义：

```
#lang racket  

(define [add a b] [+ a b])
(add 1 2)
```

使用 ``labmda`` 的匿名函数也行：

```racket
#lang racket  

(define add [lambda (a b) (+ a b)])
(add 1 2)
```

## 列表，迭代 ##

*列表* ，是 *scheme* 这类语言，最核心的一种数据结构。因为，我们写的代码，本身就是一个一个的 *列表* 。这个性质是一般大众化的语言没有的。


```racket
#lang racket  

(define add [lambda (a b) (+ a b)])
(add 1 2)

'(add 1 2)
'("add" "1" "2")
(list add 1 2)
(list "add" 1 2)
```

``list`` 函数，和 ``'`` 前缀，是同样的作用，就是得到一个列表。

*racket* 内置了很多针对列表的函数：

```racket
#lang racket  

(define any '(1 2 3 add "add"))
any
(length any)
(list-ref any 0)
(list-ref any 3)
(append any "1")
(append any '(2 "good"))
(reverse any)
```

``append`` 的第二个参数，类型不同，结果是不同的。如果第二个参数不是 *list* ，则会得到一个 *Pair* 。


*迭代* 的概念，类似于其它语言中的那一堆“函数式”方法，像 ``map`` ``filter`` ``reduce`` 之类的。

*racket* 中有 ``map`` ``filter`` ``foldl`` ``andmap`` ``ormap`` 。

```racket
#lang racket  

(map [lambda (n) (* n 2)] '[1 2 3 4 5])
(filter [lambda (n) (> n 4)] '[1 3 4 5 6 7 8])
(foldl [lambda (a b) (+ a b)] 0 '[1 2 3 4])
(andmap [lambda (n) (> n 4)] '[5 6])
(ormap [lambda (n) (> n 5)] '[5 6])
```

## 列表传统 ##

``map`` 之类的函数，对于“迭代”来说不是必须的，传统上，只需要 ``car`` 和 ``cdr`` 两个方法就可以完成对列表的遍历操作，基于它们，可以自己定义 ``map`` ``filter`` 等。在 *racket* 中，对应的方法是 ``first`` 和 ``rest`` ：

```racket
#lang racket  

(first '(1 2 3))
(rest '(1 2 3))
(first (rest '(1 2 3)))
(define l (cons 2 (cons 1 empty)))
(first l)
(rest l)
(empty? empty)
(empty? '())
(empty? '(1))
(empty? 1)
```

要写个简单的 ``map`` 就很容易了：

```racket
#lang racket  

(define (my-map f lst)
  (if [empty? lst]
    lst
    [cons (f [first lst]) (my-map f [rest lst])] ))

(my-map (lambda (n) (+ n 1)) '(1 2 3))
```

``car`` , ``cdr`` ，甚至是 ``pair`` 这类传统概念在 *racket* 中都是存在的，不过并不需要刻意去使用就是了：

```racket
#lang racket  

(pair? (cons 1 2))
(list? (cons 1 2))
(cons 1 2)
(car (cons 1 2))
(cdr (cons 1 2))
(car '(1 2 3))
(cdr '(1 2 3))
```


## 尾递归 ##

前面写的 ``my-map`` ，是一个比较直接的实现，它通过递归的方式，依次把 ``my-map`` 的结果作为 ``cons`` 的第二个参数。这种结构下，在反复自调用 ``my-map`` 的时候，都必须保存一个状态，这不是一种高效的表现。

改进的办法，是让反复自调用 ``my-map`` 时，都不依赖外部的任何信息，所有信息都通过“参数”体现。


```racket
#lang racket  

(define (my-map f lst)
  (define (iter f lst result)
    [if (empty? lst) (reverse result)
                         ;---------------------------;
      (iter f (rest lst) [cons (f (first lst)) result] )]
    )
  (iter f lst empty))

(my-map (lambda (n) (+ n 2)) '(1 2 3))
(my-map (lambda (n) (+ n 2)) empty)
```

上面的代码中，我们在每次自调用 ``my-app`` 时，都在小心地构造完整的 ``result`` 参数，这样，当最终满足结束迭代的条件时，直接返回 ``result`` 即可，不需要额外的“回溯”过程。


上面的代码，可以使用内置的 ``for/list`` （我猜它应该是一个宏）来完成：

```racket
#lang racket  

(define (my-map f lst)
             ;v;        ;v;
  (for/list ([i lst]) (f i)))

(my-map (lambda (i) (+ i 2)) '(1 2 3 4))
```

现在我们并没有讲过“变量”之类的概念，只有函数的“参数”。上面代码中的 ``i`` ，虽然看起来像“变量”，但在宏展开后，也就只是一个函数参数了。从形式上，我们可以猜出，对于 ``for/list`` 来说，它的第一个参数，是可以有多个迭代的取值对，这些取值对，第一个参数，是一个形式上的名字，而第二个参数，是一个表达式，会被“求值”。

写一些例子试试：

```racket
#lang racket  

(for/list ([a '(1 2 3)]) ((lambda (i) (+ i 2)) a))

(for/list ([a '(1 2 3)]
           [b (reverse '(1 2 3))])
  ([lambda (i k) (+ i k)] a b))
```

在 *racket* 中，它并不避讳使用递归，不是说一定要尽量使用“迭代”（迭代只是递归的一种特殊形式而已）。同时，因为语言机制，在 *racket* 中并不会有 *stack overflow* 问题（但是仍然会使用额外的更多内存）。


## 中缀语法 ##

这个，感觉像是 *racket* 自己玩花活，通过“点”符号， *racket* 定义了一种中缀表达式的格式：

```racket
#lang racket  

( (1 . + . 1) . + . 2 )
'(1 . + . 2)

(define (times base n) (base . * . n))
(10 . times . 2)
```

这种表达式，可以特定使用在，接收 2 个参数的函数上。


# 数据类型 #

## 布尔值 ##

``#t`` ``#f`` ``#T`` ``#F`` ，是布尔值。在逻辑判断中，所有不是 ``#f`` ``#F`` 的，都会被认为是 ``#t`` 。

使用 ``boolean?`` 可以做精确的类型判断：

```
#lang racket  

(boolean? #t)
(boolean? #T)
(boolean? 1)
(boolean? (not 1))
```


## 数字 ##

数字的情况在 *racket* 中复杂一些。

传统上，我们理解数字类型，可以分成 整数，浮点数，之类的。 *racket* 中也有这些概念，但在它们之上， *racket* 中的数字还被分成“精确数字” *exact* 和“非精确数字” *inexact* 。

分数的 ``1/2`` 和浮点数的 ``0.5`` ，是不同的。 ``1/2`` 是 *exact* ，而 ``0.5`` 是 *inexact* 。

精确的数字类型有这些：

- 整数， ``1``, ``999999``, ``-12``
- 分数， ``1/2``, ``-3/5``
- 复数， ``1+2i`` , ``1/3-2/5j``


不精确的数字类型有：

- 浮点， ``2.0``,  ``3.14e+10``
- 无限， ``+inf.0`` , ``-inf.0`` （必须是这两个）
- 非数字， ``+nan.0``, ``-nan.0``
- 复数， ``2.1+3.0i``, ``-inf.0+nan.0i``


在书写时，可以明确表示是否 *exact* ，使用 ``#e`` 或者 ``#i`` ， *racket* 可以自动转换：

```racket
#e0.5 ;1/2
#i1/2 ;0.5
#e0.1 ;1/10
```

二进制，八进制，十六进制，分别使用 ``#b``, ``#o``, ``#x`` ：

```
#xFF ;255
#b100100 ;36
#o10 ;8
```

精确值和非精确值之间使用 ``exact->inexact`` 和 ``inexact->exact`` 转换：

```racket
(exact->inexact 1/3)
(inexact->exact 0.3333) ;非常大的两个整数相除
```

不同类型的性能表现方面： 小的整数 > 浮点 > 超大整数和其它精确数


数字的比较，一般有两个方法， ``=`` 和 ``eqv?`` ，前者会尝试转换到精确值后再比较，后者不会：

```racket
(= 1 1.0) ;t
(= 1/3 0.333333) ;f
(eqv? 1 1.0) ;f
(eqv? 1 3/3) ;t
```

## 字符和字符串 ##

*racket* 中的 *字符* 指一个 Unicode 值。可以使用 ``#\`` ， ``#\u`` , ``#\space`` ``#\newline`` 这些表示法。同时，使用 ``char->integer`` 和 ``integer->char`` 完成数字和字符的转换：

使用 ``char=?`` 可以比较两个字符，或者 ``char-ci=?`` 忽略大小写：

```racket
(char=? #\a #\a)
(char-ci=? #\a #\A)
(char=? #\a #\u61)
(char=? #\』 #\』)
```

*字符串* 是固定长度的字符数组，使用双引号包起来。

```racket
(display "\u03BB\u03BB\n\u03BB")
```

字符串分为“可变”和“不可变”两种情况。直接写死的是不可变的字符串，通过一些方法，可以得到可变的字符串：

```racket
#lang racket  

(define s (make-string 10 #\.))
(display s)
(display "\n")
(string-set! s 2 #\x)
(display s)
```


## 字节和字节串 ##

*racket* 的 *字节*，就是 *0-255* 的整数：

```racket
(byte? 0) ;#t
(byte? 256) ;#f
```

*字节串* 是使用 *#* 前缀的字符串样子：

```racket
#"Hello"
"Hello"

(define b (make-bytes 10 0))
(bytes-set! b 0 97)
b
```

如果使用 ``display`` 函数去输出字节串的话，它会按 UTF-8 的编码方式处理。

字节串和字符串的相互转换，需要使用专门的函数实现：

```racket
(bytes->string/utf-8 #"\xCE\xBB") ;λ
```

## 符号 ##

符号 *Symbol* 是元编程中非常基础的概念，比如下面的代码：

```racket
(first '(define a 1))
(first '("define" a 1))
```

它们返回的是什么东西？

第一行代码，返回的就是 ``define`` 符号：

```racket
(eq? [first '(define a 1)] 'define)
```

也可以使用 ``gensym`` 函数，来自动生成一个系统唯一的符号，这在一些宏展开的实现中，是必须的：

```racket
(define s (gensym))
```

``string->uninterned-symbo`` 函数，可以把一个字符串转成唯一符号：

```racket
(eq? [string->uninterned-symbol "a"] [string->uninterned-symbol "a"]) ;#f
```

## 关键词 ##

*关键词*， *Keyword* ，是 *racket* 中新的概念，感觉跟其它编程语言中的“关键词参数”是一样的，具体的作用，也是除了函数参数中的“关键词参数”，我还不知道能做什么。

形式上，与 *Symbol* 类似，比如 ``#:hello`` ，但是它们是两种不同的类型：

```racket
(symbol? '#:app)
(keyword? '#:app)
```

使用上，放在参数前面就可以了：

```racket
#lang racket  

(define (lst a b #:a ka #:b kb) (list a b ka kb))
(lst 1 2 #:a 3 #:b 4)
(lst #:b 3 1 2 #:a 1)
```

有了 *keyword* 机制，可以在传参时，顺序上没有限制。非 *keyword* 参数，再按顺序匹配。


## 列表和结对 ##

这个前面已经使用过很多了。


```racket
#lang racket  

(cons 1 2)
(cons 1 '(2))
(cons 1 null)
(cons 1 empty)

(display "-----\n")

(empty? null)
(null? empty)

(display "-----\n")

(list? '(1 . 2))
(list? '(1 2))

(display "-----\n")

(pair? '(1 2))
(pair? '(1 . 2))
```

可以看出， *list* 是 *pair* 的特殊情况。


## 向量 ##

*向量*， *Vector* ，是 *racket* 预置的一种数据结构。如果说 *list* 是链表，那 *vector* 就像传统定长数组了，它可以在 ``O(1)`` 时间访问指定成员。

同时，跟 *strings* 一样， *vector* 也分可变的，或者不可变的。

形式上，可以看成加了 ``#`` 前缀的列表，或者是加了 ``#19`` 这种前缀的列表， ``#`` 后面可以有一个可选的长度。

如果指定了长度，则会使用最后一个成员填充到指定长度。


```racket
#(1 2 x3 display)
#8(1 2 x3 display)

(vector 1 2 3 'define)
(vector-ref #(1 2 3 define) 3)
```

## 三种不同的“等于” ##

下面介绍的“哈希表”，涉及三种不同的 *key* 的匹配方式，分别对于三种比较函数：

- ``equal?``
- ``eqv?``
- ``eq?``


``eq?`` 算是最严格的，它需要两者是相同的对象：

```racket
(eq? 1 1)
(eq? 1.0 1.0)
(eq? 1.0 1) ;#f
(eq? (expt 2 10) (expt 2 10))
(eq? (expt 2 10) 1024)
(eq? (expt 2 100) (expt 2 100)) ;#f
(eq? (cons 1 2) (cons 1 2)) ;#f
(eq? 1/2 2/4)
(eq? "hello" "hello")
(eq? "hello" (bytes->string/utf-8 #"hello")) ;#f
```

这里注意，大整数 ``(expt 2 100)`` 可能是不同对象。

``eqv?`` ，是在 ``eq?`` 基础上，有一些“放宽”，在数字：

```racket
(eq? (expt 2 100) (expt 2 100)) ;#f
(eqv? (expt 2 100) (expt 2 100)) ;#t
```

``equal?`` 是最常用的判断，它是普遍意义上的“值”的比较（ ``eq?`` 和 ``eqv?`` 的 ``true`` 肯定也是 ``equal?`` 的 ``true``）：

```racket
(equal? 1.0 1) ;#f
(equal? (expt 2 100) (expt 2 100)) ;#t
(equal? (cons 1 2) (cons 1 2)) ;#t
(equal? "hello" (bytes->string/utf-8 #"hello")) ;#t
(equal? '(1 2 3) '(1 2 3)) ;#t
```


## 哈希表 ##

*Hash Table* 也是一种 *racket* 内置的数据结构实现。它可以分为可变和不可变的两套，对于不可变的，我们也可以“扩展它构建新的结构”。同时，根据 *key* 的比较规则不同，又进一步分成三种子类，分别使用 ``equal?`` ``eqv?`` ``eq?`` 作为 *key* 的比较。

构建可变的 *Hash Table* ，可以使用 ``make-hash`` ``make-hasheqv`` ``make-hasheq`` 函数，构建不可变的结构，函数就分别是 ``hash`` ``hasheqv`` ``hasheq`` 。

可变的结构：

```racket
#lang racket  

(define ht (make-hash))
(hash-set! ht "first" 1)
(hash-set! ht 'second '(1 2 hello))
(hash-set! ht 3 'world)

(hash-ref ht 'second)
(hash-ref ht 3)
(hash-ref ht "first")
```

不可变的结构，除了 ``hash`` 函数，还可以使用 ``#hash`` 语法：

```racket
(define ht [hash "first" 1 'second "two" 3 'third])
(hash-ref ht 3)
; error
; (hash-set! ht "first" 2)

(define ht #hash(["first" . 1] [second . "two"] [3 . 'third]))
(hash-ref ht 'second)
```

``#hash`` 感觉是一个宏，里面不能再使用 *symbol* ，直接写的标识就是 *symbol* ，取值时要注意。

对于 *Hash Table* ，都可以使用 ``hash-set`` 方法得到一个新对象：

```racket
(define ht [hash "first" 1 'second "two" 3 'third])
(hash-ref ht 3)

(define new_ht (hash-set ht "four" 444))
(hash-ref new_ht "four")
(hash-ref new_ht "first")
```



## 封箱 ##

*封箱* 这个名字是我自己译的，指的就是 *Box* 这种数据类型。

它初看好像没啥用，我个人目前的看法，是它提供了一种直接的“引用”的表达能力，像“指针”。同时，网上有人提， *Box* 可能对于应用开发场景来说不重要，但是对于“语言开发”场景，它是很有必要的。

*Box* 的值打印出来时，会是像 ``'#&2`` 这种，以 ``#&`` 开头。

```
#lang racket  


(define p (box 1))
(define (add1 p1) (set-box! p (+ (unbox p) 1)))
(add1 p)
p

(define r 1)
(define (add2 v) (set! v (+ v 2)))
(add2 r)
r
```

从另一个方面来说，如果一个函数需要你传入 *Box* ，那么也就可以表示，这个函数会直接更改它，而不是返回一个新值。


## Void 和 Undefined ##

这是两个特殊的值， ``(void)`` 方法，可以得到 ``#<void>`` 类型的返回，它表示“无”，比如 ``display`` 函数就是没有返回的。

```racket
(void 1 2 3)
```

``#<undefined>`` ，可以在一些未初始化值的访问时出现（也可能报错）。


# 其它表达式细节 #

## 函数调用和参数 ##

### 函数的 apply 调用 ###

``apply`` 可以用于“展平”函数调用参数：

```racket
(+ 1 2 3)
(define (sum lst) (apply + lst))
(sum '(1 2 3))
```

基本可以多加一个参数：

```racket
(apply - 0 '(1 2 3))
(- 0 1 2 3)
```

### 函数的不定参数 ###

参数列表的最后一个参数，可以使用 *点* 分割，则最后一个参数是一个列表，表示剩下的不定参数：

```racket
(define (sum a b . c) (+ a b (apply + c)))
(sum 1 2 3 4 5 6 7 8 9 10)
```

### 函数的默认参数 ###

参数列表中，中括号括起来的，可以添加一个默认值：

```racket
(define (sum a [b 100] . c) (+ a b (apply + c)))
(sum 1)
```

### 函数的关键词参数 ###

关键词参数，可以和默认参数混合使用：

```racket
(define (sum a #:b [b 100] . c) (+ a b (apply + c)))
(sum #:b 10 1 2 3)
```

### 函数的根据参数匹配 ###

模式匹配这种时髦的东西，*racket* 自然不会错误。通过 ``case-lambda`` 可以实现根据实际参数个数，调用不同的逻辑：

```racket
#lang racket  

(define something 
  (case-lambda
    [(a) (+ a 1)]
    [(a b) (* a b)]
    [(a b c) ((+ a b) . - . c)]
))

(something 1)
(something 2 10)
(something 2 10 30)
```

## 多值返回和多值定义 ##

这里说的“多值返回”，是真正的多值返回，不是用列表搞的“模式匹配”。

使用 ``values`` 完成多值返回，对应的使用 ``define-values`` 完成多值定义：

```racket
(define-values (a b) (values 1 2))
a
b
```

## 多种数据绑定方式 ##

### let, let*, letrec ###

- ``let`` 只能在 ``body`` 中可见。
- ``let*`` 在其它 ``let`` 中也可见。
- ``letrec`` 表达式“提前”可见，可以在递归中使用。


``let`` 是最普通的：

```racket
(let ([a 1]) (+ a 1))
```

``let*`` 是在定义过程中，可以使用前面的值：

```racket
(let* ([a 1] [b (+ a 1)]) (+ a b))
```

``letrec`` 是可以“提前”使用将要定义的值，可以用于递归：

```racket
#lang racket  

(letrec
  ([last-of-lst
     (lambda (lst)
       (if [empty? (rest lst)]
         (first lst)
         (last-of-lst (rest lst))))])
  (last-of-lst '(1 2 3 4 5)))
```


### 命名绑定 ###

使用 ``let`` 时在后面跟一个名字，等于定义了一个这个名字的函数，并且用 ``let`` 的值作为参数马上调用，这个特性可以用于递归：

```racket
(let add ([a 4] [b 2])
  [if (= a 0) b (add (- a 1) (+ b b))])
```


### 多值绑定 ###

多值绑定是为了配合“多值返回”的一套实现， ``let-values``, ``let*-values``, ``letrec-values`` ：

```racket
(let-values (([a b c] [values 1 2 3])) [+ a b c])
```


## 多语句序列 ##

如果打算在一个表达式里面，做多件事，可以使用 ``begin`` 或者 ``begin0`` 把这个表达式包起来，就可以写多个语句了。

它们之前的不同在于， ``begin`` 返回最后一个表达式的值，而 ``begin0`` 返回第一个表达式的式。

```racket
(define (func a)
  (if (> a 1)
    [begin0
      a
      (display "a > 1\n")]
    [begin0
      0
      (display "a <= 1\n")]))

(func 1)
(func 2)
```

上面的代码注意区别 ``display`` 输出的内容，与 ``(func 1)`` 的返回值。

``when`` 和 ``unless`` 是类似 ``if`` 的功能，不过它们后面直接可以跟多条语句，而不用专门写 ``begin`` 了：

```racket
(define (func a) (when [> a 1]
                   [display "1\n"]
                   [display "2\n"]
                   "OK"))
(func 1)
(func 2)
```

## 引用与求值 ##

```racket
(list 1 2 3)
'(1 2 3)
(quote (1 2 3))
```

上面三个语句的返回是一样的。 *lisp* 系列语言最风骚的一个特点，就是它的语句就是 *列表*，所以紧接着的一个问题，就是什么时候应该对一个列表 *求值* ，什么时候就把它当成是一个 *列表结构* 。

当然，我们也可以理解成，总是会求值，只是，像 ``quote`` 这个函数，它求值的结构就是它的参数列表而已。

同时，又因为使用“列表结构”是如此普遍，所以针对 ``quote`` 函数的调用，专门给了它一个特殊形式，就是写成 ``'(1 2 3)`` 这种，它就相当于 ``(quote (1 2 3))`` 。

另外一个 ``quasiquote`` ，作用和 ``quote`` 是一样的，只是它在不求值的列表当中，可以混入部分的求值：

```racket
(quasiquote (1 2 (unquote (+ 1 2))))
```

使用 ``unquote`` 包起来的部分，又是需要求值的，有点像一个模板。

另外一个 ``unquote-splicing`` 和 ``unquote`` 类似，只是它后面的表达式需要返回一个 *list* ：

```racket
(quasiquote (1 2 (unquote-splicing '(1 2 3))))
```

这种引用，求值，反引用的复杂关系，就使得我们写的代码，到底是在求值，还是在生成另外一部分代码，之间的界限变得非常模糊了。

而这些元编程的基础结构，其地位之显赫，都有专门结构特殊对待的：

- ``'`` 是 ``quote``, ``'(1 2 3)``
- ````` 是 ``quasiquote`` , ```(1 2 3)``
- ``,`` 是 ``unquote`` , ```(1 2 ,(+ 1 2))``
- ``,@`` 是 ``unquote-splicing`` , ```(1 2 ,@(list 1 2))``


## 分支判断 ##

前面用过了 ``if`` ，更一般形式的是 ``cond`` ：

```racket
#lang racket  

(define (func a)
  (cond ([= a 1] 10)
        ([= a 2] 100)
        ([= a 3] 1000)
        (else 10000)))

(func 1)
(func 3)
```

普通情况下，还可以使用 ``case`` :

```racket
(define (func a)
  (case a
    [(1) 10]
    [(2) 100]
    [(3 4 5) 1000]
    [else 10000]))

(func 3)
(func 8)
```


## 专用参数 ##

*专用参数* 这个名字是我自己取的，文档中是 *parameterize* 。

我个人理解，这个机制，是处理“配置性”内容的绝佳选择，它融合了“变量”，“上下文”，“作用域”等概念。


使用方法上，先用 ``define`` 加 ``make-parameter`` 定义一个初始值，然后在使用的地方，用 ``parameterize`` “临时赋值”。

```racket
#lang racket  

(define times (make-parameter 10))
(define (func n) (* n (times)))

(func 10)

(parameterize ([times 2])
  [begin0
    (func (parameterize ([times 1]) (func 5)))
    (parameterize ([times 1000]) '())
    ])

(times)
```

- 使用“调用”获取参数值。
- 参数的值是在 ``(parameterize)`` 结构中，被层层限制作用域的。
- 离开 ``(parameterize)`` 之后，参数值会自动“还原”。



# 自定义结构 #

## 基本用法 ##

使用 ``struct`` 可以自定义一种结构：

```racket
(struct point (x y))
(define p (point 1 2))
```

定义之后，结构的名字，就是这个结构“实例化”的函数名。同时，会存在一系列与结构名相关的函数，可以用来处理结构的实例：

```racket
(point? p)
(point-x p)
```

结构可以被扩展，或者说，可以继续定义子结构：


```racket
(struct point (x y))
(struct point-3d point (z))
(define p (point-3d 1 2 3))
(point? p)
(point-3d? p)
(point-3d-z p)
;(point-3d-x p)
(point-x p)
```

``point-3d`` 是 ``point`` 的子结构，所以 ``p`` 在 ``point?`` 和 ``point-3d?`` 的结果都会是 ``#t`` 。

但是在获取属性值的时候，子结构只能获取自己的那部分，否则就需要使用父结构的方法，比如上面代码中的 ``(point-3d-x p)`` 就会报错。

结构也可以复制更新：

```racket
(struct point (x y))
(define p (point 1 2))
(define p2 (struct-copy point p (y 10)))
(point-x p2)
(point-y p2) ;10
```

## 透明结构和虚拟结构 ##

前面介绍的 ``struct`` 普通用法，可以正常得到一个结构实例。但是这个实例在后继的使用中，无法再被了解到构造时的情况，我们把实例打印出来，看到的也只是类型 ``#<point>`` 这样的信息，不知道在构造时的参数是什么。它自然是有利于“封装”的行为，不过有时在我们需要 *public* 行为时，就不是我们期望的了。

对此， *racket* 还有两种类型的扩展机制。 *透明类型 transparent* 和 *虚拟类型 previously fabricated* 。前者是解决 *public* 的一种自然想法，后者就有点天马行空的感觉了。


```racket
(struct point (x y))

(define (get-point x y) 
    (struct point (x y) #:transparent)
    (point x y)
  )
(get-point 1 2)
```

当在 ``struct`` 后面添加 ``#:transparent`` 关键字后，这个结构就是“透明类型”了。对于透明类型，现在能看到的只是打印出来的样子，从 ``#<point>`` 变成了 ``(point 1 2)`` ，至少能看到构造时的参数了。后面，还有反射相关的机制可以作用于它。

针对上面的代码，还可以了解到， ``struct`` 定义结构，并不是全局，而是有一个自然的作用域范围，可以在局部再定义同名的结构。

除了“透明类型”，还有一个 *虚拟类型 previously fabricated* ，这个机制，甚至可以让我们在结构被定义前，就预先开始使用这个结构了：

```racket
(define p #s(point 1 2))
```

这个像是使用向量的语句，是合法的。它定义了 ``p`` 是一个名为 ``point`` 的结构的实例。但是这个 ``point`` 到底是什么？目前为止，这个 ``point`` 确实还不存在。

```racket
(define p #s(point 1 2))
(struct point (x y) #:prefab)
(point? p)
(point-x p)
```

可以在后面使用 ``struct`` 再加上 ``#:prefab`` 再定义这个结构的具体形式。

它相对于其它语言的神奇之处，就是可以手写 ``#s(xxx 1 2)`` 这样的还没有被定义东西，在语法上是合法的。 *racket* / *scheme* 这样的语言，真是无时不刻在向我们示意“形式”与“逻辑”之间那无所谓般存在的界限。



## 更多的参数 ##

结构定义中，还可以在末尾加入更多的参数。这些参数，一部分是属性定义，比如像 ``#:mutable`` ，另一部分像是 Python 中的特殊方法，如 ``__str__`` ，定义了一个结构的行为表现，如 ``custom-write`` 。

``#:mutable`` ，结构的属性可变 ：

```racket
(struct point (x y) #:mutable)
(define p (point 1 2))
(point-x p)
(set-point-x! p 10)
(point-x p)
```

``#:auto-value`` ，定义一个自动值（不允许传参，但是可以获取属性值）：

```racket
(struct o ([x #:auto]) #:auto-value 1)
(struct point o ([y #:auto]) #:auto-value 2)
(define p (point))
(o-x p)
(point-y p)
```

能过层层嵌套，最终可以得到一个 0 参数值的结构。


``#:guard`` 参数预处理，子类型也会触发父级，但是只会传递有限参数：

```racket
(struct point (x y)
  #:transparent
  #:guard [lambda (x y type-name)
            (if (= x 0) (values x y)
              (values (* 2 x) (* 2 y)))])

(point 1 2)
(point 0 2)
```

在这里，也可以对参数作有效性的判断，返回错误， ``(error type-name "wrong")`` 。


``#:methods`` ，一些通用接口，像 Python 的特殊方法，类似有 ``__getitem__``  之类的。这里只演示一下 ``custom-write`` ：

```racket
(define (print-out ins port mode)
  [display port]
  [display mode]
  [display "hello"]
  [display "\n"]
)

(struct point (x y)
  #:methods
  gen:custom-write
  [(define write-proc print-out)]
)

(define p (point 1 2))
p
```

``gen:custom-write`` 的接口，会调用两次，一次是 *nowhere* ，不知道这样设计的初衷。


``#:property`` ，和 ``#:methods`` 一样的，比如 ``prop:procedure`` 是定义像 Python 中的 ``__call__`` 行为，即实例可以再次被“调用”。 ``#:property`` 和 ``#:methods`` 的区别，感觉后者是一个接口范围，像前面的，你需要定义一个 ``write-proc`` 方法。而 ``#:property`` 里就直接是具体的行为了，像 ``prop:procedure`` 直接一个函数就行。

```racket
(struct point (x y)
  #:property
  prop:procedure
  (lambda (self a b) (+ (point-x self) (point-y self) a b))
)

(define p (point 1 2))
(p 10 20)
```

``#:super`` ，跟前面的 ``扩展`` 是一样的能力，换了个写法：

```racket
(struct point (x y))
(struct point-3d (z) #:super struct:point)

(define p (point-3d 1 2 3))
(point-3d-x p)
```

这里还有一点， ``point`` 和 ``struct: point`` 是不同的东西。 ``struct?`` 和 ``struct-type?`` 也是不同的。


# 模块 #

## 基本用法 ##

*racket* 的模块机制，本身还是比较直观的，但是细节的变化上，又搞得很复杂。光是 ``require`` 的形式，就有三种：

```racket
(require demo) ;从包管理中导入
(require "demo.rkt") ;从相对路径中导入
(require 'demo) ;导入当前的一个 module 定义
```

模块的结构，基本是按目录结构，文件中要“导出”的方法，需要额外的使用 ``provide`` ，假设有一个 ``demo.rkt`` 是下面的内容：

```racket
#lang racket  


(provide get-point point-x)

(struct point (x y) #:transparent)
(define (get-point x y) (point x y))

(module* main #f
  (get-point 1 2))
```

最后的 ``module* main #f`` 相关于 Python 中的 ``if __name__ == '__main__'`` 。 ``provide`` 导出中，需要包括相关的函数，否则， ``get-point`` 出去的结构，也没办法获取相关数据的。

在另一个 ``a.rkwt`` 当中导入 ``demo.rkt`` ：

```racket
#lang racket

(require "demo.rkt")
(define p (get-point 1 2))
(point-x p)
#;(point-y p)
```

模块本身，也是一个函数调用的结果，和文件没有关系。文件上的表现，已经是一个加工了。

```racket
#lang racket  

(module demo (lib "racket/main.rkt")
  (display "in demo\n")
  (define (hello a) (display (string-join (list "Hello" a "\n"))))
  (provide hello))

(require 'demo)
(hello "world")
```

``lib`` 函数后面跟字符串 ``"racket/main.rkt"``，就相关于直接写 ``racket`` 了，表示模块的位置。而这里的 ``racket`` ，也即相当于一般情况下，把当前文件作为一个 ``module`` 快捷定义，最开头写的 ``#lang`` ，就是 ``module`` 完整形式的第二个参数。



## 模块相关路径 ##

除了当前位置的“相对路径”， *racket* 也有包寻找路径和对应的环境变量。

环境变量是 *PLTCOLLECTS* ，可以指定包寻找的位置。

默认的位置，可以通过下面的方法找到：

```racket
(require setup/dirs)
(find-user-collects-dir)
(get-collects-search-dirs)
```


## 子模块 ##

模块当中再通过 ``module`` 或者 ``module*`` ，声明的模块，就是子模块。 *racket* 中的子模块具有和普通模块一样的独立性，即，默认情况下，都不会随父模块导入导出，比如有一个 ``demo.rkt`` 文件：

```racket
#lang racket  

(module demo (lib "racket/main.rkt")
  (display "in demo\n")
  (define (hello a) (display (string-join (list "Hello" a "\n"))))
  (provide hello))
```

在同目录的另一个 ``a.rkt`` 文件中，如果写成：

```racket
#lang racket

(require "demo.rkt")
(hello "world")
```

是不行的，因为 ``demo.rkt`` 这个模块，并没有 ``hello`` 函数， ``hello`` 是在 ``demo.rkwt`` 里面的子模块 ``demo`` 里的，要正确引入，需要写成：

```racket
(require (submod "demo.rkt" demo))
(hello "world")
```


再看 ``module*`` 的行为，它更像是一个专门为内部使用而定义的子模块：

```racket
#lang racket  

(module demo (lib "racket/main.rkt")
  (define (add1 a) (+ a 1))
  (module demo-sub racket
    [display "in demo\n"]
    [define (hello a) (display (string-join (list "Hello" a "\n")))]
    [provide add1]
    [provide hello]
))

(define (add a b) (+ a b))

(require (submod 'demo demo-sub))
(module* main #f 
  (hello "world")
  (add1 10)
  (add 1 2))
```

``module*`` 加上 ``#f`` 可以使这个子模块看到当前模块的所有绑定。

还有一个 ``module+`` 的形式，类型 ``module*`` 加 ``#f`` ，但是 ``module+`` 可以多次声明一个名字的子模块，最终它们会自动合并：

```racket
(module+ main
  (add 1 2))

(module+ main
  (hello "world"))

(module+ main
  (hello "world2"))
```


# Contracts #

## 是什么 ##

*Contracts* 的作用，是“约束”，它描述了像函数的入参与结果是什么样子。“类型”只是“约束”的子集。比如，其它语言中的类型，可以指定说，“第一个参数是整数”，但是 *Contracts* 可以做到“第一个参数是大于 2 且小于 10 的整数”。

更神奇的是，在 *racket* 中，这套 *Contracts* 机制，完全是可插拔的，前面介绍的中，完全不管它，完全不影响代码和功能的正常使用。而且，它没有自己的“语法”，完全和普通代码一样，它也是普通代码。

用普通代码去约束普通代码。

其它语言中的，接口，泛型，在 *racket* 中没有任何特殊地，没有添加任何额外语法地，就这么实现了。

*Contracts* 的样子，大概是：

```racket
#lang racket  

(module demo racket
  (provide (contract-out [x positive?]))
  (define x 123))

(require 'demo)
x
```

``demo`` 模块中上，声明了一个 *contract* ，说 ``x`` 需要是正数。这时如果写成 ``(define x -1)`` 就会报错了。




## 绑定 ##

“绑定”就是 ``define`` 的那些标识，可以给它们都添加相应的 *Contracts* 。


```racket
#lang racket  

(define/contract
  x
  (or/c string? positive?)
  "hello")

(set! x -1) ;error
```

使用 ``define/contract`` 在定义的同时给出相应的约束。

使用 ``or/c`` 或者 ``and/c`` 可以组件约束的条件。

如果过程中出现了不满足 *Contracts* 的情况，则会报错。

## 函数 ##

### 一般形式 ###

函数中，有“参数”和“结果”，所以函数的 *Contracts* 也应该包含这两部分的信息，使用 ``->`` 函数表示 。

```racket
(module demo racket
  (provide (contract-out
             [add (-> positive? number? number?)]))
  (define (add a b) (+ a b)))

(require 'demo)
(add -1 2)
```

上面，描述了 ``add`` 函数的参数中，第一个是正数，所以 ``(add -1 2)`` 会报错。

``->`` 使用，也可以写成 ``(positive? number? . -> . number?)`` 有时会好看点。

函数也可以在定义时，直接给出约束：


```racket
(define/contract
  (add a b)
  (positive? number? . -> . number?)
  (+ a b))

(add 1 2)
(add -1 2)
```

### any any/c void? ###

- ``any`` 任何东西，系统都可以不检查。
- ``void?`` 空，比如没有返回。
- ``any/c`` 类型 ``any`` ，但是它限制了，只是能“单值”，不能是“多值”。


### 高阶函数 ###

嵌套使用 ``->`` 就可以了：


```racket
(define/contract
  (base-add a)
  (number? . -> . (number? . -> . number?))
  (lambda (b) (+ a b)))

(define/contract
  (all-add func lst)
  (-> (-> number? number?) list? list?)
  (map func lst))

((base-add 10) 1)

(all-add (lambda (n) (+ n 1)) '(1 2 3))
```


### 提示信息 ###


```racket
(define/contract
  (add a b)
  (->
    (flat-named-contract
      'a
      (lambda (x) (and (> x 10) (< x 100)))
    )
    positive?
    positive?)
  (+ a b))

(add 1 -1)
```

在对应参数/结果的位置上，可以使用 ``flat-named-contract`` 来给出具体的提示，否则，像 ``labmda`` 这种，会显示成代码的位置。


### 可选参数 ###

可选参数，就是带默认值，在参数列表后半部分的那些参数。这种形式下，需要使用 ``->*`` 来制定约束。 ``->*`` 有两部分输入参数，第一组是必须参数列表，第二组是可选参数列表。

```racket
(define/contract
  (add a b [c 1] [d 1])
  (->* (number? number?)
       (number? number?)
       number?)
  (+ a b c d))

(add 1 1 3 3)
```


### 不定参数 ###

不定参数，指参数个数不确定的情况。

它同样使用 ``->*`` ，不过需要配合一个 ``#:rest`` 关键词。

函数中定义不定参数，是使用的 ``.`` 这个符号来分割参数：

```racket
(define
  (max-abs n . lst)
  (if (empty? lst) n
    [apply max-abs
           (max (abs n) (abs (first lst)))
           (rest lst)]))

(max-abs -10 -2 3 4)
```

加上约束的话（估计在约束中加一个值必须大于 0）：

```racket
(define (list-and lst)
  (cond [(empty? lst) #t]
        [(eq? #f (first lst)) #f]
        [else (list-and (rest lst))]))

(define/contract
  (max-abs n . lst)
  (->* (number?)
       ()
       #:rest (lambda (lst) (list-and (map
                                        (lambda (x) (and (number? x) (> x 0)))
                                        lst)))
       ;#:rest (listof number?)
       number?)
  (if (empty? lst) n
    [apply max-abs
           (max (abs n) (abs (first lst)))
           (rest lst)]))

(max-abs 10 2 3 1)
```

``->*`` 的参数的完整形式，还可以多一个 ``#:rest`` ，后面是一个参数是列表的函数。

这里 ``and`` 是特殊函数，所以 ``(apply and ...)`` 会报错。


### 关键词参数 ###


关键词参数在约束定义中，使用普通的 ``->`` 就可以了，它支持关键词参数：

```racket
(define/contract
  (minus a #:other b)
  (-> number? #:other number?
      number?)
  (- a b))

(minus #:other 10 1)
```

关键词和可选参数一起：

```racket
(define/contract
  (minus a #:other [b 10])
  (->* (number?)
       (#:other number?)
       number?)
  (- a b))

(minus 1 #:other 10)
```


### case-lambda ###

``case-lambda`` 是一个有点像模式匹配的功能，约束定义上，对应使用 ``case->`` 。

```racket
(define/contract
  add
  (case->
    (number? number? . -> . number?)
    (number? . -> . number?))
  (case-lambda
    [(a b) (+ a b)]
    [(a) (+ 100 a)]))

(add 1)
(add 1 2)
```

### 结果与参数有关联 ###

广义地说，这种情况应该说成“参数与参数之间有依赖，或者结果与参数之间有依赖”。后半段，其实是一段“废话”，对于一个函数来说，除非是特别的像常数函数，其它的函数，基本上结果都依赖于参数。所以，这里说的约束上的机制，更多的是在于在使用时，我们自己想怎么定义这个约束而已，约束不是检查函数对错，而是站在调用者角度，防范错误地使用了。举一个例子，假设我们有一个错误的“加法”，在它的实现上， ``1 + 1 = 3`` ，约束不是考虑 ``1 + 1`` 的结果对不对，而是考虑调用 ``wrong-add`` 这个函数时，它的两个参数是否传对了，有时，它确实也是跟业务有关的。

同样也是加法， ``a + b`` ，假设，我们期望的是 ``b > a`` ，这种约束，需要使用 ``->i`` （ ``i`` 表示“indy dependent”）：

```racket
(define/contract
  (add a b)
  (->i ([a number?]
        [b (a) (and/c number? (>/c a))])
       (result (a b) (>=/c (+ a b))))
  (+ a b))

(add 1 2)
```

``->i`` ，后面有两组参数，第一组，是函数的参数，按顺序，后面的可以依赖前面的。第二组，是结果，可以依赖所有函数参数。

这里重早申一下 ``and/c``, ``>/c`` 这类函数。它们都是高阶函数，最后的结果，是仅接受一个参数的函数。


### 参数被修改的情况 ###

这里要介绍的，还是对 *result* 的检查，但是有一种情况，就是参数会被函数更改的情况。

这时，之前的 ``(result (a b) (...))`` 就没有办法正常工作了，因为 ``a, b`` 已经被更改，没有原始状态，可能就无法用于检查结果是否正常。这里， *racket* 提供的工具，作了一些细微的变化，允许 ``(...)`` 这部分先求值，如果需要，就可以事先把原始的 ``a`` ``b`` 保存一下（注意，求值的结果是一个单参数函数，而函数的执行永远是在原函数调用之后的，这时才有 ``result`` 值）：

```racket
(define/contract
  (add1 a)
  (->i ([a box?])
       (_ (a) (begin
                     (display (list "A ->" (unbox a)))
                     (display "\n")
                     (lambda (x) (begin
                                   (display (list "B ->" x))
                                   (display "\n")
                                   #t)))))
  (set-box! a (+ 1 (unbox a)))
  (unbox a))

(define x (box 1))
(define r (add1 x))
(display (list "C ->" r))
```

这个例子，写成 ``_`` ，那么后面的表达式就是“先求值”，会输出 "A -> 1" 。如果像原来那样，写成 ``result`` ，就会“后求值”，输出 "A -> 2"。


### 多值返回 ###

多值返回仍然使用 ``values`` 就可以了， 通过 ``values`` 返回多个单参数函数：

```racket
(define/contract
  (get)
  (-> (values number? number?))
  (values 10 20))

(get)
```


### 参数之间依赖 ###

最后一种情况，算是最复杂的情况，指的是，参数之间互相有依赖，比如，第一个参数是否符合约束条件，是要看第二个参数的情况。

```racket
(define (n-step proc inits)
  (let ([inc (apply proc inits)])
    (when inc
      (n-step proc [map (lambda (x) (+ x inc)) inits]))))


(define (f x)
  (printf "~s\n" x)
  (if (= x 0) #f -1))

(n-step f '(10 9))
```

上面的例子，运行是会报错的。因为 ``f`` 函数，它只能接收一个参数，但是 ``(apply proc inits)`` 会把 ``10`` 和 ``9`` 两个参数传给它。如果要为 ``n-step`` 的第一个参数 ``proc`` 写约束，需要在 ``->i`` 机制下，用到专门的一些功能方法去描述 ``proc`` 的参数与结果（函数的定义域和值域）：

```racket
(define/contract
  (n-step proc inits)
  (->i ([proc (inits) 
              (and/c (unconstrained-domain-> (or/c false/c number?))
                     (lambda (f) (procedure-arity-includes?
                                   f
                                   [length inits])))]
        [inits (listof number?)])
       ()
       any)
  (let ([inc (apply proc inits)])
    (when inc
      (n-step proc [map (lambda (x) (+ x inc)) inits]))))
```

通过 ``unconstrained-domain->`` 检查函数的结果，这里表示结果只能是 ``#f`` 或者一个数字。

在检查函数本身的时候，使用了 ``procedure-arity-includes?`` ，它的作用是检查指定函数是否可以接收指定个数的参数。


## 结构 ##

### 结构类型约束 ###

结构类型的约束，像是普通的类型声明，不过这些约束并不是用于静态分析的，只是运行时的额外，跟手写 ``if`` 效果是一样的。

```racket
(struct/contract
  point
  ([x number?] [y number?]))

(define (g) (point "a" 10))
```

这个例子，定义 ``point`` 时，指明了它的 ``x`` 和 ``y`` 都是数据。所以 ``(g)`` 的调用，就会出错了。


### 结构实例声明 ###

实例指的就是前面例子中 ``(g)`` 返回的东西，还是同样的例子：

```racket
(struct/contract
  point
  ([x number?] [y number?]))

(define/contract
  (g)
  (-> (struct/c point number? number?))
  (point 20 10))
```

在 ``(g)`` 函数的定义中，使用 ``struct/c`` 声明了它的返回值，是一个 ``point`` 结构，并且两个参数都是数字。

进一步，与函数的 ``->i`` 类型，也有 ``struct/dc`` ，可以声明结构的各属性之间有依赖的情况的约束规则。比如还是 ``point`` ，要让 ``y`` 一定比 ``x`` 要大的话：

```racket
(struct/contract
  point
  ([x number?] [y number?]))

(define/contract
  (g)
  (-> (struct/dc
        point
        [x number?]
        [y (x) (>/c x)]))
  (point 20 30))

(g)
```

## 抽象的 Contracts ##

抽象约束，第一眼看着像泛型，多想想又像接口。其实就是不管是约束，还是一组函数，其本身对于一些元素，并不在意它具体是什么，只要能满足条件，正常工作就行了（又像鸭子类型）。这里用 *Hash Table* 来做一个例子。


```racket
(define a #hash([name . "a"] [age . 10]))

(define (get-name p)
  (hash-ref p 'name))
(define (get-age p)
  (hash-ref p 'age))

(provide
  (contract-out
    #:exists person
    [get-name (person . -> . symbol?)]
    [get-age (person . -> . number?)]))
```

这个例子当中，只是定义了一个名为 ``a`` 的 *Hash Table* ，然后 ``get-name`` 和 ``get-age`` 都只是普通的操作。在定义约束的时候，通过 ``#:exists`` 给了一个 ``person`` 的概念，形式上，就看成了 ``get-name`` 和 ``get-age`` 都是在针对 ``person`` 这个东西在做操作， ``person`` 就是抽象出来的东西。


## 自定义 Contracts ##

TODO


# IO #

## 基本概念 ##

### 文件 ###

*racket* 中的 IO，基本由 *port* 来实现，而 *port* 的概念，类似于 Python 中的 *file* ，它可以是文件，socket，pipeline ，甚至是任何 *file like* 的东西。

```racket
#lang racket  

(define out (open-output-file "demo.txt" #:exists 'truncate))
(display "hello" out)
(close-output-port out)

(define in (open-input-file "demo.txt"))
(read-line in)
(close-input-port in)
```

*racket* 也有像 Python 中的 *with* 一样的方法：

```racket
(call-with-output-file "data.txt"
                       #:exists 'truncate
                       (lambda (out)
                         (display "hello" out)))

(call-with-input-file "data.txt"
                      (lambda (in)
                        (read-line in)))
```

对于不大的文件/port，可以直接用 ``port->string`` 读取它：

```racket
(define s (port->string (open-input-file "demo.txt") #:close? #t))
(printf "~a\n" s)
```


### 字符串 ###

*file like* 的东西，在 *racket* 中就简单了，直接 ``open-output-string`` 和 ``open-input-string`` 就可以了：

```racket
(define port (open-output-string))
(display "hello" port)
(get-output-string port)

(read-line (open-input-string "here"))
```

从上面也可以看出，我觉得不太方便的一点，就是在 *racket* 中， output 的 *port* 和 input 的 *port* 是明确分开的。


### 网络 ###

一个一次性的 echo 服务可以是：

```racket
#lang racket  

(display "Begin\n")

(define server (tcp-listen 8888 4 #t))
(define-values (srv-in srv-out) (tcp-accept server))
(define content (read-line srv-in))

(display content)
(display "\n")

(display content srv-out)
(display "\n" srv-out)

(close-output-port srv-out)
(tcp-close server)

(display "End\n")
```

这里有一个坑， ``close-output-port`` ，否则客户收不到响应。


### 子进程的输入输出 ###

```racket
(define-values (sp out in err)
               (subprocess #f #f #f "/bin/ls" "-l"))
(printf "\n~a\n" (port->string out))
```


### 内部管道 ###

这里的 *pipe* ，只是 *racket* 自己的实现，不是操作系统上的那个。

```racket
(define-values (in out) (make-pipe))
(display "hello" out)
(close-output-port out)
(printf "~a\n" (read-line in))
```

还是要记得 ``close-output-port`` 。


### 当前标准输入输出 ###

``display`` 默认使用当前标准输出， ``current-output-port`` 。错误输出 ``current-error-port`` 。标准输入 ``current-input-port`` 。这几个都是函数。


```racket
(display "Input:\n")
(define s (read-line (current-input-port)))
(display s (current-output-port))
(display "\n" (current-output-port))
(display "error" (current-error-port))
```


## racket 的三种输出格式 ##

这部分，相对其它编程语言，就要复杂一些了。

*racket* 中的数据，在输出的时候，有三种形式可供选择。为什么搞这么复杂呢？

举一个例子，一个字符串 ``hello`` ，它在输出的时候：

```racket
hello
"hello"
```

哪种是你希望的？没有确定的答案。

*racket* 还有一种 *quote* ，比如： ``'(+ 1 1)`` ，最后输出的时候：

```racket
(+ 1 1)
'(+ 1 1)
```

哪种是你希望的？

所以， *racket* 提供了三种输出的函数，它们行为上，有一些差异：

- ``print`` ，最“原始”，与 REPL 中的显示完全一样的输出。
- ``write`` ，终端层面的“原始”，去掉了 *quote* 的情况。
- ``display`` ，最贴近人阅读的形式，输出实际的字符字节，没有额外的引号。


从字符串：

```racket
(print "hello\n")
(display "\n")
(write "hello\n")
(display "\n")
(display "hello\n")
```

到符号：

```racket
(print '(+ 1 "1"))
(display "\n")
(write '(+ 1 "1"))
(display "\n")
(display '(+ 1 "1"))
```

就比较容易区分它们了。


在 ``printf`` 函数中，它有三种占位符，对应上面的三种输出：

- ``~a`` ， ``display``
- ``~s`` ， ``write``
- ``~v`` ， ``print``


```racket
(printf "~v\n" '(+ 1 "1"))
(printf "~s\n" '(+ 1 "1"))
(printf "~a\n" '(+ 1 "1"))
```

上面的结果是：

```racket
'(+ 1 "1")
(+ 1 "1")
(+ 1 1)
```

但是 ``printf`` 本身，又是 ``display`` 的行为。

上述的所有函数，都是工作在“字符”层面的，“字节”层面的有其它函数，如 ``read-byte`` ``write-byte`` 。


## 直接的序列化 ##

这里又是体现 lisp 的“数据即代码，代码即数据”的一个地方。同时，也和前面讲 *struct* 时， *prefab*, *#:transparent* 这些联系起来了。

```racket
(define-values (in out) (make-pipe))
(define a '(+ 1 1))
(list? a)
(write a out)
(close-output-port out)
(define b (read in))
(list? b)
```

上面是 *quote* 的情况，其它的 *struct* ，使用 *#:transparent* 无法直接实现序列化效果，需要配合其它工具（这里先不讨论了）：

```racket
(struct point (x y) #:transparent)
(define p (point 1 2))
(point-x p)

(define-values (in out) (make-pipe))
(write p out)
(close-output-port out)
(define p2 (read in))
(vector? p2)
```

即使这样，``read`` 进来的，也完成了 ``vector`` 的转化。

*prefab* 的结构，就可以直接序列化处理了：

```racket
(struct point (x y) #:prefab)
(define p (point 1 2))

(define-values (in out) (make-pipe))
(write p out)
(close-output-port out)
(define p2 (read in))
(vector? p2)
(point? p2)
(point-x p2)
```


# 正则表达式 #

*racket* 的正则表达式没有太多特别的地方，使用上，分字符串和字节串。

- 字符串： ``#px"\\d*?"``
- 字节串： ``#px#"\\d*?"``


这里注意，要 ``#px`` 才支持 ``\d`` 。 ``#rx`` 是不支持的。

因为 ``racket`` 字符串规则的限制，转义时需要写两个 ``\`` 。也可以不管转义，使用l ``regexp-quote`` 函数：

```racket
(regexp-quote "list?") ; list\\?
```

正则表达式的一般操作，都有对应的函数：

- 查询和匹配： ``regexp-match-positions`` 和 ``regexp-match`` ，及 ``regexp-match?`` 。
- 切分： ``regexp-split`` 。
- 替换： ``regexp-replace`` 和 ``regexp-replace*`` （带 ``*`` 是替换所有，否则只替换第一个）。


一些例子：

```racket
(define s (regexp-match #px"(.)(\\d+)" "abc123"))
(list-ref s 2)
```

替换的：

```racket
(regexp-replace* #px"(.*?)(\\d+)" "abc123" "\\2+\\1")
```


# 异常和 call/cc #

## 传统异常和 catch ##

通过 ``with-handlers`` 和 ``exn:fail*`` 系列对象，完成异常的捕获：

```racket
(with-handlers
  ([exn:fail:contract:divide-by-zero?
     (lambda (exc) (begin (display "here\n") 0))])
  (/ 1 0))
```

``with-handlers`` 后面的异常类型，可以有多个。当然，前提是要先知道异常类型。

不清楚的，也可以直接用 ``exn:fail?`` ：

```racket
(with-handlers
  ([exn:fail?
     (lambda (exc) (begin (display "here\n") 0))])
  (/ 1 0))
```

抛出异常使用 ``error`` 或者 ``raise`` 。 ``error`` 会把参数包装成 ``exn:fail`` 结构，而 ``raise`` 不会：

```racket
(with-handlers
  ([exn:fail?
       (lambda (exc) (begin (printf "~a\n" (exn-message exc)) 0))])
         (error "Hello"))
```

使用 ``exn-message`` 获取错误信息。如果是 ``raise`` ，就不能直接用 ``exn:fail?`` ，需要自己实现一个判断：

```racket
(with-handlers
  ([(lambda (v) (eq? v "Hello"))
     (lambda (v) (begin (printf "~a\n" v) 0))])
  (raise "Hello"))
```


## Prompt 和 Abort ##

在 *racket* 中，比异常捕获更通用的，是 *Prompt* 和 *Abort* 机制。它们，类型其它语言中的 *label* 和 *goto* ，但是会在异常未捕获时，自动 *goto* 到最近的一个 *label* 处。

它的结构，像是表达式版的 ``try`` 。

```racket
(define tag (make-continuation-prompt-tag 'a))

(+ 1
   (call-with-continuation-prompt
     (lambda () [begin
                  (display "here\n")
                  (abort-current-continuation
                    tag
                    (lambda () 10))
                  (+ 1 1)])
     tag)
)
```

这个例子中，先通过 ``make-continuation-prompt-tag`` 创建一个 *label* 。然后表达式中的部分，使用 ``call-with-continuation-prompt`` *try* 起来，它的第一个参数是一个函数，第二个参数是 *label* 。

在第一个参数函数中，就可以控制 ``abort-current-continuation`` 带着一个新函数，跳到指定的 *label* 处了。

``make-continuation-prompt-tag`` 创建的 *label*，也可以使用 ``default-continuation-prompt-tag`` 方法代替。

``abort-current-continuation`` 只可以往父级的 *prompt* 跳，可以跨级：

```racket
(define tag-a (make-continuation-prompt-tag 'a))
(define tag-b (make-continuation-prompt-tag 'b))

(+ 1
   (call-with-continuation-prompt
     (lambda () [begin
                  (display "A\n")
                  (call-with-continuation-prompt
                    (lambda () [begin
                                 (display "B\n")
                                 (abort-current-continuation
                                   tag-a
                                   (lambda () 10))])
                    tag-b)
                  (+ 1 1)])
     tag-a)
)
```


## Continuation, call/cc ##


标题中的 ``call/cc`` 是 ``call-with-current-continuation`` ，它是 *scheme* 的一个传统技艺，在 *racket* 中有了一些扩展，用 ``call-with-composable-continuation`` 。

*Continuation* ，简单来说，就是表达式中的“坑位”。每次填坑的时候，都可以对一个即定的表达式重新求值。

我个人理解，它其实是对表达式求值过程的一个自动化的函数化表达转换。

理解 ``call/cc`` 不难，也不需要用网上那些“理论”（其实是我不懂）：

```racket
(define ff void)

(+ 1 (call/cc (lambda (f)
                (set! ff f)
                (f 2)
                (printf "here"))))

(printf "|~a|\n" (ff 10))
```

上面代码的结果，对于大部份初次接触 ``call/cc`` 的人来说，肯定会非常意外的。

其实核心很简单：

**当 ``call/cc`` 的 ``lambda`` 的那个 ``f`` 被调用时，会中断当前表达式的求值过程，同时调用的结果会作为当前表达式的结果。**

熟悉 *yield* 的人，在这里肯定有似曾相似的感觉，虽然具体形式上有差异，不过都是表达式的值，是由另外一个地方的“参数”所影响与决定的。

``f`` 的行为本身是好理解的，整个表达式，把自己这部分换个坑，变成一个单参数的样子。比如，上面的代码， ``f`` 相当于： ``lambda (hole) (+ 1 hole)`` 。

执行流程的改变，跟 ``call/cc`` 表达式本身没有关系，关键是那个 ``f`` 有没有被调用。 ``|~a|`` 那里，因为 ``ff`` 被调用了，所以 ``printf`` 就没有作用了。（ ``printf`` 本身没有返回值， ``ff`` 调用后，它的返回值就作为表达式返回值。同时，因为 ``ff`` 的调用， ``printf`` 的调用过程即当前表达式的求值过程被中断，也就看不到 ``printf`` 的效果了。）

接下来，要尝试搞清楚，我们说的“当前表达式”，到底是一个怎样的范围。还是刚才的例子：

```racket
(define ff void)

(+ 1 (call/cc (lambda (f)
                (set! ff f)
                (f 2)
                (printf "here"))))

(printf ">~a<\n"
        (printf "|~a|\n" (ff 10)))

(printf ">~a<\n"
        (printf "|~a|\n" 100))
```

输出的结果是：

```text
3
11
|100|
>#<void>< 
```

结果验证了刚才对 ``printf`` 过程的解释。同时也可以看出，“当前表达式”的范围，是一行整个表达式。甚至额外把它包到一个函数里也不行：

```racket
(define ff void)

(+ 1 (call/cc (lambda (f)
                (set! ff f)
                (f 2))))

(define (get-result) (ff 10))

(printf ">~a<\n"
        (printf "|~a|\n" (get-result)))
```

这个行为，就跟是在“正则序”求值一样。（事实是否如此我并不知道）

那是否可以控制这个“当前表达式”的范围呢？ *racket* 中是可以的，就是用前面介绍过的 *prompt* 的 *tag* ：

```racket
(define tag-a (make-continuation-prompt-tag 'a))
(define ff void)

(call-with-continuation-prompt
  (lambda () 
    [+ 1 (call/cc (lambda (f)
                    (set! ff f)
                    (f 2)) tag-a)]) tag-a)

(define (get-result) (ff 10))

(printf ">~a<\n"
        (call-with-continuation-prompt
          [lambda ()
            (printf "|~a|\n" (get-result))] tag-a))
```

这个代码，``ff`` 被执行后，它的结果会作为 ``tag-a`` 这个 *tag* 范围的表达式的返回值，所以结果是：

```text
3
>11<
```

了解了 ``call/cc`` ，再看 *racket* 中的 ``call-with-composable-continuation`` 。

最大的区别是， ``call-with-composable-continuation`` 会在对 ``f`` 的调用求值后，再把这个求值带回原表达式，继续求值。而 ``f`` 的调用求值，是否返回，取决于用户是否显式地设置了 *label* ，如果设置了，则不返回。否则，返回，这样，实际上就会返回多个值。

```racket
(define tag-a (make-continuation-prompt-tag 'a))
(define tag-b (make-continuation-prompt-tag 'b))
(define ff void)
(define fff void)

(call-with-continuation-prompt
  (lambda ()
    (+ 1 (call-with-composable-continuation
           (lambda (f)
             (set! ff f)
             (f 20)) tag-a))
    ) tag-a)


(+ 1
   (call-with-continuation-prompt
     (lambda ()
       (+ 5
          (call-with-composable-continuation
            (lambda (f)
              (set! fff f)
              (f 20)
              #;100)
            tag-b))
       ) tag-b))



(define (get-result) (fff 100))
(printf ">~a<\n"
        (printf "|~a|\n" (get-result)))

```

``tag-b`` ，自己求值那里，看两步：

- 第一步， ``(f 20)`` ，根据 ``tag-b`` 的范围，会得到 25 的结果。
- 第二，把 25 替换到 ``call-with-composable-continuation`` 的位置，求值原表达式，得到 31 。


这里挻有意思的一点，就是 ``(f 20)`` 它求值的范围，和结果替换的范围，是不同的。

再看 ``(fff 100)`` ， ``fff`` 是 ``f`` 的范围，所以是 ``tag-b`` 的范围，那么 ``(fff 100)`` 的求值结果应该是 ``105`` 。 ``get-result`` 结果是 105 ，再把它代回原表达式求值，就得到了：

```text
|105|
>#<void><
```

如果不设定 ``call-with-continuation-prompt`` ，那么会返回两次：

```racket
(define ff void)

(+ 1 (+ 5
        (call-with-composable-continuation
          (lambda (f)
            (set! ff f)
            (f 100)))))

(printf ">~a<\n"
        (printf "|~a|\n" (ff 1000)))
```

最后的输出会是：

```racket
106
112
1006
|1006|
>#<void>< 
```

``(f 100)`` 和 ``(ff 1000)`` 都返回了两次，一次是代替整个表达式返回，另一次是作为自己返回，原表达式再继续求值。

不默认把“代替整个表达式返回”这个取消掉，这个设计挻谜的。


# 迭代 #

## for ##

虽然不是必须，为了方便， *racket* 提供了 ``for`` 一簇的方法。

```racket
(for ([i '(1 2 3)])
  (display i)
  (display i))
```

很直观的使用方式。也可以像 ``map`` 一样，使用 ``for/list`` ，它会返回列表：

```racket
(for/list ([i '(1 2 3)])
  (+ i i))
```

多个列表（取最短）：

```racket
(for/list ([i '(1 2 3)]
           [j '(a b c d e)])
  (list i j))
```

传统嵌套（得到 ``1 a, 1 b, 1 c, 2 a ...``）：

```racket
(for*/list ([i '(1 2)]
            [j '(a b c)])
  (list i j))
```

列表推导：

```racket
(for/list ([i '(1 2)]
           #:when (= i 1)
           [j '(a b c)]
           #:unless (equal? j 'b))
  (list i j))
```

``for/vector`` 和 ``for*/vector`` 可以生成向量结果。


*reduce* 的能力是 ``for/fold`` 和 ``for*/fold``：

```racket
(for/fold ([sum 0]) ([i '(1 2 3)])
  (+ sum i))
```

注意， ``for/fold`` 后面多了一个参数。



## 判断与查找 ##

``for/and`` 和 ``for/or`` 可以实现 ``all`` 和 ``some`` 的能力：

```racket
(for/and ([i '(1 2 3)])
  (i . = . 2))

(for/or ([i '(1 2 3)])
  (i . = . 2))
```

``for/first`` 和 ``for/last`` 是 ``find`` 之类的能力，它需要配合列表推导， *body* 是返回了：

```racket
(for/first ([i '(1 2 3 2)]
            #:when (= i 2))
           (list i (+ 1 i)))

(for/last ([i '(1 2 3 2)]
            #:when (not (= i 2)))
           (list i (+ 1 i)))
```


## 中断 ##

*racket* 还专门提供了一个 ``break`` ，实现迭代中的中断行为：

```racket
(for ([i '(1 2 3)]
      #:break (= i 3))
  (display i))
```


## 序列生成 ##

``in-range`` 是一个典型的序列生成器，三个参数是 *start/end/step* ：

```racket
(for ([i (in-range 10)])
  (display i))

(display "\n")

(for ([i (in-range 1 5)])
  (display i))

(display "\n")

(for ([i (in-range 1 20 3)])
  (display i))
```


## 关于性能 ##

迭代的对象，虽然是普通的 *list* 或者 *vector* *string* 之类都是可以正常工作：

```racket
(for/list ([i '(1 2 3)])
  (+ i 1))

(for/vector ([i #(1 2 3)])
  (+ i 1))
```

在迭代中，更快的处理方式，是把列表转成对应的“序列”，使用 ``in-list`` ``in-vector``：

```racket
(for/list ([i '(1 2 3)])
  (+ i 1))

(for/vector ([i #(1 2 3)])
  (+ i 1))
```

可能是出于典型的惰性计算考虑吧。

# 分支匹配和模式匹配 #

## 分支匹配 ##

确定形式的匹配，可以直接写：

```racket
(define val 1)
(match val
  [1 'one]
  [2 'two])

(match '(2 3)
  ['(1 2) 1]
  ['(2 3) 2])

(struct point (x y))
(match (point 2 3)
  [(point 1 2) "one"]
  [(point 2 3) "two"])

(match (point 2 4)
  [(point 1 2) "one"]
  [(point 2 3) "two"]
  [_ "other"])
```


## 模式匹配 ##

带参数的匹配项，会按“模式”进行参数匹配：

```racket
(define (m val)
  (match val
    [(list x) (+ x 1)]
    [(list x y) (+ x y)]))

(m '(1))
(m '(1 2))
```

结构体：

```racket
(struct point (x y))
(struct point2 (x y))

(define (m val)
  (match val
    [(point x y) (+ x y)]
    [(point2 x y) (* x y)]))

(m (point 2 3))
(m (point2 2 3))
```

*list* 和 *vector* 情况下，还可以用 ``...`` 表示相同省略 ：

```racket
(define (m val)
  (match val
    [(list 1 2 ...) 'first]
    [(list 2 ...) 'second]
    [_ 'other]))

(m '(1 2 2 2)) ;first
(m '(2 3)) ;other
```

或者加上参数，作不同参数的匹配：

```racket
(define (m val)
  (match val
    [(list 1 x ...) (apply + x)]
    [(list 2 x ...) x]
    [_ 'other]))

(m '(1 2 3 3))
(m '(2 3))
```


# 类和对象 #

# 组件 Unit #

# 反射 #

# 宏 #


