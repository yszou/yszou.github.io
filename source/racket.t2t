Racket 语言学习参考
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/racket.html
%!format: !email
%%toc


# 安装与简介 #

*racket* 是一个比较现代化的 *scheme* 语言。它的 Hello World 是这样的：

```racket
#lang racket  

(display "helloworld")
```

可以直接使用：

```bash
sudo apt-get install racket
```

进行安装，完成之后，有一个 ``racket`` 的可执行程序/REPL ，及 ``drracket`` 这个开发环境/IDE。

``racket`` 可以直接执行一个文件，如：

```bash
racket /home/zys/temp/demo.rkt
```

*racket* 提供了编译器，可以直接编译得到可执行程序。


# 基本语法 #

## 圆括号和方括号 ##

*scheme* 是用 S 表达式来组成的， *racket* 中这点并没有变化，但是 *racket* 中的 S 表达式，同时支持圆括号 ``()`` 和方括号 ``[]`` ，这个机制，在括号嵌套场景下，可以提供更好的视觉识别，如：

```racket
#lang racket  

(define [add1 a b] [+ a b])
(define (add2 a b) (+ a b))

(add1 1 2)
(add2 1 2)
```

## 注释 ##

```racket
#lang racket  

;这是传统的单行注释

#| 
这是 racket 的，可以多行的，
    #|
        可以嵌套的注释
    |#
|#

#; 注释一个 "单语法单元"
#;(display
    123) (display "1\n")
#;1 2 (display "2\n")
```

``#;`` 的行为比较特殊，其它语言中是没有的。


## 基本数据类型 ##

```racket
#lang racket  

1
3.14
1/3
(+ 1/3 1/3)
6.02e+23
1+2i
#t
#f
"string"
"string\"ss\""
(display "string\"ss\"\n")
"λx:(μα.α→α).xx"
"』▶😀😂"
(display "』▶😀😂\n")
```

基本数据类型有：整数，小数，实数，复数，布尔量，Unicode 字符串。

后面还会专门对内置的数据类型作介绍。


## 逻辑运算，条件判断 ##

TODO


## 定义与函数，匿名函数 ##

*定义* ，这里指的是 ``define`` ，其实应该说 *绑定* 的：

```racket
#lang racket  

(define a 1)
(define b 2)
(+ a b)
```

像是赋值，但是不能对同一个 *标识* ，进行重复的 ``define`` 。

``define`` 也可以用于函数的定义：

```
#lang racket  

(define [add a b] [+ a b])
(add 1 2)
```

使用 ``labmda`` 的匿名函数也行：

```racket
#lang racket  

(define add [lambda (a b) (+ a b)])
(add 1 2)
```

## 列表，迭代 ##

*列表* ，是 *scheme* 这类语言，最核心的一种数据结构。因为，我们写的代码，本身就是一个一个的 *列表* 。这个性质是一般大众化的语言没有的。


```racket
#lang racket  

(define add [lambda (a b) (+ a b)])
(add 1 2)

'(add 1 2)
'("add" "1" "2")
(list add 1 2)
(list "add" 1 2)
```

``list`` 函数，和 ``'`` 前缀，是同样的作用，就是得到一个列表。

*racket* 内置了很多针对列表的函数：

```racket
#lang racket  

(define any '(1 2 3 add "add"))
any
(length any)
(list-ref any 0)
(list-ref any 3)
(append any "1")
(append any '(2 "good"))
(reverse any)
```

``append`` 的第二个参数，类型不同，结果是不同的。如果第二个参数不是 *list* ，则会得到一个 *Pair* 。


*迭代* 的概念，类似于其它语言中的那一堆“函数式”方法，像 ``map`` ``filter`` ``reduce`` 之类的。

*racket* 中有 ``map`` ``filter`` ``foldl`` ``andmap`` ``ormap`` 。

```racket
#lang racket  

(map [lambda (n) (* n 2)] '[1 2 3 4 5])
(filter [lambda (n) (> n 4)] '[1 3 4 5 6 7 8])
(foldl [lambda (a b) (+ a b)] 0 '[1 2 3 4])
(andmap [lambda (n) (> n 4)] '[5 6])
(ormap [lambda (n) (> n 5)] '[5 6])
```

## 列表传统 ##

``map`` 之类的函数，对于“迭代”来说不是必须的，传统上，只需要 ``car`` 和 ``cdr`` 两个方法就可以完成对列表的遍历操作，基于它们，可以自己定义 ``map`` ``filter`` 等。在 *racket* 中，对应的方法是 ``first`` 和 ``rest`` ：

```racket
#lang racket  

(first '(1 2 3))
(rest '(1 2 3))
(first (rest '(1 2 3)))
(define l (cons 2 (cons 1 empty)))
(first l)
(rest l)
(empty? empty)
(empty? '())
(empty? '(1))
(empty? 1)
```

要写个简单的 ``map`` 就很容易了：

```racket
#lang racket  

(define (my-map f lst)
  (if [empty? lst]
    lst
    [cons (f [first lst]) (my-map f [rest lst])] ))

(my-map (lambda (n) (+ n 1)) '(1 2 3))
```

``car`` , ``cdr`` ，甚至是 ``pair`` 这类传统概念在 *racket* 中都是存在的，不过并不需要刻意去使用就是了：

```racket
#lang racket  

(pair? (cons 1 2))
(list? (cons 1 2))
(cons 1 2)
(car (cons 1 2))
(cdr (cons 1 2))
(car '(1 2 3))
(cdr '(1 2 3))
```


## 尾递归 ##

前面写的 ``my-map`` ，是一个比较直接的实现，它通过递归的方式，依次把 ``my-map`` 的结果作为 ``cons`` 的第二个参数。这种结构下，在反复自调用 ``my-map`` 的时候，都必须保存一个状态，这不是一种高效的表现。

改进的办法，是让反复自调用 ``my-map`` 时，都不依赖外部的任何信息，所有信息都通过“参数”体现。


```racket
#lang racket  

(define (my-map f lst)
  (define (iter f lst result)
    [if (empty? lst) (reverse result)
                         ;---------------------------;
      (iter f (rest lst) [cons (f (first lst)) result] )]
    )
  (iter f lst empty))

(my-map (lambda (n) (+ n 2)) '(1 2 3))
(my-map (lambda (n) (+ n 2)) empty)
```

上面的代码中，我们在每次自调用 ``my-app`` 时，都在小心地构造完整的 ``result`` 参数，这样，当最终满足结束迭代的条件时，直接返回 ``result`` 即可，不需要额外的“回溯”过程。


上面的代码，可以使用内置的 ``for/list`` （我猜它应该是一个宏）来完成：

```racket
#lang racket  

(define (my-map f lst)
             ;v;        ;v;
  (for/list ([i lst]) (f i)))

(my-map (lambda (i) (+ i 2)) '(1 2 3 4))
```

现在我们并没有讲过“变量”之类的概念，只有函数的“参数”。上面代码中的 ``i`` ，虽然看起来像“变量”，但在宏展开后，也就只是一个函数参数了。从形式上，我们可以猜出，对于 ``for/list`` 来说，它的第一个参数，是可以有多个迭代的取值对，这些取值对，第一个参数，是一个形式上的名字，而第二个参数，是一个表达式，会被“求值”。

写一些例子试试：

```racket
#lang racket  

(for/list ([a '(1 2 3)]) ((lambda (i) (+ i 2)) a))

(for/list ([a '(1 2 3)]
           [b (reverse '(1 2 3))])
  ([lambda (i k) (+ i k)] a b))
```

在 *racket* 中，它并不避讳使用递归，不是说一定要尽量使用“迭代”（迭代只是递归的一种特殊形式而已）。同时，因为语言机制，在 *racket* 中并不会有 *stack overflow* 问题（但是仍然会使用额外的更多内存）。


## 中缀语法 ##

这个，感觉像是 *racket* 自己玩花活，通过“点”符号， *racket* 定义了一种中缀表达式的格式：

```racket
#lang racket  

( (1 . + . 1) . + . 2 )
'(1 . + . 2)

(define (times base n) (base . * . n))
(10 . times . 2)
```

这种表达式，可以特定使用在，接收 2 个参数的函数上。


# 数据类型 #

## 布尔值 ##

``#t`` ``#f`` ``#T`` ``#F`` ，是布尔值。在逻辑判断中，所有不是 ``#f`` ``#F`` 的，都会被认为是 ``#t`` 。

使用 ``boolean?`` 可以做精确的类型判断：

```
#lang racket  

(boolean? #t)
(boolean? #T)
(boolean? 1)
(boolean? (not 1))
```


## 数字 ##

数字的情况在 *racket* 中复杂一些。

传统上，我们理解数字类型，可以分成 整数，浮点数，之类的。 *racket* 中也有这些概念，但在它们之上， *racket* 中的数字还被分成“精确数字” *exact* 和“非精确数字” *inexact* 。

分数的 ``1/2`` 和浮点数的 ``0.5`` ，是不同的。 ``1/2`` 是 *exact* ，而 ``0.5`` 是 *inexact* 。

精确的数字类型有这些：

- 整数， ``1``, ``999999``, ``-12``
- 分数， ``1/2``, ``-3/5``
- 复数， ``1+2i`` , ``1/3-2/5j``


不精确的数字类型有：

- 浮点， ``2.0``,  ``3.14e+10``
- 无限， ``+inf.0`` , ``-inf.0`` （必须是这两个）
- 非数字， ``+nan.0``, ``-nan.0``
- 复数， ``2.1+3.0i``, ``-inf.0+nan.0i``


在书写时，可以明确表示是否 *exact* ，使用 ``#e`` 或者 ``#i`` ， *racket* 可以自动转换：

```racket
#e0.5 ;1/2
#i1/2 ;0.5
#e0.1 ;1/10
```

二进制，八进制，十六进制，分别使用 ``#b``, ``#o``, ``#x`` ：

```
#xFF ;255
#b100100 ;36
#o10 ;8
```

精确值和非精确值之间使用 ``exact->inexact`` 和 ``inexact->exact`` 转换：

```racket
(exact->inexact 1/3)
(inexact->exact 0.3333) ;非常大的两个整数相除
```

不同类型的性能表现方面： 小的整数 > 浮点 > 超大整数和其它精确数


数字的比较，一般有两个方法， ``=`` 和 ``eqv?`` ，前者会尝试转换到精确值后再比较，后者不会：

```racket
(= 1 1.0) ;t
(= 1/3 0.333333) ;f
(eqv? 1 1.0) ;f
(eqv? 1 3/3) ;t
```

## 字符和字符串 ##

*racket* 中的 *字符* 指一个 Unicode 值。可以使用 ``#\`` ， ``#\u`` , ``#\space`` ``#\newline`` 这些表示法。同时，使用 ``char->integer`` 和 ``integer->char`` 完成数字和字符的转换：

使用 ``char=?`` 可以比较两个字符，或者 ``char-ci=?`` 忽略大小写：

```racket
(char=? #\a #\a)
(char-ci=? #\a #\A)
(char=? #\a #\u61)
(char=? #\』 #\』)
```

*字符串* 是固定长度的字符数组，使用双引号包起来。

```racket
(display "\u03BB\u03BB\n\u03BB")
```

字符串分为“可变”和“不可变”两种情况。直接写死的是不可变的字符串，通过一些方法，可以得到可变的字符串：

```racket
#lang racket  

(define s (make-string 10 #\.))
(display s)
(display "\n")
(string-set! s 2 #\x)
(display s)
```


## 字节和字节串 ##

*racket* 的 *字节*，就是 *0-255* 的整数：

```racket
(byte? 0) ;#t
(byte? 256) ;#f
```

*字节串* 是使用 *#* 前缀的字符串样子：

```racket
#"Hello"
"Hello"

(define b (make-bytes 10 0))
(bytes-set! b 0 97)
b
```

如果使用 ``display`` 函数去输出字节串的话，它会按 UTF-8 的编码方式处理。

字节串和字符串的相互转换，需要使用专门的函数实现：

```racket
(bytes->string/utf-8 #"\xCE\xBB") ;λ
```

## 符号 ##

符号 *Symbol* 是元编程中非常基础的概念，比如下面的代码：

```racket
(first '(define a 1))
(first '("define" a 1))
```

它们返回的是什么东西？

第一行代码，返回的就是 ``define`` 符号：

```racket
(eq? [first '(define a 1)] 'define)
```

也可以使用 ``gensym`` 函数，来自动生成一个系统唯一的符号，这在一些宏展开的实现中，是必须的：

```racket
(define s (gensym))
```

``string->uninterned-symbo`` 函数，可以把一个字符串转成唯一符号：

```racket
(eq? [string->uninterned-symbol "a"] [string->uninterned-symbol "a"]) ;#f
```

## 关键词 ##

*关键词*， *Keyword* ，是 *racket* 中新的概念，感觉跟其它编程语言中的“关键词参数”是一样的，具体的作用，也是除了函数参数中的“关键词参数”，我还不知道能做什么。

形式上，与 *Symbol* 类似，比如 ``#:hello`` ，但是它们是两种不同的类型：

```racket
(symbol? '#:app)
(keyword? '#:app)
```

使用上，放在参数前面就可以了：

```racket
#lang racket  

(define (lst a b #:a ka #:b kb) (list a b ka kb))
(lst 1 2 #:a 3 #:b 4)
(lst #:b 3 1 2 #:a 1)
```

有了 *keyword* 机制，可以在传参时，顺序上没有限制。非 *keyword* 参数，再按顺序匹配。


## 列表和结对 ##

这个前面已经使用过很多了。


```racket
#lang racket  

(cons 1 2)
(cons 1 '(2))
(cons 1 null)
(cons 1 empty)

(display "-----\n")

(empty? null)
(null? empty)

(display "-----\n")

(list? '(1 . 2))
(list? '(1 2))

(display "-----\n")

(pair? '(1 2))
(pair? '(1 . 2))
```

可以看出， *list* 是 *pair* 的特殊情况。


## 向量 ##

*向量*， *Vector* ，是 *racket* 预置的一种数据结构。如果说 *list* 是链表，那 *vector* 就像传统定长数组了，它可以在 ``O(1)`` 时间访问指定成员。

同时，跟 *strings* 一样， *vector* 也分可变的，或者不可变的。

形式上，可以看成加了 ``#`` 前缀的列表，或者是加了 ``#19`` 这种前缀的列表， ``#`` 后面可以有一个可选的长度。

如果指定了长度，则会使用最后一个成员填充到指定长度。


```racket
#(1 2 x3 display)
#8(1 2 x3 display)

(vector 1 2 3 'define)
(vector-ref #(1 2 3 define) 3)
```

## 三种不同的“等于” ##

下面介绍的“哈希表”，涉及三种不同的 *key* 的匹配方式，分别对于三种比较函数：

- ``equal?``
- ``eqv?``
- ``eq?``


``eq?`` 算是最严格的，它需要两者是相同的对象：

```racket
(eq? 1 1)
(eq? 1.0 1.0)
(eq? 1.0 1) ;#f
(eq? (expt 2 10) (expt 2 10))
(eq? (expt 2 10) 1024)
(eq? (expt 2 100) (expt 2 100)) ;#f
(eq? (cons 1 2) (cons 1 2)) ;#f
(eq? 1/2 2/4)
(eq? "hello" "hello")
(eq? "hello" (bytes->string/utf-8 #"hello")) ;#f
```

这里注意，大整数 ``(expt 2 100)`` 可能是不同对象。

``eqv?`` ，是在 ``eq?`` 基础上，有一些“放宽”，在数字：

```racket
(eq? (expt 2 100) (expt 2 100)) ;#f
(eqv? (expt 2 100) (expt 2 100)) ;#t
```

``equal?`` 是最常用的判断，它是普遍意义上的“值”的比较（ ``eq?`` 和 ``eqv?`` 的 ``true`` 肯定也是 ``equal?`` 的 ``true``）：

```racket
(equal? 1.0 1) ;#f
(equal? (expt 2 100) (expt 2 100)) ;#t
(equal? (cons 1 2) (cons 1 2)) ;#t
(equal? "hello" (bytes->string/utf-8 #"hello")) ;#t
(equal? '(1 2 3) '(1 2 3)) ;#t
```


## 哈希表 ##

*Hash Table* 也是一种 *racket* 内置的数据结构实现。它可以分为可变和不可变的两套，对于不可变的，我们也可以“扩展它构建新的结构”。同时，根据 *key* 的比较规则不同，又进一步分成三种子类，分别使用 ``equal?`` ``eqv?`` ``eq?`` 作为 *key* 的比较。

构建可变的 *Hash Table* ，可以使用 ``make-hash`` ``make-hasheqv`` ``make-hasheq`` 函数，构建不可变的结构，函数就分别是 ``hash`` ``hasheqv`` ``hasheq`` 。

可变的结构：

```racket
#lang racket  

(define ht (make-hash))
(hash-set! ht "first" 1)
(hash-set! ht 'second '(1 2 hello))
(hash-set! ht 3 'world)

(hash-ref ht 'second)
(hash-ref ht 3)
(hash-ref ht "first")
```

不可变的结构，除了 ``hash`` 函数，还可以使用 ``#hash`` 语法：

```racket
(define ht [hash "first" 1 'second "two" 3 'third])
(hash-ref ht 3)
; error
; (hash-set! ht "first" 2)

(define ht #hash(["first" . 1] [second . "two"] [3 . 'third]))
(hash-ref ht 'second)
```

``#hash`` 感觉是一个宏，里面不能再使用 *symbol* ，直接写的标识就是 *symbol* ，取值时要注意。

对于 *Hash Table* ，都可以使用 ``hash-set`` 方法得到一个新对象：

```racket
(define ht [hash "first" 1 'second "two" 3 'third])
(hash-ref ht 3)

(define new_ht (hash-set ht "four" 444))
(hash-ref new_ht "four")
(hash-ref new_ht "first")
```



## 封箱 ##

*封箱* 这个名字是我自己译的，指的就是 *Box* 这种数据类型。

它初看好像没啥用，我个人目前的看法，是它提供了一种直接的“引用”的表达能力，像“指针”。同时，网上有人提， *Box* 可能对于应用开发场景来说不重要，但是对于“语言开发”场景，它是很有必要的。

*Box* 的值打印出来时，会是像 ``'#&2`` 这种，以 ``#&`` 开头。

```
#lang racket  


(define p (box 1))
(define (add1 p1) (set-box! p (+ (unbox p) 1)))
(add1 p)
p

(define r 1)
(define (add2 v) (set! v (+ v 2)))
(add2 r)
r
```

从另一个方面来说，如果一个函数需要你传入 *Box* ，那么也就可以表示，这个函数会直接更改它，而不是返回一个新值。


## Void 和 Undefined ##

这是两个特殊的值， ``(void)`` 方法，可以得到 ``#<void>`` 类型的返回，它表示“无”，比如 ``display`` 函数就是没有返回的。

```racket
(void 1 2 3)
```

``#<undefined>`` ，可以在一些未初始化值的访问时出现（也可能报错）。


# 表达式 #


# 宏 #
