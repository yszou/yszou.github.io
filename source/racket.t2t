Racket 语言学习参考
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/racket.html
%!format: !email
%%toc


# 安装与简介 #

*racket* 是一个比较现代化的 *scheme* 语言。它的 Hello World 是这样的：

```racket
#lang racket  

(display "helloworld")
```

可以直接使用：

```bash
sudo apt-get install racket
```

进行安装，完成之后，有一个 ``racket`` 的可执行程序/REPL ，及 ``drracket`` 这个开发环境/IDE。

``racket`` 可以直接执行一个文件，如：

```bash
racket /home/zys/temp/demo.rkt
```

*racket* 提供了编译器，可以直接编译得到可执行程序。


# 基本语法 #

## 圆括号和方括号 ##

*scheme* 是用 S 表达式来组成的， *racket* 中这点并没有变化，但是 *racket* 中的 S 表达式，同时支持圆括号 ``()`` 和方括号 ``[]`` ，这个机制，在括号嵌套场景下，可以提供更好的视觉识别，如：

```racket
#lang racket  

(define [add1 a b] [+ a b])
(define (add2 a b) (+ a b))

(add1 1 2)
(add2 1 2)
```

## 注释 ##

```racket
#lang racket  

;这是传统的单行注释

#| 
这是 racket 的，可以多行的，
    #|
        可以嵌套的注释
    |#
|#

#; 注释一个 "单语法单元"
#;(display
    123) (display "1\n")
#;1 2 (display "2\n")
```

``#;`` 的行为比较特殊，其它语言中是没有的。


## 基本数据类型 ##

```racket
#lang racket  

1
3.14
1/3
(+ 1/3 1/3)
6.02e+23
1+2i
#t
#f
"string"
"string\"ss\""
(display "string\"ss\"\n")
"λx:(μα.α→α).xx"
"』▶😀😂"
(display "』▶😀😂\n")
```

基本数据类型有：整数，小数，实数，复数，布尔量，Unicode 字符串。

后面还会专门对内置的数据类型作介绍。


## 逻辑运算，条件判断 ##

TODO


## 定义与函数，匿名函数 ##

*定义* ，这里指的是 ``define`` ，其实应该说 *绑定* 的：

```racket
#lang racket  

(define a 1)
(define b 2)
(+ a b)
```

像是赋值，但是不能对同一个 *标识* ，进行重复的 ``define`` 。

``define`` 也可以用于函数的定义：

```
#lang racket  

(define [add a b] [+ a b])
(add 1 2)
```

使用 ``labmda`` 的匿名函数也行：

```racket
#lang racket  

(define add [lambda (a b) (+ a b)])
(add 1 2)
```

## 列表，迭代 ##

*列表* ，是 *scheme* 这类语言，最核心的一种数据结构。因为，我们写的代码，本身就是一个一个的 *列表* 。这个性质是一般大众化的语言没有的。


```racket
#lang racket  

(define add [lambda (a b) (+ a b)])
(add 1 2)

'(add 1 2)
'("add" "1" "2")
(list add 1 2)
(list "add" 1 2)
```

``list`` 函数，和 ``'`` 前缀，是同样的作用，就是得到一个列表。

*racket* 内置了很多针对列表的函数：

```racket
#lang racket  

(define any '(1 2 3 add "add"))
any
(length any)
(list-ref any 0)
(list-ref any 3)
(append any "1")
(append any '(2 "good"))
(reverse any)
```

``append`` 的第二个参数，类型不同，结果是不同的。如果第二个参数不是 *list* ，则会得到一个 *Pair* 。


*迭代* 的概念，类似于其它语言中的那一堆“函数式”方法，像 ``map`` ``filter`` ``reduce`` 之类的。

*racket* 中有 ``map`` ``filter`` ``foldl`` ``andmap`` ``ormap`` 。

```racket
#lang racket  

(map [lambda (n) (* n 2)] '[1 2 3 4 5])
(filter [lambda (n) (> n 4)] '[1 3 4 5 6 7 8])
(foldl [lambda (a b) (+ a b)] 0 '[1 2 3 4])
(andmap [lambda (n) (> n 4)] '[5 6])
(ormap [lambda (n) (> n 5)] '[5 6])
```

## 列表传统 ##

``map`` 之类的函数，对于“迭代”来说不是必须的，传统上，只需要 ``car`` 和 ``cdr`` 两个方法就可以完成对列表的遍历操作，基于它们，可以自己定义 ``map`` ``filter`` 等。在 *racket* 中，对应的方法是 ``first`` 和 ``rest`` ：

```racket
#lang racket  

(first '(1 2 3))
(rest '(1 2 3))
(first (rest '(1 2 3)))
(define l (cons 2 (cons 1 empty)))
(first l)
(rest l)
(empty? empty)
(empty? '())
(empty? '(1))
(empty? 1)
```

要写个简单的 ``map`` 就很容易了：

```racket
#lang racket  

(define (my-map f lst)
  (if [empty? lst]
    lst
    [cons (f [first lst]) (my-map f [rest lst])] ))

(my-map (lambda (n) (+ n 1)) '(1 2 3))
```

``car`` , ``cdr`` ，甚至是 ``pair`` 这类传统概念在 *racket* 中都是存在的，不过并不需要刻意去使用就是了：

```racket
#lang racket  

(pair? (cons 1 2))
(list? (cons 1 2))
(cons 1 2)
(car (cons 1 2))
(cdr (cons 1 2))
(car '(1 2 3))
(cdr '(1 2 3))
```


## 尾递归 ##

前面写的 ``my-map`` ，是一个比较直接的实现，它通过递归的方式，依次把 ``my-map`` 的结果作为 ``cons`` 的第二个参数。这种结构下，在反复自调用 ``my-map`` 的时候，都必须保存一个状态，这不是一种高效的表现。

改进的办法，是让反复自调用 ``my-map`` 时，都不依赖外部的任何信息，所有信息都通过“参数”体现。


```racket
#lang racket  

(define (my-map f lst)
  (define (iter f lst result)
    [if (empty? lst) (reverse result)
                         ;---------------------------;
      (iter f (rest lst) [cons (f (first lst)) result] )]
    )
  (iter f lst empty))

(my-map (lambda (n) (+ n 2)) '(1 2 3))
(my-map (lambda (n) (+ n 2)) empty)
```

上面的代码中，我们在每次自调用 ``my-app`` 时，都在小心地构造完整的 ``result`` 参数，这样，当最终满足结束迭代的条件时，直接返回 ``result`` 即可，不需要额外的“回溯”过程。


上面的代码，可以使用内置的 ``for/list`` （我猜它应该是一个宏）来完成：

```racket
#lang racket  

(define (my-map f lst)
             ;v;        ;v;
  (for/list ([i lst]) (f i)))

(my-map (lambda (i) (+ i 2)) '(1 2 3 4))
```

现在我们并没有讲过“变量”之类的概念，只有函数的“参数”。上面代码中的 ``i`` ，虽然看起来像“变量”，但在宏展开后，也就只是一个函数参数了。从形式上，我们可以猜出，对于 ``for/list`` 来说，它的第一个参数，是可以有多个迭代的取值对，这些取值对，第一个参数，是一个形式上的名字，而第二个参数，是一个表达式，会被“求值”。

写一些例子试试：

```racket
#lang racket  

(for/list ([a '(1 2 3)]) ((lambda (i) (+ i 2)) a))

(for/list ([a '(1 2 3)]
           [b (reverse '(1 2 3))])
  ([lambda (i k) (+ i k)] a b))
```

在 *racket* 中，它并不避讳使用递归，不是说一定要尽量使用“迭代”（迭代只是递归的一种特殊形式而已）。同时，因为语言机制，在 *racket* 中并不会有 *stack overflow* 问题（但是仍然会使用额外的更多内存）。


## 中缀语法 ##

这个，感觉像是 *racket* 自己玩花活，通过“点”符号， *racket* 定义了一种中缀表达式的格式：

```racket
#lang racket  

( (1 . + . 1) . + . 2 )
'(1 . + . 2)

(define (times base n) (base . * . n))
(10 . times . 2)
```

这种表达式，可以特定使用在，接收 2 个参数的函数上。


# 数据类型 #

## 布尔值 ##

``#t`` ``#f`` ``#T`` ``#F`` ，是布尔值。在逻辑判断中，所有不是 ``#f`` ``#F`` 的，都会被认为是 ``#t`` 。

使用 ``boolean?`` 可以做精确的类型判断：

```
#lang racket  

(boolean? #t)
(boolean? #T)
(boolean? 1)
(boolean? (not 1))
```


## 数字 ##

数字的情况在 *racket* 中复杂一些。

传统上，我们理解数字类型，可以分成 整数，浮点数，之类的。 *racket* 中也有这些概念，但在它们之上， *racket* 中的数字还被分成“精确数字” *exact* 和“非精确数字” *inexact* 。

分数的 ``1/2`` 和浮点数的 ``0.5`` ，是不同的。 ``1/2`` 是 *exact* ，而 ``0.5`` 是 *inexact* 。

精确的数字类型有这些：

- 整数， ``1``, ``999999``, ``-12``
- 分数， ``1/2``, ``-3/5``
- 复数， ``1+2i`` , ``1/3-2/5j``


不精确的数字类型有：

- 浮点， ``2.0``,  ``3.14e+10``
- 无限， ``+inf.0`` , ``-inf.0`` （必须是这两个）
- 非数字， ``+nan.0``, ``-nan.0``
- 复数， ``2.1+3.0i``, ``-inf.0+nan.0i``


在书写时，可以明确表示是否 *exact* ，使用 ``#e`` 或者 ``#i`` ， *racket* 可以自动转换：

```racket
#e0.5 ;1/2
#i1/2 ;0.5
#e0.1 ;1/10
```

二进制，八进制，十六进制，分别使用 ``#b``, ``#o``, ``#x`` ：

```
#xFF ;255
#b100100 ;36
#o10 ;8
```

精确值和非精确值之间使用 ``exact->inexact`` 和 ``inexact->exact`` 转换：

```racket
(exact->inexact 1/3)
(inexact->exact 0.3333) ;非常大的两个整数相除
```

不同类型的性能表现方面： 小的整数 > 浮点 > 超大整数和其它精确数


数字的比较，一般有两个方法， ``=`` 和 ``eqv?`` ，前者会尝试转换到精确值后再比较，后者不会：

```racket
(= 1 1.0) ;t
(= 1/3 0.333333) ;f
(eqv? 1 1.0) ;f
(eqv? 1 3/3) ;t
```

## 字符和字符串 ##

*racket* 中的 *字符* 指一个 Unicode 值。可以使用 ``#\`` ， ``#\u`` , ``#\space`` ``#\newline`` 这些表示法。同时，使用 ``char->integer`` 和 ``integer->char`` 完成数字和字符的转换：

使用 ``char=?`` 可以比较两个字符，或者 ``char-ci=?`` 忽略大小写：

```racket
(char=? #\a #\a)
(char-ci=? #\a #\A)
(char=? #\a #\u61)
(char=? #\』 #\』)
```

*字符串* 是固定长度的字符数组，使用双引号包起来。

```racket
(display "\u03BB\u03BB\n\u03BB")
```

字符串分为“可变”和“不可变”两种情况。直接写死的是不可变的字符串，通过一些方法，可以得到可变的字符串：

```racket
#lang racket  

(define s (make-string 10 #\.))
(display s)
(display "\n")
(string-set! s 2 #\x)
(display s)
```


## 字节和字节串 ##

*racket* 的 *字节*，就是 *0-255* 的整数：

```racket
(byte? 0) ;#t
(byte? 256) ;#f
```

*字节串* 是使用 *#* 前缀的字符串样子：

```racket
#"Hello"
"Hello"

(define b (make-bytes 10 0))
(bytes-set! b 0 97)
b
```

如果使用 ``display`` 函数去输出字节串的话，它会按 UTF-8 的编码方式处理。

字节串和字符串的相互转换，需要使用专门的函数实现：

```racket
(bytes->string/utf-8 #"\xCE\xBB") ;λ
```

## 符号 ##

符号 *Symbol* 是元编程中非常基础的概念，比如下面的代码：

```racket
(first '(define a 1))
(first '("define" a 1))
```

它们返回的是什么东西？

第一行代码，返回的就是 ``define`` 符号：

```racket
(eq? [first '(define a 1)] 'define)
```

也可以使用 ``gensym`` 函数，来自动生成一个系统唯一的符号，这在一些宏展开的实现中，是必须的：

```racket
(define s (gensym))
```

``string->uninterned-symbo`` 函数，可以把一个字符串转成唯一符号：

```racket
(eq? [string->uninterned-symbol "a"] [string->uninterned-symbol "a"]) ;#f
```

## 关键词 ##

*关键词*， *Keyword* ，是 *racket* 中新的概念，感觉跟其它编程语言中的“关键词参数”是一样的，具体的作用，也是除了函数参数中的“关键词参数”，我还不知道能做什么。

形式上，与 *Symbol* 类似，比如 ``#:hello`` ，但是它们是两种不同的类型：

```racket
(symbol? '#:app)
(keyword? '#:app)
```

使用上，放在参数前面就可以了：

```racket
#lang racket  

(define (lst a b #:a ka #:b kb) (list a b ka kb))
(lst 1 2 #:a 3 #:b 4)
(lst #:b 3 1 2 #:a 1)
```

有了 *keyword* 机制，可以在传参时，顺序上没有限制。非 *keyword* 参数，再按顺序匹配。


## 列表和结对 ##

这个前面已经使用过很多了。


```racket
#lang racket  

(cons 1 2)
(cons 1 '(2))
(cons 1 null)
(cons 1 empty)

(display "-----\n")

(empty? null)
(null? empty)

(display "-----\n")

(list? '(1 . 2))
(list? '(1 2))

(display "-----\n")

(pair? '(1 2))
(pair? '(1 . 2))
```

可以看出， *list* 是 *pair* 的特殊情况。


## 向量 ##

*向量*， *Vector* ，是 *racket* 预置的一种数据结构。如果说 *list* 是链表，那 *vector* 就像传统定长数组了，它可以在 ``O(1)`` 时间访问指定成员。

同时，跟 *strings* 一样， *vector* 也分可变的，或者不可变的。

形式上，可以看成加了 ``#`` 前缀的列表，或者是加了 ``#19`` 这种前缀的列表， ``#`` 后面可以有一个可选的长度。

如果指定了长度，则会使用最后一个成员填充到指定长度。


```racket
#(1 2 x3 display)
#8(1 2 x3 display)

(vector 1 2 3 'define)
(vector-ref #(1 2 3 define) 3)
```

## 三种不同的“等于” ##

下面介绍的“哈希表”，涉及三种不同的 *key* 的匹配方式，分别对于三种比较函数：

- ``equal?``
- ``eqv?``
- ``eq?``


``eq?`` 算是最严格的，它需要两者是相同的对象：

```racket
(eq? 1 1)
(eq? 1.0 1.0)
(eq? 1.0 1) ;#f
(eq? (expt 2 10) (expt 2 10))
(eq? (expt 2 10) 1024)
(eq? (expt 2 100) (expt 2 100)) ;#f
(eq? (cons 1 2) (cons 1 2)) ;#f
(eq? 1/2 2/4)
(eq? "hello" "hello")
(eq? "hello" (bytes->string/utf-8 #"hello")) ;#f
```

这里注意，大整数 ``(expt 2 100)`` 可能是不同对象。

``eqv?`` ，是在 ``eq?`` 基础上，有一些“放宽”，在数字：

```racket
(eq? (expt 2 100) (expt 2 100)) ;#f
(eqv? (expt 2 100) (expt 2 100)) ;#t
```

``equal?`` 是最常用的判断，它是普遍意义上的“值”的比较（ ``eq?`` 和 ``eqv?`` 的 ``true`` 肯定也是 ``equal?`` 的 ``true``）：

```racket
(equal? 1.0 1) ;#f
(equal? (expt 2 100) (expt 2 100)) ;#t
(equal? (cons 1 2) (cons 1 2)) ;#t
(equal? "hello" (bytes->string/utf-8 #"hello")) ;#t
(equal? '(1 2 3) '(1 2 3)) ;#t
```


## 哈希表 ##

*Hash Table* 也是一种 *racket* 内置的数据结构实现。它可以分为可变和不可变的两套，对于不可变的，我们也可以“扩展它构建新的结构”。同时，根据 *key* 的比较规则不同，又进一步分成三种子类，分别使用 ``equal?`` ``eqv?`` ``eq?`` 作为 *key* 的比较。

构建可变的 *Hash Table* ，可以使用 ``make-hash`` ``make-hasheqv`` ``make-hasheq`` 函数，构建不可变的结构，函数就分别是 ``hash`` ``hasheqv`` ``hasheq`` 。

可变的结构：

```racket
#lang racket  

(define ht (make-hash))
(hash-set! ht "first" 1)
(hash-set! ht 'second '(1 2 hello))
(hash-set! ht 3 'world)

(hash-ref ht 'second)
(hash-ref ht 3)
(hash-ref ht "first")
```

不可变的结构，除了 ``hash`` 函数，还可以使用 ``#hash`` 语法：

```racket
(define ht [hash "first" 1 'second "two" 3 'third])
(hash-ref ht 3)
; error
; (hash-set! ht "first" 2)

(define ht #hash(["first" . 1] [second . "two"] [3 . 'third]))
(hash-ref ht 'second)
```

``#hash`` 感觉是一个宏，里面不能再使用 *symbol* ，直接写的标识就是 *symbol* ，取值时要注意。

对于 *Hash Table* ，都可以使用 ``hash-set`` 方法得到一个新对象：

```racket
(define ht [hash "first" 1 'second "two" 3 'third])
(hash-ref ht 3)

(define new_ht (hash-set ht "four" 444))
(hash-ref new_ht "four")
(hash-ref new_ht "first")
```



## 封箱 ##

*封箱* 这个名字是我自己译的，指的就是 *Box* 这种数据类型。

它初看好像没啥用，我个人目前的看法，是它提供了一种直接的“引用”的表达能力，像“指针”。同时，网上有人提， *Box* 可能对于应用开发场景来说不重要，但是对于“语言开发”场景，它是很有必要的。

*Box* 的值打印出来时，会是像 ``'#&2`` 这种，以 ``#&`` 开头。

```
#lang racket  


(define p (box 1))
(define (add1 p1) (set-box! p (+ (unbox p) 1)))
(add1 p)
p

(define r 1)
(define (add2 v) (set! v (+ v 2)))
(add2 r)
r
```

从另一个方面来说，如果一个函数需要你传入 *Box* ，那么也就可以表示，这个函数会直接更改它，而不是返回一个新值。


## Void 和 Undefined ##

这是两个特殊的值， ``(void)`` 方法，可以得到 ``#<void>`` 类型的返回，它表示“无”，比如 ``display`` 函数就是没有返回的。

```racket
(void 1 2 3)
```

``#<undefined>`` ，可以在一些未初始化值的访问时出现（也可能报错）。


# 其它表达式细节 #

## 函数调用和参数 ##

### 函数的 apply 调用 ###

``apply`` 可以用于“展平”函数调用参数：

```racket
(+ 1 2 3)
(define (sum lst) (apply + lst))
(sum '(1 2 3))
```

基本可以多加一个参数：

```racket
(apply - 0 '(1 2 3))
(- 0 1 2 3)
```

### 函数的不定参数 ###

参数列表的最后一个参数，可以使用 *点* 分割，则最后一个参数是一个列表，表示剩下的不定参数：

```racket
(define (sum a b . c) (+ a b (apply + c)))
(sum 1 2 3 4 5 6 7 8 9 10)
```

### 函数的默认参数 ###

参数列表中，中括号括起来的，可以添加一个默认值：

```racket
(define (sum a [b 100] . c) (+ a b (apply + c)))
(sum 1)
```

### 函数的关键词参数 ###

关键词参数，可以和默认参数混合使用：

```racket
(define (sum a #:b [b 100] . c) (+ a b (apply + c)))
(sum #:b 10 1 2 3)
```

### 函数的根据参数匹配 ###

模式匹配这种时髦的东西，*racket* 自然不会错误。通过 ``case-lambda`` 可以实现根据实际参数个数，调用不同的逻辑：

```racket
#lang racket  

(define something 
  (case-lambda
    [(a) (+ a 1)]
    [(a b) (* a b)]
    [(a b c) ((+ a b) . - . c)]
))

(something 1)
(something 2 10)
(something 2 10 30)
```

## 多值返回和多值定义 ##

这里说的“多值返回”，是真正的多值返回，不是用列表搞的“模式匹配”。

使用 ``values`` 完成多值返回，对应的使用 ``define-values`` 完成多值定义：

```racket
(define-values (a b) (values 1 2))
a
b
```

## 多种数据绑定方式 ##

### let, let*, letrec ###

- ``let`` 只能在 ``body`` 中可见。
- ``let*`` 在其它 ``let`` 中也可见。
- ``letrec`` 表达式“提前”可见，可以在递归中使用。


``let`` 是最普通的：

```racket
(let ([a 1]) (+ a 1))
```

``let*`` 是在定义过程中，可以使用前面的值：

```racket
(let* ([a 1] [b (+ a 1)]) (+ a b))
```

``letrec`` 是可以“提前”使用将要定义的值，可以用于递归：

```racket
#lang racket  

(letrec
  ([last-of-lst
     (lambda (lst)
       (if [empty? (rest lst)]
         (first lst)
         (last-of-lst (rest lst))))])
  (last-of-lst '(1 2 3 4 5)))
```


### 命名绑定 ###

使用 ``let`` 时在后面跟一个名字，等于定义了一个这个名字的函数，并且用 ``let`` 的值作为参数马上调用，这个特性可以用于递归：

```racket
(let add ([a 4] [b 2])
  [if (= a 0) b (add (- a 1) (+ b b))])
```


### 多值绑定 ###

多值绑定是为了配合“多值返回”的一套实现， ``let-values``, ``let*-values``, ``letrec-values`` ：

```racket
(let-values (([a b c] [values 1 2 3])) [+ a b c])
```


## 多语句序列 ##

如果打算在一个表达式里面，做多件事，可以使用 ``begin`` 或者 ``begin0`` 把这个表达式包起来，就可以写多个语句了。

它们之前的不同在于， ``begin`` 返回最后一个表达式的值，而 ``begin0`` 返回第一个表达式的式。

```racket
(define (func a)
  (if (> a 1)
    [begin0
      a
      (display "a > 1\n")]
    [begin0
      0
      (display "a <= 1\n")]))

(func 1)
(func 2)
```

上面的代码注意区别 ``display`` 输出的内容，与 ``(func 1)`` 的返回值。

``when`` 和 ``unless`` 是类似 ``if`` 的功能，不过它们后面直接可以跟多条语句，而不用专门写 ``begin`` 了：

```racket
(define (func a) (when [> a 1]
                   [display "1\n"]
                   [display "2\n"]
                   "OK"))
(func 1)
(func 2)
```

## 引用与求值 ##

```racket
(list 1 2 3)
'(1 2 3)
(quote (1 2 3))
```

上面三个语句的返回是一样的。 *lisp* 系列语言最风骚的一个特点，就是它的语句就是 *列表*，所以紧接着的一个问题，就是什么时候应该对一个列表 *求值* ，什么时候就把它当成是一个 *列表结构* 。

当然，我们也可以理解成，总是会求值，只是，像 ``quote`` 这个函数，它求值的结构就是它的参数列表而已。

同时，又因为使用“列表结构”是如此普遍，所以针对 ``quote`` 函数的调用，专门给了它一个特殊形式，就是写成 ``'(1 2 3)`` 这种，它就相当于 ``(quote (1 2 3))`` 。

另外一个 ``quasiquote`` ，作用和 ``quote`` 是一样的，只是它在不求值的列表当中，可以混入部分的求值：

```racket
(quasiquote (1 2 (unquote (+ 1 2))))
```

使用 ``unquote`` 包起来的部分，又是需要求值的，有点像一个模板。

另外一个 ``unquote-splicing`` 和 ``unquote`` 类似，只是它后面的表达式需要返回一个 *list* ：

```racket
(quasiquote (1 2 (unquote-splicing '(1 2 3))))
```

这种引用，求值，反引用的复杂关系，就使得我们写的代码，到底是在求值，还是在生成另外一部分代码，之间的界限变得非常模糊了。

而这些元编程的基础结构，其地位之显赫，都有专门结构特殊对待的：

- ``'`` 是 ``quote``, ``'(1 2 3)``
- ````` 是 ``quasiquote`` , ```(1 2 3)``
- ``,`` 是 ``unquote`` , ```(1 2 ,(+ 1 2))``
- ``,@`` 是 ``unquote-splicing`` , ```(1 2 ,@(list 1 2))``


## 分支判断 ##

前面用过了 ``if`` ，更一般形式的是 ``cond`` ：

```racket
#lang racket  

(define (func a)
  (cond ([= a 1] 10)
        ([= a 2] 100)
        ([= a 3] 1000)
        (else 10000)))

(func 1)
(func 3)
```

普通情况下，还可以使用 ``case`` :

```racket
(define (func a)
  (case a
    [(1) 10]
    [(2) 100]
    [(3 4 5) 1000]
    [else 10000]))

(func 3)
(func 8)
```


## 专用参数 ##

*专用参数* 这个名字是我自己取的，文档中是 *parameterize* 。

我个人理解，这个机制，是处理“配置性”内容的绝佳选择，它融合了“变量”，“上下文”，“作用域”等概念。


使用方法上，先用 ``define`` 加 ``make-parameter`` 定义一个初始值，然后在使用的地方，用 ``parameterize`` “临时赋值”。

```racket
#lang racket  

(define times (make-parameter 10))
(define (func n) (* n (times)))

(func 10)

(parameterize ([times 2])
  [begin0
    (func (parameterize ([times 1]) (func 5)))
    (parameterize ([times 1000]) '())
    ])

(times)
```

- 使用“调用”获取参数值。
- 参数的值是在 ``(parameterize)`` 结构中，被层层限制作用域的。
- 离开 ``(parameterize)`` 之后，参数值会自动“还原”。



# 自定义结构 #

## 基本用法 ##

使用 ``struct`` 可以自定义一种结构：

```racket
(struct point (x y))
(define p (point 1 2))
```

定义之后，结构的名字，就是这个结构“实例化”的函数名。同时，会存在一系列与结构名相关的函数，可以用来处理结构的实例：

```racket
(point? p)
(point-x p)
```

结构可以被扩展，或者说，可以继续定义子结构：


```racket
(struct point (x y))
(struct point-3d point (z))
(define p (point-3d 1 2 3))
(point? p)
(point-3d? p)
(point-3d-z p)
;(point-3d-x p)
(point-x p)
```

``point-3d`` 是 ``point`` 的子结构，所以 ``p`` 在 ``point?`` 和 ``point-3d?`` 的结果都会是 ``#t`` 。

但是在获取属性值的时候，子结构只能获取自己的那部分，否则就需要使用父结构的方法，比如上面代码中的 ``(point-3d-x p)`` 就会报错。

结构也可以复制更新：

```racket
(struct point (x y))
(define p (point 1 2))
(define p2 (struct-copy point p (y 10)))
(point-x p2)
(point-y p2) ;10
```

## 透明结构和虚拟结构 ##

前面介绍的 ``struct`` 普通用法，可以正常得到一个结构实例。但是这个实例在后继的使用中，无法再被了解到构造时的情况，我们把实例打印出来，看到的也只是类型 ``#<point>`` 这样的信息，不知道在构造时的参数是什么。它自然是有利于“封装”的行为，不过有时在我们需要 *public* 行为时，就不是我们期望的了。

对此， *racket* 还有两种类型的扩展机制。 *透明类型 transparent* 和 *虚拟类型 previously fabricated* 。前者是解决 *public* 的一种自然想法，后者就有点天马行空的感觉了。


```racket
(struct point (x y))

(define (get-point x y) 
    (struct point (x y) #:transparent)
    (point x y)
  )
(get-point 1 2)
```

当在 ``struct`` 后面添加 ``#:transparent`` 关键字后，这个结构就是“透明类型”了。对于透明类型，现在能看到的只是打印出来的样子，从 ``#<point>`` 变成了 ``(point 1 2)`` ，至少能看到构造时的参数了。后面，还有反射相关的机制可以作用于它。

针对上面的代码，还可以了解到， ``struct`` 定义结构，并不是全局，而是有一个自然的作用域范围，可以在局部再定义同名的结构。

除了“透明类型”，还有一个 *虚拟类型 previously fabricated* ，这个机制，甚至可以让我们在结构被定义前，就预先开始使用这个结构了：

```racket
(define p #s(point 1 2))
```

这个像是使用向量的语句，是合法的。它定义了 ``p`` 是一个名为 ``point`` 的结构的实例。但是这个 ``point`` 到底是什么？目前为止，这个 ``point`` 确实还不存在。

```racket
(define p #s(point 1 2))
(struct point (x y) #:prefab)
(point? p)
(point-x p)
```

可以在后面使用 ``struct`` 再加上 ``#:prefab`` 再定义这个结构的具体形式。

它相对于其它语言的神奇之处，就是可以手写 ``#s(xxx 1 2)`` 这样的还没有被定义东西，在语法上是合法的。 *racket* / *scheme* 这样的语言，真是无时不刻在向我们示意“形式”与“逻辑”之间那无所谓般存在的界限。



## 更多的参数 ##

结构定义中，还可以在末尾加入更多的参数。这些参数，一部分是属性定义，比如像 ``#:mutable`` ，另一部分像是 Python 中的特殊方法，如 ``__str__`` ，定义了一个结构的行为表现，如 ``custom-write`` 。

``#:mutable`` ，结构的属性可变 ：

```racket
(struct point (x y) #:mutable)
(define p (point 1 2))
(point-x p)
(set-point-x! p 10)
(point-x p)
```

``#:auto-value`` ，定义一个自动值（不允许传参，但是可以获取属性值）：

```racket
(struct o ([x #:auto]) #:auto-value 1)
(struct point o ([y #:auto]) #:auto-value 2)
(define p (point))
(o-x p)
(point-y p)
```

能过层层嵌套，最终可以得到一个 0 参数值的结构。


``#:guard`` 参数预处理，子类型也会触发父级，但是只会传递有限参数：

```racket
(struct point (x y)
  #:transparent
  #:guard [lambda (x y type-name)
            (if (= x 0) (values x y)
              (values (* 2 x) (* 2 y)))])

(point 1 2)
(point 0 2)
```

在这里，也可以对参数作有效性的判断，返回错误， ``(error type-name "wrong")`` 。


``#:methods`` ，一些通用接口，像 Python 的特殊方法，类似有 ``__getitem__``  之类的。这里只演示一下 ``custom-write`` ：

```racket
(define (print-out ins port mode)
  [display port]
  [display mode]
  [display "hello"]
  [display "\n"]
)

(struct point (x y)
  #:methods
  gen:custom-write
  [(define write-proc print-out)]
)

(define p (point 1 2))
p
```

``gen:custom-write`` 的接口，会调用两次，一次是 *nowhere* ，不知道这样设计的初衷。


``#:property`` ，和 ``#:methods`` 一样的，比如 ``prop:procedure`` 是定义像 Python 中的 ``__call__`` 行为，即实例可以再次被“调用”。 ``#:property`` 和 ``#:methods`` 的区别，感觉后者是一个接口范围，像前面的，你需要定义一个 ``write-proc`` 方法。而 ``#:property`` 里就直接是具体的行为了，像 ``prop:procedure`` 直接一个函数就行。

```racket
(struct point (x y)
  #:property
  prop:procedure
  (lambda (self a b) (+ (point-x self) (point-y self) a b))
)

(define p (point 1 2))
(p 10 20)
```

``#:super`` ，跟前面的 ``扩展`` 是一样的能力，换了个写法：

```racket
(struct point (x y))
(struct point-3d (z) #:super struct:point)

(define p (point-3d 1 2 3))
(point-3d-x p)
```

这里还有一点， ``point`` 和 ``struct: point`` 是不同的东西。 ``struct?`` 和 ``struct-type?`` 也是不同的。


# 模块 #

## 基本用法 ##

*racket* 的模块机制，本身还是比较直观的，但是细节的变化上，又搞得很复杂。光是 ``require`` 的形式，就有三种：

```racket
(require demo) ;从包管理中导入
(require "demo.rkt") ;从相对路径中导入
(require 'demo) ;导入当前的一个 module 定义
```

模块的结构，基本是按目录结构，文件中要“导出”的方法，需要额外的使用 ``provide`` ，假设有一个 ``demo.rkt`` 是下面的内容：

```racket
#lang racket  


(provide get-point point-x)

(struct point (x y) #:transparent)
(define (get-point x y) (point x y))

(module* main #f
  (get-point 1 2))
```

最后的 ``module* main #f`` 相关于 Python 中的 ``if __name__ == '__main__'`` 。 ``provide`` 导出中，需要包括相关的函数，否则， ``get-point`` 出去的结构，也没办法获取相关数据的。

在另一个 ``a.rkwt`` 当中导入 ``demo.rkt`` ：

```racket
#lang racket

(require "demo.rkt")
(define p (get-point 1 2))
(point-x p)
#;(point-y p)
```

模块本身，也是一个函数调用的结果，和文件没有关系。文件上的表现，已经是一个加工了。

```racket
#lang racket  

(module demo (lib "racket/main.rkt")
  (display "in demo\n")
  (define (hello a) (display (string-join (list "Hello" a "\n"))))
  (provide hello))

(require 'demo)
(hello "world")
```

``lib`` 函数后面跟字符串 ``"racket/main.rkt"``，就相关于直接写 ``racket`` 了，表示模块的位置。而这里的 ``racket`` ，也即相当于一般情况下，把当前文件作为一个 ``module`` 快捷定义，最开头写的 ``#lang`` ，就是 ``module`` 完整形式的第二个参数。



## 模块相关路径 ##

除了当前位置的“相对路径”， *racket* 也有包寻找路径和对应的环境变量。

环境变量是 *PLTCOLLECTS* ，可以指定包寻找的位置。

默认的位置，可以通过下面的方法找到：

```racket
(require setup/dirs)
(find-user-collects-dir)
(get-collects-search-dirs)
```


## 子模块 ##

模块当中再通过 ``module`` 或者 ``module*`` ，声明的模块，就是子模块。 *racket* 中的子模块具有和普通模块一样的独立性，即，默认情况下，都不会随父模块导入导出，比如有一个 ``demo.rkt`` 文件：

```racket
#lang racket  

(module demo (lib "racket/main.rkt")
  (display "in demo\n")
  (define (hello a) (display (string-join (list "Hello" a "\n"))))
  (provide hello))
```

在同目录的另一个 ``a.rkt`` 文件中，如果写成：

```racket
#lang racket

(require "demo.rkt")
(hello "world")
```

是不行的，因为 ``demo.rkt`` 这个模块，并没有 ``hello`` 函数， ``hello`` 是在 ``demo.rkwt`` 里面的子模块 ``demo`` 里的，要正确引入，需要写成：

```racket
(require (submod "demo.rkt" demo))
(hello "world")
```


再看 ``module*`` 的行为，它更像是一个专门为内部使用而定义的子模块：

```racket
#lang racket  

(module demo (lib "racket/main.rkt")
  (define (add1 a) (+ a 1))
  (module demo-sub racket
    [display "in demo\n"]
    [define (hello a) (display (string-join (list "Hello" a "\n")))]
    [provide add1]
    [provide hello]
))

(define (add a b) (+ a b))

(require (submod 'demo demo-sub))
(module* main #f 
  (hello "world")
  (add1 10)
  (add 1 2))
```

``module*`` 加上 ``#f`` 可以使这个子模块看到当前模块的所有绑定。

还有一个 ``module+`` 的形式，类型 ``module*`` 加 ``#f`` ，但是 ``module+`` 可以多次声明一个名字的子模块，最终它们会自动合并：

```racket
(module+ main
  (add 1 2))

(module+ main
  (hello "world"))

(module+ main
  (hello "world2"))
```


# Contracts #

## 是什么 ##

*Contracts* 的作用，是“约束”，它描述了像函数的入参与结果是什么样子。“类型”只是“约束”的子集。比如，其它语言中的类型，可以指定说，“第一个参数是整数”，但是 *Contracts* 可以做到“第一个参数是大于 2 且小于 10 的整数”。

更神奇的是，在 *racket* 中，这套 *Contracts* 机制，完全是可插拔的，前面介绍的中，完全不管它，完全不影响代码和功能的正常使用。而且，它没有自己的“语法”，完全和普通代码一样，它也是普通代码。

用普通代码去约束普通代码。

其它语言中的，接口，泛型，在 *racket* 中没有任何特殊地，没有添加任何额外语法地，就这么实现了。

*Contracts* 的样子，大概是：

```racket
#lang racket  

(module demo racket
  (provide (contract-out [x positive?]))
  (define x 123))

(require 'demo)
x
```

``demo`` 模块中上，声明了一个 *contract* ，说 ``x`` 需要是正数。这时如果写成 ``(define x -1)`` 就会报错了。




## 绑定 ##

“绑定”就是 ``define`` 的那些标识，可以给它们都添加相应的 *Contracts* 。


```racket
#lang racket  

(define/contract
  x
  (or/c string? positive?)
  "hello")

(set! x -1) ;error
```

使用 ``define/contract`` 在定义的同时给出相应的约束。

使用 ``or/c`` 或者 ``and/c`` 可以组件约束的条件。

如果过程中出现了不满足 *Contracts* 的情况，则会报错。

## 函数 ##

### 一般形式 ###

函数中，有“参数”和“结果”，所以函数的 *Contracts* 也应该包含这两部分的信息，使用 ``->`` 函数表示 。

```racket
(module demo racket
  (provide (contract-out
             [add (-> positive? number? number?)]))
  (define (add a b) (+ a b)))

(require 'demo)
(add -1 2)
```

上面，描述了 ``add`` 函数的参数中，第一个是正数，所以 ``(add -1 2)`` 会报错。

``->`` 使用，也可以写成 ``(positive? number? . -> . number?)`` 有时会好看点。

函数也可以在定义时，直接给出约束：


```racket
(define/contract
  (add a b)
  (positive? number? . -> . number?)
  (+ a b))

(add 1 2)
(add -1 2)
```

### any any/c void? ###

- ``any`` 任何东西，系统都可以不检查。
- ``void?`` 空，比如没有返回。
- ``any/c`` 类型 ``any`` ，但是它限制了，只是能“单值”，不能是“多值”。


### 高阶函数 ###

嵌套使用 ``->`` 就可以了：


```racket
(define/contract
  (base-add a)
  (number? . -> . (number? . -> . number?))
  (lambda (b) (+ a b)))

(define/contract
  (all-add func lst)
  (-> (-> number? number?) list? list?)
  (map func lst))

((base-add 10) 1)

(all-add (lambda (n) (+ n 1)) '(1 2 3))
```


### 提示信息 ###


```racket
(define/contract
  (add a b)
  (->
    (flat-named-contract
      'a
      (lambda (x) (and (> x 10) (< x 100)))
    )
    positive?
    positive?)
  (+ a b))

(add 1 -1)
```

在对应参数/结果的位置上，可以使用 ``flat-named-contract`` 来给出具体的提示，否则，像 ``labmda`` 这种，会显示成代码的位置。


### 可选参数 ###

可选参数，就是带默认值，在参数列表后半部分的那些参数。这种形式下，需要使用 ``->*`` 来制定约束。 ``->*`` 有两部分输入参数，第一组是必须参数列表，第二组是可选参数列表。

```racket
(define/contract
  (add a b [c 1] [d 1])
  (->* (number? number?)
       (number? number?)
       number?)
  (+ a b c d))

(add 1 1 3 3)
```


### 不定参数 ###

不定参数，指参数个数不确定的情况。

它同样使用 ``->*`` ，不过需要配合一个 ``#:rest`` 关键词。

函数中定义不定参数，是使用的 ``.`` 这个符号来分割参数：

```racket
(define
  (max-abs n . lst)
  (if (empty? lst) n
    [apply max-abs
           (max (abs n) (abs (first lst)))
           (rest lst)]))

(max-abs -10 -2 3 4)
```

加上约束的话（估计在约束中加一个值必须大于 0）：

```racket
(define (list-and lst)
  (cond [(empty? lst) #t]
        [(eq? #f (first lst)) #f]
        [else (list-and (rest lst))]))

(define/contract
  (max-abs n . lst)
  (->* (number?)
       ()
       #:rest (lambda (lst) (list-and (map
                                        (lambda (x) (and (number? x) (> x 0)))
                                        lst)))
       ;#:rest (listof number?)
       number?)
  (if (empty? lst) n
    [apply max-abs
           (max (abs n) (abs (first lst)))
           (rest lst)]))

(max-abs 10 2 3 1)
```

``->*`` 的参数的完整形式，还可以多一个 ``#:rest`` ，后面是一个参数是列表的函数。

这里 ``and`` 是特殊函数，所以 ``(apply and ...)`` 会报错。


### 关键词参数 ###


关键词参数在约束定义中，使用普通的 ``->`` 就可以了，它支持关键词参数：

```racket
(define/contract
  (minus a #:other b)
  (-> number? #:other number?
      number?)
  (- a b))

(minus #:other 10 1)
```

关键词和可选参数一起：

```racket
(define/contract
  (minus a #:other [b 10])
  (->* (number?)
       (#:other number?)
       number?)
  (- a b))

(minus 1 #:other 10)
```


### case-lambda ###

``case-lambda`` 是一个有点像模式匹配的功能，约束定义上，对应使用 ``case->`` 。

```racket
(define/contract
  add
  (case->
    (number? number? . -> . number?)
    (number? . -> . number?))
  (case-lambda
    [(a b) (+ a b)]
    [(a) (+ 100 a)]))

(add 1)
(add 1 2)
```

### 结果与参数有关联 ###

广义地说，这种情况应该说成“参数与参数之间有依赖，或者结果与参数之间有依赖”。后半段，其实是一段“废话”，对于一个函数来说，除非是特别的像常数函数，其它的函数，基本上结果都依赖于参数。所以，这里说的约束上的机制，更多的是在于在使用时，我们自己想怎么定义这个约束而已，约束不是检查函数对错，而是站在调用者角度，防范错误地使用了。举一个例子，假设我们有一个错误的“加法”，在它的实现上， ``1 + 1 = 3`` ，约束不是考虑 ``1 + 1`` 的结果对不对，而是考虑调用 ``wrong-add`` 这个函数时，它的两个参数是否传对了，有时，它确实也是跟业务有关的。

同样也是加法， ``a + b`` ，假设，我们期望的是 ``b > a`` ，这种约束，需要使用 ``->i`` （ ``i`` 表示“indy dependent”）：

```racket
(define/contract
  (add a b)
  (->i ([a number?]
        [b (a) (and/c number? (>/c a))])
        [result (a b) (>=/c (+ a b))])
  (+ a b))

(add 1 2)
```

``->i`` ，后面有两组参数，第一组，是函数的参数，按顺序，后面的可以依赖前面的。第二组，是结果，可以依赖所有函数参数。

这里重早申一下 ``and/c``, ``>/c`` 这类函数。它们都是高阶函数，最后的结果，是仅接受一个参数的函数。


### 可变值 ###

### 多值返回 ###

### 不定结果 ###


## 模块 ##

## 结构 ##

## 抽象 Contracts ##

## 自定义 Contracts ##



