Go 的 HTTP 服务端实现
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/go-http.html
%!format: !email
%%toc


# 基本结构 #

go 官方提供了 ``net/http`` 来做 HTTP 协议的客户端及服务端处理。这里只说服务端部分。

虽然 go 的社区中有很多的 web 应用层框架，但是因为 ``net/http`` 的封装是比较高级的，所以社区建议也是以它为准。个人的理解，不管上层框架做了什么事，大概还是会依据相同的 API 设计。

另外， ``net/http`` 是同步的实现，先随大流吧。

```go
package main

import (
    "net/http"
)

func HelloHandler(response http.ResponseWriter, request *http.Request) {
    response.Write([]byte("Hello"))
}

func main () {
    http.HandleFunc("/", HelloHandler)
    println("Server is starting on 8888 ...")
    http.ListenAndServe(":8888", nil)
}
```

基本结构上， ``net/http`` 已经是像一个 Web 服务框架了：

- ``HandleFunc`` 完成路径的映射。
- ``HelloHandler`` 处理逻辑，参数中一个“响应”，一个“请求”。
- ``ListenAndServe`` 完成端口监听。


作为静态语言，几行代码就完成了一个 Web 服务端的实现，还是很能体会到“时代进步”的。


# 获取参数 #

``http.Request`` 是一个面向数据的比较原始的对象，不是面向 HTTP 抽象概念的封装（你需要了解 HTTP 的原始报文，才知道这句话说的什么）。

它没有提供像 ``GetParams()`` 之类的方法，只提供了 URL 对象，所以，你需要自己知道，获取 GET 参数得从 URL 中解析。


## GET 和 URL 对象 ##


```go
package main

import (
    "net/http"
    "fmt"
)

func HelloHandler(response http.ResponseWriter, request *http.Request) {
    var n string
    var name []string = request.URL.Query()["name"]
    if len(name) > 0 {
        n = name[0]
    }
    response.Write([]byte("Hello " + n))
}

func main () {
    http.HandleFunc("/", HelloHandler)
    fmt.Println("Server is starting on 8888 ...")
    http.ListenAndServe(":8888", nil)
}
```

通过 ``URL`` 的 ``Query()`` 方法返回的对象获取指定的参数。因为同名参数可以是多个（实践中几乎不会使用重复名字的参数），所以 ``name`` 是一个字符串列表，可能是一个空列表。所以在获取具体值之前要进行非空判断，否则会发生运行时错误。

``request.URL`` 是一个单独的 ``url.URL`` 对象，结构上类似标准的 *URI* 。

- ``[scheme:][//[userinfo@]host][/]path[?query][#fragment]``
- 或者 ``scheme:opaque[?query][#fragment]``


*URI* 的各部分，都可以直接取到。但是注意，这里没有 ``Hostname`` 和 ``Port`` ，这两个要通过方法获取。

``query`` 部分的解析，由 ``Query()`` 方法单独处理，返回的是 ``Values`` 结构，实际上就是一个 *Map* 。

这个 ``Values`` 提供了一个 ``Get()`` 方法，可以返回指定的 ``key`` 的第一个值，并且是 *decode* 之后的值。

```go
package main

import "net/url"
import "fmt"

func main() {
    u, err := url.Parse("https://zys.me?a=123&b=%E9%82%B9&b=1")
    if err != nil {
        panic(err)
    }
    fmt.Println(u.Query().Get("b"))
    fmt.Println(u.Query().Has("c"))
}
```

``Get()`` 方法才应该是获取 ``GET`` 参数的正解：

```go
func HelloHandler(response http.ResponseWriter, request *http.Request) {
    var n string = request.URL.Query().Get("name")
    response.Write([]byte("Hello " + n))
}
```

即使不存在 ``name`` 参数，也可以得到一个空字符串，不会报错。

GET 的参数也可以从获取 POST 参数的 ``Form`` 中一起获取到。


## 获取头 ##

使用 ``request.Header`` 获取请求的头， ``Header`` 是一个 *map* ，但是它的 ``Get()`` 方法对头的名字做了兼容性处理。所以不需要担心大小写，横杠问题。

```go
func HelloHandler(response http.ResponseWriter, request *http.Request) {
    var t string = request.Header.Get("Content-Type")
    fmt.Println(t)
    response.Write([]byte("Hello " + t))
}
```

这里写 ``Content-Type`` 或者 ``Content-type`` 都可以正常工作的。可以简单理解成，横杠写对，无视大小写就可以了。



## POST ##

POST 参数的获取，先要调用一下 ``ParseForm()`` ，然后可以从 ``Form`` 这个 *map* 中获取。


```go
package main

import (
    "net/http"
    "fmt"
)

func HelloHandler(response http.ResponseWriter, request *http.Request) {
    request.ParseForm()
    fmt.Println(request.Form)
    var n string = request.Form.Get("name")
    response.Write([]byte("Hello " + n))
}

func main () {
    http.HandleFunc("/", HelloHandler)
    fmt.Println("Server is starting on 8888 ...")
    http.ListenAndServe(":8888", nil)
}
```

- ``request.Form`` 会包括 ``GET`` 和 ``POST`` 的参数。
- 同名的参数会放在一个列表当中， ``POST`` 的在前， ``GET`` 的在后。（``Get()`` 会优先取到 ``POST`` 参数）


如果请求的 *Content-Type* 不是 ``application/x-www-form-urlencoded`` 的话：

客户端请求：

```python
# -*- coding: utf-8 -*-

import requests
res = requests.post('http://localhost:8888', data="123456", headers={"Content-Type": "plain/text"})
print(res.text)
```

服务端处理：


```go
package main

import (
    "net/http"
    "fmt"
    "io/ioutil"
)

func HelloHandler(response http.ResponseWriter, request *http.Request) {
    var content_type string = request.Header.Get("Content-Type")
    fmt.Println("Content-Type", content_type)

    var body []byte
    body, err := ioutil.ReadAll(request.Body)
    if err != nil {
        fmt.Println("Error", err)
        return
    }
    response.Write([]byte("Hello "))
    response.Write(body)
    response.Write([]byte("  "))
    response.Write([]byte(string(body)))
}

func main () {
    http.HandleFunc("/", HelloHandler)
    fmt.Println("Server is starting on 8888 ...")
    http.ListenAndServe(":8888", nil)
}
```

- 通过 ``request.Body`` 获取原始内容。
- ``request.Body`` 是一个 *io.ReadCloser* 接口实现。
- ``request.Body`` 虽然有 ``Close()`` ，但是不需要手工关闭。


## 获取文件 ##

文件的处理跟 POST 参数差不多，使用 ``ParseMultiparseForm()`` 代替 ``ParseForm()`` ：

客户端请求：

```python
# -*- coding: utf-8 -*-

import requests
f = open('/home/zys/temp/a.svg', 'rb')
res = requests.post('http://localhost:8888', files={"file": f}, data={"name": "123"})
print(res.text)
```

服务端处理：

```go
package main

import (
    "net/http"
    "fmt"
    "io/ioutil"
)

func HelloHandler(response http.ResponseWriter, request *http.Request) {
    fmt.Println(request.Method)
    var err error = request.ParseMultipartForm(1024 * 1024 * 5)
    if err != nil {
        fmt.Println(err)
        return
    }
    file, file_header, err := request.FormFile("file")
    if err != nil {
        fmt.Println(err)
        return
    }

    fmt.Println("file_name", file_header.Filename)
    fmt.Println("file_size", file_header.Size)
    fmt.Println(file_header.Header)

    body, err := ioutil.ReadAll(file)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(string(body))

    var name string = request.Form.Get("name")
    response.Write([]byte("Hello " + name))
}

func main () {
    http.HandleFunc("/", HelloHandler)
    fmt.Println("Server is starting on 8888 ...")
    http.ListenAndServe(":8888", nil)
}
```

- 先调用 ``request.ParseMultiparseForm(max)`` ，需要指定缓冲区的最大字节长度。它也会做 ``ParseForm()`` 的事。
- 使用 ``request.FormFile()`` 获取指定参数的文件内容。
- ``file_header`` 有文件基本信息，文件名，大小。
- 文件内容是通过 ``file`` ，作为一个文件对象处理的。


# 写头与非 200 响应 #

``response.Header()`` 方法可以获取响应中的头对象， ``Set()`` 方法完成值的设置：

```go
func HelloHandler(response http.ResponseWriter, request *http.Request) {
    var header http.Header = response.Header()
    header.Set("Content-Type", "text/ttt")
    response.Write([]byte("Hello"))
}
```

状态码使用 ``response.WriteHeader()`` 方法处理（奇怪的名字）：

```go
func HelloHandler(response http.ResponseWriter, request *http.Request) {
    response.WriteHeader(503)
    response.Write([]byte("Hello"))
}
```

``response.WriteHeader()`` 的调用必须在第一个 ``response.Write()`` 前，否则 ``response.Write()`` 会写入 200 的状态码，之后再调用 ``response.WriteHeader()`` 也没有作用了。


# 读写 Cookie #

## Cookie 结构 ##

*http.Cookie* 提供了 Cookie 的结构支持：

```go
type Cookie struct {
	Name  string
	Value string

	Path       string    // optional
	Domain     string    // optional
	Expires    time.Time // optional
	RawExpires string    // for reading cookies only

	// MaxAge=0 means no 'Max-Age' attribute specified.
	// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'
	// MaxAge>0 means Max-Age attribute present and given in seconds
	MaxAge   int
	Secure   bool
	HttpOnly bool
	SameSite SameSite
	Raw      string
	Unparsed []string // Raw text of unparsed attribute-value pairs
}
```

同时，它还有一个 ``String()`` 方法，可以直接用于单条 cookie 头的设置：

```go
func HelloHandler(response http.ResponseWriter, request *http.Request) {
    var cookie *http.Cookie = &http.Cookie{
        Name: "first",
        Value: "abcc",
    }
    response.Header().Add("Set-Cookie", cookie.String())
    response.Write([]byte("Hello"))
}
```


## 写 Cookie ##

除了直接使用 ``response.Header().Add()`` ，把 cookie 作为普通头处理之外， *http* 也提供了一个 ``SetCookie()`` 静态函数：

```go
func HelloHandler(response http.ResponseWriter, request *http.Request) {
    var cookie *http.Cookie = &http.Cookie{
        Name: "first",
        Value: "abcc",
    }
    http.SetCookie(response, cookie)
    response.Write([]byte("Hello"))
}
```


## 读 Cookie ##

*Cookie* 的获取，可以直接读取头自己解析，也可以通过 ``request`` 中的 ``Cookies()`` 和 ``Cookie(name)`` 方法处理。

``Cookies()`` 返回的是一个 ``http.Cookie`` 对象的列表。 ``Cookie(name)`` 就是一个 ``http.Cookie`` 对象。

```go
func HelloHandler(response http.ResponseWriter, request *http.Request) {
    fmt.Println("all", request.Cookies()[0])
    var cookie *http.Cookie
    cookie, err := request.Cookie("soup")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("name", cookie.Name)
    fmt.Println("value", cookie.Value)
    response.Write([]byte("Hello"))
}
```


# 多应用和路径映射 #

在最前面，我们看到的代码示例是：

```go
package main

import (
    "net/http"
)

func HelloHandler(response http.ResponseWriter, request *http.Request) {
    response.Write([]byte("Hello"))
}

func main () {
    http.HandleFunc("/", HelloHandler)
    println("Server is starting on 8888 ...")
    http.ListenAndServe(":8888", nil)
```

``http`` 下的几个直接的方法，像 ``ListenAndServe`` 和 ``HandleFunc`` 明显是一些快捷方法。

完整点的结构的话：

- ``http.Server`` 是定义一个服务。
- ``Multiplexer`` 是管理一套路径映射。 go 中没有 *Application* 的概念。
- ``Handler`` 是一个接口。


## Server 与多应用 ##

``http.Server`` 可以定义一个 HTTP 服务，并且使用已有的路径映射。


```go
package main

import (
    "net/http"
    "fmt"
)

func HelloHandler(response http.ResponseWriter, request *http.Request) {
    fmt.Println("all", request.Cookies()[0])
    var cookie *http.Cookie
    cookie, err := request.Cookie("soup")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println("name", cookie.Name)
    fmt.Println("value", cookie.Value)
    response.Write([]byte("Hello"))
}

func main () {
    http.HandleFunc("/", HelloHandler)
    fmt.Println("Server is starting on 8888 ...")
    go func(){
        var srv = &http.Server{
            Addr: "127.0.0.1:8889",
        }
        srv.ListenAndServe()
    }()
    http.ListenAndServe(":8888", nil)
}
```

在一个 *goroutine* 有另一外监听到 *8889* 的服务，同时在“主进程”中，原来的 *8888* 也是活动的，这样程序就不会直接结束。此时，两个端口都可以正常响应。

``http.HandleFunc()`` 会产生一个默认的 ``DefaultServeMux`` ， ``Server()`` 中没有指定 ``Handler`` 的话，就会使用它。

通过 *goroutine* 配合 ``Server`` ，启动多个服务是简单的，go 中的 ``Server`` 另外一些有价值的 API ，是“优雅关闭”的内置支持。

``Close()`` 方法会直接断掉连接，但是 ``Shutdown()`` 会等到当前连接已经处理完，才停止服务。这期间，会拒绝进的连接进入。


## 信号处理 ##

可以配合信号完成一个多服务的停止实现， go 中的信号处理直接就用的通道了：

```
package main

import (
    "net/http"
    "fmt"
    "strconv"
    "os"
    "os/signal"
    "syscall"
    "context"
    "time"
)

func HelloHandler(response http.ResponseWriter, request *http.Request) {
    time.Sleep(10 * time.Second)
    response.Write([]byte("Hello" + strconv.FormatInt(time.Now().Unix(), 10)))
}

func main () {
    http.HandleFunc("/", HelloHandler)
    var port_list = [...]int{8890, 8891, 8892, 8893}
    var srv_list = [len(port_list)]*http.Server{}
    for i, port := range port_list {
        var srv = &http.Server{
            Addr: ":" + strconv.Itoa(port),
        }
        srv_list[i] = srv
        go func(){
            srv.ListenAndServe()
        }()
    }
    //http.ListenAndServe(":8888", nil)
    var s_chan = make(chan os.Signal, 1)
    signal.Notify(s_chan, syscall.SIGINT)
    var root = context.Background()
    for {
        var s = <-s_chan
        switch s {
            case syscall.SIGINT:
                fmt.Println("exit...")
                for _, srv := range srv_list {
                    srv.Shutdown(root)
                }
                os.Exit(0)
        }
    }
}
```

运行这个服务，先访问 *8890* ，然后按 *Ctrl-C* ，再访问 *8891* 。

可以看到， *8890* 没有中断，但是 *8891* 已经拒绝连接了。要等到 *8890* 的请求正常响应之后，整个服务才会退出。


## Multiplexer 和 Handler ##


``Multiplexer`` 是一组路径映射，关联路径和对应的 ``Handler`` 。


``Handler`` 是一套接口，不是一个函数。前面使用 ``HandleFunc()`` 是一个简便方法。


``Multiplexer`` 的实例配置好之后，就可以把实例放到 *Server* 中启动。


```go
package main

import (
    "net/http"
    "fmt"
    "strconv"
    "time"
)

type handler struct {
    text string
}

func (h *handler) ServeHTTP(response http.ResponseWriter, request *http.Request){
    response.Write([]byte(h.text + strconv.FormatInt(time.Now().Unix(), 10)))
}


func main () {
    var mux = http.NewServeMux()
    mux.Handle("/", &handler{"HAHAHA"})
    var srv = &http.Server{
        Addr: ":8888",
        Handler: mux,
    }
    fmt.Println("8888...")
    srv.ListenAndServe()
}
```

*Server* 中的 ``Handler`` 参数，就是需要一个 ``Multiplexer`` 实例。

而另一方法，``Handler`` 接口，只需要一个 ``ServeHTTP()`` 方法，所以 ``HandleFunc()`` 更直接方便。


## Middleware ##

不考虑错误处理，中间件可以分为“前置”和“后置”。不管是接收 ``Handler`` 实例返回新实例，还是接收函数，返回新函数，都是比较好处理的。

不过 go 中没有 *Class* ，也没有继承（ ``struct`` 那套是什么鬼），所以函数式的方式我觉得更自然一些吧。


```go
package main

import (
    "net/http"
    "fmt"
    "strconv"
    "time"
)


func hello(response http.ResponseWriter, request *http.Request) {
    response.Write([]byte("Hello" + strconv.FormatInt(time.Now().Unix(), 10)))
}

func pre_log(handler func(http.ResponseWriter, *http.Request)) func(http.ResponseWriter, *http.Request) {
    return func(response http.ResponseWriter, request *http.Request){
        fmt.Println("PRE_LOG")
        handler(response, request)
    }
}


func main () {
    var mux = http.NewServeMux()
    mux.HandleFunc("/", pre_log(hello))
    var srv = &http.Server{
        Addr: ":8888",
        Handler: mux,
    }
    fmt.Println("8888...")
    srv.ListenAndServe()
}
```

高阶函数，跟 Python 的“装饰器”机制一样，不过 go 中就没有方便的语法糖可用了。

这样只是“理论上可行”，实际项目中，估计还是从 ``mux.HandleFunc`` 这一层动手，封装出的形式会更好看一些。



# 回调触发的时机 #

``Server`` 的结构，我们只用了 ``Addr`` 和 ``Handler`` ，但是它里面还有一些比较细节的参数配置，比如读写的时间，头的最大长度等等。

那么 Header 和 Body 既然是分开的，对于 ``HandleFunc`` 注册的函数，它是在 *Header* 完就调用了呢，还是要等 *Body* 完才调用？

```go
package main

import (
    "net/http"
    "fmt"
    "strconv"
    "time"
)


func hello(response http.ResponseWriter, request *http.Request) {
    fmt.Println("here")
    response.Write([]byte("Hello" + strconv.FormatInt(time.Now().Unix(), 10)))
    fmt.Println("finish")
}


func main () {
    var mux = http.NewServeMux()
    mux.HandleFunc("/", hello)
    var srv = &http.Server{
        Addr: ":8888",
        Handler: mux,
    }
    fmt.Println("8888...")
    srv.ListenAndServe()
}
```

对于上面的代码，通过 *telnet* 进行测试：

```text
zys@shopee:/home/zys >>> telnet localhost 8888
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
POST / HTTP/1.1
Host: localhost
Content-Length: 3

123
HTTP/1.1 200 OK
Date: Mon, 29 Nov 2021 18:43:08 GMT
Content-Length: 15
Content-Type: text/plain; charset=utf-8

Hello1638211377
```

可以看出，头接收完之后，函数就已经执行完了，不会等 *Body* 部分。

如果把 ``hello`` 改一下：

```go
func hello(response http.ResponseWriter, request *http.Request) {
    fmt.Println("here")
    request.ParseForm()
    var name string = request.Form.Get("name")
    response.Write([]byte(name + "Hello" + strconv.FormatInt(time.Now().Unix(), 10)))
    fmt.Println("finish")
}
```

在请求的 ``Content-Type`` 头是可以处理的情况之下，比如是 ``application/x-www-form-urlencoded`` ，那么 ``request.ParseForm()`` 这行会阻塞，直到 *Body* 接收完毕，再继承执行。

如果要直接读 ``request.Body`` ，也会阻塞：

```go
func hello(response http.ResponseWriter, request *http.Request) {
    fmt.Println("here")

    var body []byte
    body, err := ioutil.ReadAll(request.Body)
    if err != nil {
        fmt.Println("Error", err)
        return
    }

    response.Write([]byte(string(body) + "Hello" + strconv.FormatInt(time.Now().Unix(), 10)))
    fmt.Println("finish")
}
```


# 并发处理 #


# Chunk 传输 #


# WebSocket #



