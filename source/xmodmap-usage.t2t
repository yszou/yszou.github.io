xmodmap使用指南
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/xmodmap-usage.html
%%toc


=什么是 xmodmap=

xmodmap 是一个在 X 图形环境下用于修改键盘和鼠标按钮映射的工具。比如你可以使用它来实现鼠标的左右键互换，把 caps lock 键改成 ctrl 键， a 键改成 b 键等。

在介绍 xmodmap 的使用方法之前，先介绍一下系统是如何处理键盘的输入的。

- 键盘中的一个按键被按下时，会产生一个“信号”传给操作系统。
- 操作系统得到这个信号之后，检查此信号对应的处理方法。
- 执行对应的处理方法。


上面的流程当中，键盘某键产生的信号是不可变的，就是我们后面会提到的 //keycode// 是不会变的。你按不同的键，实际上可以看成是传入了不同的 //keycode// ，至于这些 //keycode// 要做什么事那是后话。也就是说，你按下了键盘上的 a 键与是否输入了一个 a ，它们之间是没有必然联系的。同时，那些操作系统当中对不同信号设置的处理方法也是没法直接改变的。而唯一可以改变的，就是它们之间的映射关系。这也是 xmodmap 它要做的事。

第二步，操作系统得到键盘输入的信号之后，就去检查对应的处理方法。这个处理方法已经预置了一套，比如键盘的上 a 键产生的 //keycode// 对应的处理方法就是输入一个 a 。我们也可以根据自己的需求，把 a 产生的 //keycode// 让它对应到另外一个处理方法上去，比如输入的是一个 b 。

我们可以使用 **xev** 这个工具来获取不同按钮产生的 //keycode// ，比如 a 这个按钮产生的 //keycode// 是 28， ``tab`` 键产生的 //keycode// 是 23。


=改变按键的行为=

我们先看普通键的行为如何被更改。之前后再介绍修饰键，比如 ``ctrl`` 键的行为如何修改。

假如我们希望得到的一个效果是，按下 a 按键，但是却是输入一个 b。

根据前面的介绍，我们要做的事，只是把 a 按键对应的处理方法，改成和 b 按键的一样就可以了。

```
xmodmap -e 'keycode 38 = b'
```

xmodmbp 使用 -e 参数后面跟一个表达式来实现相应的修改。

//keycode// 的作用是将一个按键与一串处理方法绑定，是一串方法，不是一个，即：

```
xmodmap -e 'keycode 38 = b E'
```

像这样一样，以空格分割，写多个处理方法。根据文档，你最多可以写8个处理方法，但是，一般只有前4个为可用的，第2个指定的是按住 ``shift`` 键时如何处理（第3个和第4个说的修饰键没接触过）。上面的代码的效果就是，直接按 a 键会输入一个 b ，按住 shift 键再按 a 键就是输入一个 E，大写的。

上面写的 b E 是两个处理方法，实际上，处理方法都是以整数表示的，在 **xev** 的输出中也可以看到， b 对应的是 //0x62// ，而 E 对应的是 //0x45// ，所以，上面的代码也可以写成：

```
xmodmap -e 'keycode 38 = 0x62 0x45'
```

完整的处理方法数值列表，可以在 //X11/keysymdef.h// 这个文件中找到。

另外一种修改按键行为的方法是使用 //keysym// 来转换预定义的处理方法。比如把 //0x62// 这个处理方法转换成 //0x63// ：

```
xmodmap -e 'keysym 0x62 = 0x63'
```

这段代码与下面等价：

```
xmodmap -e 'keysym b = c'
```

效果与下面的等价：

```
xmodmap -e 'keycode 56 = c'
```


=修改修饰键的行为=

修饰键指的就是像 ``ctrl`` ， ``alt`` 等这些键。一般是按住它们再去按其它键以产生不同的效果。前面也提到，绑定到某个按键的处理方法是一串，而不是一个。针对修饰键的处理，也是一个绑定的过程。具体一点，就是把一些处理方法绑定到特定的装饰方法当中。比如把左边那个 ``ctrl`` 键对应的 //0xffe3// 这个处理方法绑定到 ``control`` 这个装饰方法当中。当然，一个装饰方法中，可以有多个普通方法，左 ``ctrl`` 和右 ``ctrl`` 就是两个，你也可以添加你自己的。

我们先使用：

```
xmodmap -pm
```

来查看装饰方法的情况。比如我现在的是这样：

```
shift       Shift_L (0x32),  Shift_R (0x3e)
lock      
control     Control_L (0x25),  Control_L (0x42),  Control_R (0x69)
mod1        Alt_L (0x40),  Alt_R (0x6c),  Meta_L (0xcd)
mod2        Num_Lock (0x4d)
mod3      
mod4        Super_L (0x85),  Super_R (0x86),  Super_L (0xce),  Hyper_L (0xcf)
mod5        ISO_Level3_Shift (0x5c),  Mode_switch (0xcb)
```

可以看到，系统定义了 ``shift``, ``lock``, ``control``, ``mod1``, ``mod2``, ``mod3``, ``mod4``, ``mod5`` 这8种装饰方法。 ``shift`` 一般对应 Shift ``键，lock`` 对应 caps lock键，我已经把它干掉了。 ``control`` 对应左右的 ctrl 键， ``mod1`` 就是 alt 键了。通过 **xev** 程序，我得到我键盘上的那个 win 键对应的处理方法是 ``mod4`` 中的 Super_L 。

上面右键的处理方法后面括号中的数字，是表示的 //keycode// ，因为相同的处理方法可能是由不同的按键，即不同的 //keycode// 产生出来的。

要修改装饰键的行为，一般分成两步：

+ 将一个按键的处理方法改成已有几种特殊方法，像 Control_L 这些。（这步不是必须的，但是如果你把一个像 a 这种处理方法绑定到修饰方法上，会出问题，后面会尝试）
+ 把一种处理方法绑定到修饰方法上。


我们以 ``shift`` 这个修饰为例来说明。把指定处理方法绑定到修饰方法上，使用 //add// 来添加一个修饰方法绑定，比如：

```
xmodmap -e 'add shift = a'
```

这样， a 这个处理方法就会被当成 ``shift`` 修饰方法来用了。而因为默认地， a 这个处理方法，是由产生 //keycode// 为38的 a 按键触发的，所以，现在，当你按住 a 键，再按其它键时，就会……，挂掉，嗯，不错，就会挂掉。我不知道为什么。不过别简单，我们可以把它从修饰方法中移除：

```
xmodmap -e 'remove shift = a'
```

这样就可以了。那我们拿键盘右侧的 menu 键来试试吧。从 **xev** 中可以获取到，右侧的这个“菜单键”，它的 //keycode// 是135，当前对应的处理方法是名为“Menu”的 //0xff67// 方法。那我们就把这个处理方法添加到 ``shift`` 修饰方法当中试试：

```
xmodmap -e 'add shift = Menu'
```

这样，当你按住“菜单键”时，就和按住左边的 Shift 键一样了，可以输入大写字母。当然，同时“菜单键”还有它原来的一些行为，比如会输入 $ 符号什么的。这也是为什么，我们如果要修改修饰键，那么最好使用已经定义的那几种专为修饰键预定的处理方法，以避免产生问题。

所以，如果我们要完全把“菜单键”改成一个左 Shift 键，那么应该按上面提到的两个步骤做，首先：

```
xmodmap -e 'keycode 135 = Shift_L'
```

把它的处理方法改成 Shift_L ，而不使用原来的 Menu 。

这时，可能有人会想，Shift_L 方法不是已经绑定到相应的 ``shift`` 这个装饰方法了嘛，那我们已经达到目的了？当然不是，绑定装饰方法的处理方法，是对应到具体的 //keycode// 的，左 Shift 键产生的 Shift_L 方法显然和我们刚才定义的菜单键产生的 Shift_L 方法是有区别的。我们刚才定义会产生的 Shift_L 方法还没有绑定到 ``shift`` 这个装饰方法上。所以，现在的表现为，菜单键已经不具有以前的行为了（比如弹出一个菜单什么的），但是，它还仍未拥有修饰键的作用，我们还需要绑定一下：

```
xmodmap -e 'add shift = Shift_L'
```

再次把所有的 Shift_L 处理方法都绑定到 ``shift`` 这个装饰方法上。现在使用：

```
xmodmap -pm
```

可以看到下面这一行：

```
  shift       Shift_L (0x32),  Shift_R (0x3e),  Shift_L (0x87)
```

//0x87// 就是 135 ，也就是我们刚才自己添加的那个“菜单键”，现在，这个菜单键就完全被改成一个左 Shift 键了。

如果你是修改 caps lock 键的行为，那么记得需要使用 //remove// 把之前的修饰绑定移除：

```
xmodmap -e 'remove lock = xxx'
```


=修改鼠标按键行为=

修改鼠标的按键行为就简单很多了，直接使用 //pointer// 顺序指定各个按键的处理方法。处理方法与默认的按键号是一致的，比如处理方法1，对应1号按键，处理方法2对应2号按键。（最多有12个按键绑定，我们下面只考虑前3个就好了）

```
xmodmap -e 'pointer = 1 2 3'
```

这样什么也不会发生，它就是默认的设置。如果要交换鼠标的左右键，只需要让1号按键（第一位）对应到3号处理方法，就3号按键（第三位）对应1号处理方法：

```
xmodmap -e 'pointer = 3 2 1'
```

这样就实现了左右键互换。

=Fvwm中的修辞键使用=

在 Fvwm 中，通常使用 C 和 M 这些来使用 ``control`` 和 ``mod1`` 这些修饰方法，那要使用 ``mod4`` 怎么办呢？其实在 Fvwm 的文档中已经有说明了：

```
    X11 modifiers mod1 through mod5 are represented as the digits '1' through '5'. 
```

要使用一个 mod4 的修辞键可以这样写：

```
Key	1	A	4	GotoDeskAndPage 0 0 0
```

