WASI 和 WebAssembly
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/wasi
%!format: !email
%%toc



# 是什么东西？ #

*WASI* 的意思是 WebAssembly System Interface ，可以把它看成是一整套方案。

*WebAssembly* 是一种字节码格式，执行它需要对应的一种虚拟机。

我们一般不会手写 WebAssembly ，而是通过其它高级语言，比如 C ，Rust，Go 等，利用编译器来得到 *WebAssembly* 格式（二进制格式类型）的输出。


执行 *WebAssembly* 需要的虚拟机，在不同的环境下，有不同的实现，比如，在浏览器中。当然，也有独立的实现，像：https://github.com/bytecodealliance/wasmtime 。


*WebAssembly* 的文本格式是采用类似 Lisp 语言的 S 表达式的形式，我们可以手写它（ *wasmtime* 也支持直接执行）：

```wst
(module
    (import "wasi_unstable" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
    (memory 1)
    (export "memory" (memory 0))
    (data (i32.const 8) "hello world\n")
    (func $main (export "_start")
        (i32.store (i32.const 0) (i32.const 8))
        (i32.store (i32.const 4) (i32.const 12))
        (call $fd_write
            (i32.const 1)
            (i32.const 0)
            (i32.const 1)
            (i32.const 20)
        )
        drop
    )
)
```

把这些内容保存成 ``demo.wat`` ，用前面的 *wasmtime* 执行它就可以输出 ``hello world`` 了：

```bash
wasmtime demo.wat
```

这里面其实除了 *WebAssembly* 语言本身的机制外，还有像 *fd_write* 这种 API 。只有具体的虚拟机，或者说运行时，提供了这些 API ，我们才能使用具体的语言去完成更业务性的事，否则只能一直做些四则运算的事。


坏消息是， API 层面，现在还不是一个稳定，完整的状态，在 https://github.com/WebAssembly/WASI 这里，能看到它们在被缓慢的推进着，一份简单的文档在 https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md 。

不要尝试去找针对 *WebAssembly* 的文本格式的完整的“语法手册”，因为根本找不到。官方的“语法手册”，是从 Token 层面说的，给编译器开发人员看的那种文档，或许没人会觉得手写 S 表达式是正常的行为吧。

后面我们会使用其它的高级语言，通过编译得到 *WebAssembly* 。之后的重点，其实已经不在 *WebAssembly* 这个语言本身，反正是编译器的事。相反，了解各个运行时环境，知道它们提供了哪些像前面的 ``fd_write`` 那样的东西，及怎么和 js 交互，才是更有意义的。


# C 编译 #

## 安装 ##

*emscripten* ，是一套构建与 SDK 方案，它在 https://emscripten.org/ 。

安装的方式，是先拉取 git 代码：

```bash
git clone https://github.com/emscripten-core/emsdk.git
```

进入目录后，执行安装，它会下载编辑器，nodejs 等一堆东西：

```bash
cd emsdk
./emsdk install latest
./emsdk activate latest
```

最后处理一下环境：

```bash
source ./emsdk_env.sh
```


## Hello World ##

先写个 *hello world* ：

```c
#include <stdio.h>

int main() {
    printf("Hello, World\n");
    return 0;
}
```

前面的环境如果处理好了，就可以用 ``emcc`` 去直接编译这个 ``demo.c`` ：

```bash
emcc demo.c
```

编译的结果，在当前目录下，会得到 ``a.out.js`` 和 ``a.out.wasm`` 两个文件。

``a.out.wasm`` 是前面介绍过的， *WebAssembly* 的二进制是格式的代码。

``a.out.js`` 处理加载和额外的依赖，同时，它支持 nodejs 。所以：

```bash
node a.out.js
```

就可以看到 ``Hello, World`` 的输出了。

这里，如果用前面的 ``wasmtime`` 去执行 ``a.out.wasm`` ，会看到报错，报措的原因是找不到一些定义。这就是前面说过的，语言问题是小事，麻烦的是环境。 *emcc* 做了一套方案，去兼容 c 的编程环境。当这些实现要跑在 nodejs ，或者浏览器中的时候，环境相关的一些东西就需要被重新解释，比如“标准输出”，要变成 ``console.log`` 。这些东西，不是 *WebAssembly* 范畴的，要么运行时在实现时提供一个内置标准，比如 ``wasmtime`` 里面可能提供了一些东西。要么运行时提供一个注入式的方案，比如 nodejs 或者浏览器上，都可以完成 *WebAssembly* 和 *javascript* 的互调用。那么“标准输入”在编译时就可以被解析成任何一个符号，执行时再由 *javascript* 提供这个符号的实现就可以了。

``wasmtime a.out.wasm`` 的报错，是找不到 ``env::emscripten_memcpy_big`` ，打开 ``a.out.js`` 找一下，就能找到 ``emscripten_memcpy_big`` 。

``a.out.js`` 中的“标准输出”，就是 ``_fd_write`` 这个函数，我们可以加一些 ``console.log`` 看看。事实上， ``fd_write`` 就是 *wasi* 中的一个标准。（但是 ``emscripten_memcpy_big`` 不是）

nodejs 可以执行 *WebAssembly* ，浏览器也可以：

```bash
emcc demo.c -o hello.html
```

这样的话，除了 ``hello.wasm`` , ``hello.js`` ，还会有一个 ``hello.html`` 。

可以直接执行：

```bash
node hello.js
```

也可以启动一个静态服务，在浏览器中访问这个 ``hello.html``  ：

```bash
python -mhttp.server
```

通过访问 ``http://localhost:8000/hello.html`` ，就可以看到下图了：

![](https://img.zys.me/NoftHfT.png)


（ ``hello.html`` ，别看它有很多行代码，其中有好多是 svg 图 …… ）


## js 调用 c ##

假设做一个 ``add`` 函数给 js 用，在 ``demo.c`` 文件中：

```c
int add(int a, int b) {
    return a + b;
}
```

``emcc`` 直接提供了编译工具，封装了 js 调用 WebAssembly 的过程：

```bash
emcc demo.c -o hello.html -sEXPORTED_FUNCTIONS=_add
```

- ``-sEXPORTED_FUNCTIONS`` 是导出的函数，需要加前置下划线。


同样，打开 ``http://localhost:8000/hello.html`` 之后，我们在控制台输入：

```javascript
Module._add(1,2)
```

就能看到 ``3`` 的返回。 ``Module`` 是 ``emcc`` 定义的全局量，调用中，是函数名，返回类型，参数类型。


如果要把 ``Module`` 作为模块，而不是全局量，加一个编译参数就可以了：

```bash
emcc demo.c -o demo.js -sEXPORTED_FUNCTIONS=_add  -sMODULARIZE
```

这样的话， ``demo.js`` ，会返回一个 *Promise* 对象， *resolve* 出 ``Module`` ：

```javascript
var f = require('./demo.js')
f().then(ins => console.log(ins._add(1,1)))
2
```


``-sEXPORTED_FUNCTIONS`` 觉得麻烦的话，可以在源码中“标记”要导出的函数：

```
#include <emscripten.h>

EMSCRIPTEN_KEEPALIVE
int add_1(int a) {
    return a + 1;
}
```

这样，直接编译就可以导出 ``add_1`` 这个函数了：

```bash
emcc demo.c -o demo.html
emcc demo.c -o demo.js -sMODULARIZE
```


# 其它编译 #

市面上还有 c++, go, rust, 类 typescript 等各种实现。


# 相互调用背后的东西 #



# 可能的应用场景 #

- 计算密集型的纯计算场景，比较图片，音视频编解码。（但是同时典型场景方面浏览器 API 中已经有可以直接利用硬件的相关实现了）
- 复用其它语言中的已有实现，移植到浏览器。
- 重量级的，但又不那么专业的，工具。
- 大型的 DSL 。


