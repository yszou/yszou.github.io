Next JS 笔记
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/nextjs.html
%!format: !email
%%toc


# 安装 #

Next JS 是一个基于 React 的前端整体方案。它比较不同的是整合了“服务端渲染”机制。

直接使用 *npx* 可以创建项目：

```bash
npx create-next-app@latest
```

它会问一些问题。


# 服务端渲染 #

整合服务端渲染是 *NextJS* 的一个特点。对于“服务端渲染”，我的简单理解，就是针对 React 的组件，在“可能”的前提下，由服务端处理，然后将得到的结果，序列化之后，发送给前端，再由前端处理。这个过程当中，就有很多可以优化的空间，缓存之类的。并且，像数据的获取，在服务端处理也是有明显的好处。

不过，根据这个理解，对于服务端渲染，就有几点很直观的限制：

- “可能”的前提，像 ``setState``, ``useEffect`` 这些，还有事件处理，就不可能在服务端处理。
- 因为需要序列化，所以在服务端工作的组件的结果，只是能基本数据，不可以是函数之类的结构（至少目前是这样）。


*NextJS* 中， *服务端组件* 和 *客户端组件* 是可以直接混合工作的，框架会处理其中的细节。这里也有几点规则：

-  ``app`` 目录中，默认都是服务端组件，除非在文件最开头的位置声明了 ``use client`` 。
- 一个组件被声明是客户端组件，则它 *import* 进来的依赖的其它组件也是客户端组件。
- 服务端组件中，可以 *import* 客户端组件。
- 客户端组件中，不可以 *import* 服务端组件。这种情况，可以把需要的组件设计是 ``props`` ，传入。


默认是服务端组件，则可以写这样的代码：

```javascript
import React from "react";

export default function Hello(): React.ReactNode {
  const counter = process.pid;
  return <div>
    <div>Current Counter</div>
    <div> {counter} </div>
  </div>
}
```

对于这个组件，在最开头加一个 ``use client`` 的字符串的话，开发过程当中渲染时，会有报错。提示说，作为服务端渲染，文本是 ``Current Counter XX`` ，作为客户端渲染，文本不同。


组件当中，如果使用了 ``useEffect`` 或者 ``useState`` 什么的，就不能按服务端组件处理了。

```javascript
import React, {useState} from "react";

export default function Hello(): React.ReactNode {
  const [counter, setCounter] = useState(0);
  return <div>
    <div>Current Counter</div>
    <div> {counter} </div>
  </div>
}
```

把组件改成这样， IDE 直接就提示错误了，说用了 ``useState`` 的组件不能服务端渲染。

如果强制约束服务端渲染，可以使用一个叫 ``server-only`` 的包：

```javascript
import 'server-only';
```



# 目录结构 #

## 基本规则 ##

根目录下的 ``app`` 是项目的主要目录：

- 目录即 PATH 。 ``app/`` 就是 ``/`` ，对应的 ``/app/hello/page.tsx`` 就是 ``/hello`` 。
- 目录中，有一些特殊文件，才会被当成路径，否则，路径中不可见，可以用来作为普通组件组织代码用。
- ``page.tsx`` 是路径使用的组件文件。
- ``layout.tsx`` 是一个路径使用的组件的布局，如果它存在，则 ``page.tsx`` 会作为它的 ``children`` 传入。
- ``loading.tsx`` 加载时的组件。


除此之外，还有 ``not-found``, ``error``, ``global-error``, ``route``, ``template``, ``default`` 这几个文件有特殊用途。



## 根布局 ##

根下的 ``layout`` 是必须，用于确定最基本的 HTML 页面结构：

```javascript
export default ({children}: { children: React.ReactNode }) => {
  return (
    <html>
    <body>{children}</body>
    </html>
  )
}
```

*head* 中的一堆东西，可以不用写， *Next* 设计的单独的 API 处理它们：

```javascript
import type {Metadata} from 'next'

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}
```


## 路径相关 ##

使用 ``Link`` 代替 ``a`` ，会处理好无刷新，否则会刷新页面：

```javascript
import React, {useState} from "react";
import Link from "next/link";

export default function Hello(): React.ReactNode {
  const [counter, setCounter] = useState(0);
  return <div>
    <div>Current Counter</div>
    <div> {counter} </div>
    <div><Link href="/hello/sub">SUB</Link></div>
  </div>
}
```

使用 ``useRouter()`` 完成 ``history`` 的事：

```javascript
'use client'

import React, {useState} from "react";
import Link from "next/link";
import {useRouter} from "next/navigation";

export default function Hello(): React.ReactNode {
  const [counter, setCounter] = useState(0);
  const router = useRouter();
  return <div>
    <div>Current Counter</div>
    <div> {counter} </div>
    <div onClick={() => {
      router.push('/hello/sub');
    }}>SUB
    </div>
  </div>
}
```

它也内置了 ``prefetch`` 的实现，只在生产环境状态开启的。默认情况下，如果一个页面上，都是静态的链接，那么所有服务端渲染的组件都会预加载。

访问过的路径，如果是一个静态地址（没有参数在中间），则会缓存下来。如果是有参数的动态地址，如 ``/hello/[id]`` ，那么 ``id`` 不变，也会缓存。


动态地址的实现，只需要在用 ``[id]`` 加中括号的名字作为目录名就行了：

```javascript
type PropType = {
  params: {
    id: string;
  }
}
export default (props: PropType) => {
  const {params} = props;
  return <h1>NOW IS {params.id}</h1>
}
```

这个文件的位置在： ``/app/hello/[id]/page.tsx`` ， ``id`` 参数会放到 ``params`` 中传给组件。

除了中括号，还可以使用小括号命名目录，如 ``(group)`` ，作用，就是忽略它在 URL 中的位置，比如，你把上面的文件放在 ``/app/hello/(group)/[id]/page.tsx`` 这个位置，作用是一样的。

中括号还可以做“模糊匹配”，名字用 ``[...id]`` 或者 ``[[...id]]`` ，后者是可空的，这时，参数是一个列表：

```javascript
type PropType = {
  params: {
    id: string[];
  }
}
export default (props: PropType) => {
  const {params} = props;
  return <h1>NOW IS {params.id.join(' | ')}</h1>
}
```


## 错误处理 ##

``error`` 文件用于定义基本的错误处理：

```javascript
'use client'

export default (props: { error: Error, reset: () => void }) => {
  const {error, reset} = props;
  return <div>
    <div>ERROR</div>
    <div>{error.message}</div>
    <div onClick={reset}>RESET</div>
  </div>
}
```

错误处理组件，参数有 ``error`` 和 ``reset()`` 函数， ``reset()`` 的调用是重新渲染原组件。

组件如果有抛出错误，此处注是用这个 ``error`` 来代替组件渲染了：

```javascript
export default (props: PropType) => {
  const {params} = props;
  throw Error("ERROR");
  return <h1>NOW IS {params.id.join(' | ')}</h1>
}
```

错误处理会向上冒泡，以“就近原则”处理。比如有 ``/hello/error.tsx`` 和 ``/hello/[...id]/error.tsx`` ， ``/hello/[...id]/page.tsx`` 的错误只会被 ``/hello[...id]/error.tsx`` 处理。它不存在，就会往上，找到 ``/hello/error.tsx`` 处理。


``error`` 本身是受 ``layout`` 管理的，包括 ``/error.tsx`` 。根上还有一个 ``/global-error.tsx`` ，它不受 ``layout`` 管理，也必须有独立的 *html* 和 *body* ：

服务端出的错误，也会包在 ``Error`` 对象中，会提供 ``message`` 和 ``digest`` 两个属性。



## 更多布局片段 ##

前面已经介绍过的目录名有：

- ``hello`` ，普通的，作为路径。
- ``[id]`` ，动态的，作为路径的一个模式。
- ``[...id]`` ，可以是多级。
- ``[[...id]]`` ，可选的。
- ``(id)`` ，忽略，只是一个普通目录，用来组织代码的。


现在又可以多一个了， ``@id`` ，和 ``page.tsx`` 同级的另外一个片段。

比如：有 ``/hello/sub/page.tsx`` ， ``/hello/sub/@id/page.tsx`` ，那么在 ``/page/sub/layout.tsx`` 当中，可以写：

```javascript
export default (props: TypeProps) => {
  return <div>
    <div>HELLO / SUB</div>
    {props.children}
    <div>PART</div>
    {props.id}
  </div>
}
```

``props.children`` 是 ``/hello/sub/page.tsx`` 的内容，而 ``props.id`` 就是 ``/hello/sub/@id/page.tsx`` 的内容了。



``@id`` 的情况，还可以倒过用，比如 ``/hello/@id/demo/page.tsx`` 和 ``/hello/@id/foo/page.tsx`` ，前者对应的路径是 ``/demo`` ，后者是 ``/foo`` 。但是注意， ``@id`` 的形式，它永远只是被动的片段，不能主动显式起作用，一定需要上层有 ``layout`` 去引用它们才行。

所以，在 ``/hello/layout.tsx`` ，一定要放上 ``props.id`` 才能看到效果，对于 ``/demo`` 和 ``/foo`` 的地址。

再考虑 ``/hello/@id/demo/page.tsx`` 和 ``/hello/@name/demo/page.tsx`` 的情况。 ``/hello/layout.tsx`` 就可以同时引用 ``props.id`` 和 ``props.name`` 了。

如果把 ``/hello/@name/demo/page.tsx`` 的 ``demo`` 改名成 ``abc`` ，则 ``props.name`` 在 ``/demo`` 上，是对应不到的，这时可以使用 ``default`` 。不过，我自己在测试过程，发现有时这个 ``default`` 并不能正常工作，原因不明。

``@name`` 这个机制，虽然比较灵活，但是，因为它可以“正着用”，表示某个页面中的不同片段，也可以“倒着用”，表示一个片段在不同页面中的表现，这就造成开发人员的心智负担非常大，得不偿失。



## 路由拦截 ##

路由拦截是一个比较有意思的特性。

简单来说，本来定义了一个 ``/image`` 的路由（目录），同时有一个 ``/top`` ，你可以定义一个 ``/top/(..)image`` ，来把前面的 ``/image`` 拦截了。

这个拦截的行为，是发生在前端导航行为时（比如点击了 *Link*）。如果你是直接浏览器上输入 URL ``/image`` ，是不会有拦截的行为。

先做 ``/top/page.tsx`` ：

```javascript
import Link from "next/link";

export default () => {
  return <div>
    <div>
      This is Top Page
    </div>
    <div>
      <Link href="/image">IMAGE</Link>
    </div>
  </div>
}
```

再做 ``/image/page.tsx`` ：

```
export default () => {
  return <div>This is Image page</div>
}
```

然后再做一个 ``/top/(..)image/page.tsx`` ：

```
export default () => {
  return <div>
    Image sub
  </div>
}
```

这时，先访问 ``/top`` ，点击页面上的 *IMAGE* ，就会看到 ``Image sub`` 的结果。而此时刷新页面，又变成 ``This is Image page`` 了。


官方文档上说，配合 ``@`` 开头的多个片段能力，可以直接实现 ``Modal`` 的调度，做一个 ``Modal`` ，有必要这么费劲嘛……


## 其它规则 ##

- 以下划线开头的目录，不允许访问，即使里面有 ``page`` 文件。
- ``app`` 都是放路由的地方，那我们可以通过其它的像 ``components`` 之类的目录来组件代码，让 ``app`` 只处理路由。



# 数据获取 #

客户端组件的数据获取没什么特别的，官方推荐用 SWR 和 React Query 。

服务端用 ``fetch()`` 。因为整个 *nextjs* 对于缓存都很在意，使用 ``fetch()`` 时也可以顺便指定缓存，以决定相同的 GET 请求是否重复发出， ``revalidate`` 是秒：

```javascript
fetch('https://...', { cache: 'no-store',  next: { revalidate: 10 } })
```

在组件中，还可以 ``export`` 一个 ``preload`` 函数，里面调用 ``fetch()`` 完成数据的预加载。它的参数，和 ``export default`` 的组件是一致的。当然，这个 ``preload()`` 需要在合适的地址，手工调用。


# 路由 Handler #

## 基本规则 ##

## 中间件 ##


# 样式 #

## CSS 模块 ##

组件目录中，以 ``.module.css`` 结尾的， *nextjs* 直接支持 CSS 模块的方式：

```javascript
import Link from "next/link";
import style from './style.module.css';

export default () => {
  return <div>
    <div className={style.red}>
      This is Top Page
    </div>
    <div>
      <Link href="/image">IMAGE</Link>
    </div>
  </div>
}
```

``style.module.css`` 的内容是：

```css
.red {
    color: red;
}
```

同时支持 Sass 需要自己安装一下 ``npm install sass`` ，所以也可以写 ``style.module.sass``：

```sass
.red
    color: red
```



## Tailwind CSS ##



# 部署 #

*nextjs* 同时支持动态部署和静态部署。

动态部署，只需要使用 ``npm run build`` ，然后 ``npm start`` 就可以了。

构建会在 ``.next`` 下产生很多优化后部署用文件。

动态部署，需要 nodejs 环境（或者其它相应的环境，比如 *edge* 之类的）。

静态部署的话，可以先修改 ``next.config.js`` ，添加 ``output`` ：

```javascript
const nextConfig = {
  output: "export"
}

module.exports = nextConfig
```

这时再运行 ``npm run build`` ，编译的结果，会放在 ``out`` 目录中。

当然，静态导出，会失去一些能力必须服务端上下文支持的能力，这里，并没有什么魔法。


