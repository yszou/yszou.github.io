Go学习笔记
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: https://www.zouyesheng.com/go.html
%!format: !email
%%toc


# 安装 #

新版本的 Go 的编译器，是使用 go 自己实现的，不是用 C ，所以，直接下载源码是编译不了的，所以也不用折腾了。直接到官网下载二进制可执行文件就行了，比如 https://golang.org/dl/go1.17.3.linux-amd64.tar.gz 。解压后使用 ``bin`` 里面的 ``go`` 命令即可。

过程中，要使用第三方的包，或者要找官方包的文档，可以在 https://pkg.go.dev/ 搜索。


# Hello World #

创建一个 ``demo.go`` 文件：

```go
package main

func main() {
    println("Hello World!")
}
```

注意两点，要直接可执行，需要在 ``main`` 中的 ``main`` 函数。

之后可以直接：

```go
go run demo.go
```

也可以：

```bash
go build demo.go
./demo
```

``-o`` 参数是可用的

```bash
go build -o a demo.go
./a
```


# 变量声明与赋值 #

go 有不同的数据类型，变量与数据类型是需要绑定的。

```go
var text string
text = "Hello World!"
```

这样是正确的，也可以直接：

```go
var text = "hello world"
```

go 有自动的类型推断，可以知道 ``text`` 的类型是 ``string`` 。

还有一种声明方式，涉及“重声明”机制：

先看：

```go
var text = "1"
var text = "2"
```

这样写，是不能通过编译的，因为 ``text`` 已经声明过。你可以重新赋值，但是不能重新声明：

```go
var text = "1"
text = "2"
```

这样没问题。

本来声明和赋值是很清楚的，但是当赋值的能力涉及到“模式匹配”，或者说“多值赋值”（我现在还不知道 go 有没有模式匹配能力）时，问题就麻烦一点了。

```go
var a, b = "1", "2"
a, b = "3", "3"
```

如果多值当中，有新声明的变量要“声明且赋值”，有旧的变量要“重新赋值”，那怎么办？

```go
var a, b = "1", "2"
var c, b = "3", "3"
```

语法上选择了 ``a, b`` 可以省略多余的 ``var`` ，那么第二行就不能解释成只新声明 ``c`` ，不声明 ``b`` 了。

也许是为了解决这种状况， ``go`` 搞了一个 ``:=`` 出来：

```go
func main() {
    var a, b = "1", "2"
    c, b := "3", "3"
    e := "s"
    fmt.Printf("%v %v %v %v\n", a, b, c, e)
}
```


``:=`` 的规则就是，左侧至少需要一个新声明的变量，这样，它就会自动对旧变量作不声明，只重赋值，感觉是在给编译器擦屁股。




# 数据类型 #

## 基本静态类型 ##

基本静态类型，我个人把它们看成四大类：

- 布尔型
- 整数型
- 浮点型
- 字节，字符，字符串


说具体的类型之前，先介绍一个工具， ``unsafe.Sizeof`` ，它可以输出变量所占的“字节数”。

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    var b bool
    b = true
    fmt.Printf("%v\n", unsafe.Sizeof(b))
}
```

你能看到 ``1`` 的输出，所以 布尔型的数据，也会占 1 个 Byte ，即 8 Bits 。


布尔型，整数，浮点，都比较简单，直接列出下面的表格就可以了：


|| 类型名                        | 名称       | 占用字节 | 范围 ||
| bool                           | 布尔量     | 1        | true 和 false |
| uint8, uint16, uint32, uint64  | 无符号整数 | 1,2,4,8  | 255, 65535, 42亿, MAX |
| int8, int16, int32, int64      | 有符号整数 | 1,2,4,8  | 127, 32767, 21亿, MAX |
| float32, float64               | 有符号浮点 | 4,8      | MAX


另外还有一个 ``int`` 的类型，听说会因为操作系统的位数不同，而使用 ``int32`` 或者 ``int64`` ，在我的本机上是 ``int64`` ，占 8 个字节。


## 类型别名 ##

通过 ``type`` ，可以指定一个自定义的类型名字：

```go
type myInt int32
var n myInt
```

## 字节，字符，字符串 ##

go 中，还是有双引号表示“字符串”，单引号表示“字符”的传统方法。不过，这里的“字符”指的是 Unicode 真字符，占 4 个字节。

```go
func main() {
    var b  = 'a'
    var c  =  b + 1
    var d  =  '\xFF'
    var e = "abcdefghikk918298371jkjfkhh832"
    fmt.Printf("%v\n", unsafe.Sizeof(b))
    fmt.Printf("%v\n", b)
    fmt.Printf("%v\n", c)
    fmt.Printf("%v\n", d)
    fmt.Printf("%v\n", unsafe.Sizeof(e))
    fmt.Printf("%v\n", e)
}
```

上面的例子，可以看出：

- ``'a'`` 是一个字符，占 4 个字节。本身是 ``uint32`` 。它有一个专门的类型名叫 ``rune`` 。
- 使用使用 ``'\xFF'`` 来表示“字符”。
- ``e`` 这个字符串占了 16 个字节，所以，字符串应该不是一个基本类型，更像是一个内置的对象。


``rune`` 是字符， go 中自然有对应的“字节”类型，就是 ``byte`` 。

```go
func main() {
    var b byte
    b  = 'a'
    var c  =  b + 1
    var d  =  '\xFF'
    fmt.Printf("%v\n", unsafe.Sizeof(b))
    fmt.Printf("%v\n", b)
    fmt.Printf("%v\n", c)
    fmt.Printf("%v\n", d)
}
```

直接把 ``b`` 声明成 ``byte`` 之后，上面的代码都是完全没问题的， ``byte`` 本身是 ``uint8`` 。

对于 ``rune`` ，它的数字值，是字符对应的 Unicode 编码的直接运算值：

```go
func main() {
    var b rune
    b  = '邹'
    var c  =  b + 1
    fmt.Printf("%v\n", unsafe.Sizeof(b))
    fmt.Printf("%v\n", b)
    fmt.Printf("%v\n", c)
}
```

``邹`` 的 Unicode 是 ``\x90B9`` ，直接看成数字就是 37049 。

简单来说，就是对于 ``byte`` 和 ``rune`` ，你可以直接用数字搞。

字符串我现在搞不懂，暂时把它当成内置对象看了。


## 数组与切片 ##

其实我一直“数组”的这个名字比较纠结，因为它里面不一定是“数字”啊，所以，一般我喜欢叫它们“列表”。

go 中，列表是一种静态类型，即大小固定，值传递。

```go
func main() {
    var b [3]bool
    b = [3]bool{true, true}
    fmt.Printf("%v\n", unsafe.Sizeof(b))
    fmt.Printf("%v\n", b[0])
}
```

这种写法下，需要把 ``[3]bool`` 整体看成是一种类型，而不是只看 ``[]bool`` 。

在 go 中， ``[]bool`` 长度留空的列表，不是列表类型，而是“切片”类型！


```go
func main() {
    type myBoolList [3]bool
    var b myBoolList
    b = myBoolList{true, true}
    fmt.Printf("%v\n", unsafe.Sizeof(b))
    fmt.Printf("%v\n", b[0])
}
```

这样处理是正确的。

```go
func main() {
    type myBoolList []bool
    var b myBoolList
    b = myBoolList{true, true}
    fmt.Printf("%v\n", unsafe.Sizeof(b))
    fmt.Printf("%v\n", b[0])
}
```

这样处理也正确，但是你会看到 ``[]bool`` 的对象，会占用 24 个字节，所以“切片”已经不是一种静态结构了。

如果要实现“自动分配固定长度”的列表，需要使用 ``[...]`` 语法：

```go
var b = [...]bool{true, true}
fmt.Printf("%v\n", unsafe.Sizeof(b))
fmt.Printf("%v\n", b[0])
```

这样， ``b`` 就只占 2 个字节。但是不能使用：

```go
type myBoolList [...]bool
```

这种 ``myBoolList`` 算啥？没法解释。

切片可以直接单独直观地使用：

```go
func main() {
    var b = [...]int32{1,2,3,4}
    var a = b[1:2]
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a[0])
}
```

区间取值是前闭后开，前后都可以省略：

```go
var a = b[:]
```

但是不支持负值索引。

使用 ``len()`` 函数可以获取数组和切片的长度（注意，数组是定长，它的长度不一定等于成员个数）：


```go
var l = [5]int{1,2,3}
println(len(l))
```

```go
var l = []int{1,2,3}
println(len(l))
```

```go
var l = [...]int{1,2,3}
println(len(l))
```

切片可变化，使用 ``append()`` 可以在尾部添加成员，并返回新的引用：

```go
var l = []int{1,2,3}
println(len(l))
l = append(l, 2, 3, 4)
println(len(l))
```



## 映射 ##

映射，也叫字典， *map* 。这种类型，或者说这种对象， go 的封装程度是比较高的：

```go
func main() {
    var a map[int32]int32
    a = map[int32]int32{}
    a[1] = 123
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a[1])
}
```

声明时，通过直观的语法声明 ``key`` 和 ``value`` 的类型即可。

还可以直接声明和赋值一起：

```go
var a = map[int32]int32{1: 123}
var b = map[string]int32{"1": 123}
```

猜测任何 *hashable* 的对象都可以作为 ``key`` ，后面验证一下。

获取一个不存在的 ``key`` ，不会引发错误：

```go
var m = map[string]string{}
m["a"] = "123"
var s string = m["b"]
println(s == "")
```

没有办法直接判断 ``key`` 是否存在，只能取值，通过第二个返回值判断：

```go
var m = map[string]string{}
m["a"] = "123"
s, ok := m["b"]
println(s == "")
println(ok)
```

使用 ``delete`` 函数删除 ``key`` ：

```go
var m = map[string]string{}
var s string
var ok bool

m["a"] = "123"
s, ok = m["a"]
println(s == "")
println(ok)
delete(m, "a")
s, ok = m["a"]
println(s == "")
println(ok)
```



## 结构体与函数 ##

类似 C 中一样，通过 ``type`` 我们可以声明一个类型的“别名”，也可以直接通过 ``type`` 声明新的类型：

```go
func main() {
    type point struct {
        x int32
        y int32
    }
    var a = point{x: 1, y: 2}
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a.x)
}
```

也可以：

```go
var a point
a.x = 1; a.y = 2
```

但是不可以：

```go
var a point = {x: 1, y: 2}
```


还可以使用 ``new`` ，像指针那样操作：

```go
var a = new(point)
a.x = 1; a.y = 2
fmt.Printf("%v\n", (*a).y)
```

这里把“函数”和结构体一起讲，是希望突出一个关键的语言特性，即我们常看到的一种说法——“函数是一等公民”。

在 go 中，函数是一种基本类型，可以被用于成员定义，参数传入，返回。

```go
func main() {
    type point struct {
        x int32
        y int32
        add func(int32, int32) int32
    }
    var a point
    a.x = 1; a.y = 2
    a.add = func(a int32, b int32) int32 {
        return a + b
    }
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a.add(a.x, a.y))
}
```

``point`` 的 ``add`` 成员，是一个函数，函数签名是两个 ``int32`` 的参数，返回 ``int32`` 。

实际的实现中，我们直接给 ``a.add`` 赋值一个匿名函数。


## 函数与可变参数 ##

上一部分说了到了函数是基本类型，那么就就必要细看一下函数的行为。

作为类型声明：

```go
func main() {
    type onePFunc func(int32) string
    var a onePFunc = func(a int32) string {
        return "hello"
    }
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a(1))
}
```

这里的 ``a`` 参数，没有用到，编译器也不会提醒的。但是某个 ``import`` 的东西没有用到，却会提醒。

作为结构体成员：

```go
func main() {
    type hasFunc struct {
        f func(int32) string
    }
    var a = hasFunc{f: func(a int32) string {return "hello"}}
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a.f(1))
}
```

作为参数：

```go
func main() {
    var a = func(f func(int32) int32) int32{
        return f(1)
    }
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a(func(n int32) int32 { return n+1}))
}
```

作为函数返回：

```go
func main() {
    var a = func(n int32) func() int32{
        return func() int32 {
            return n + 1
        }
    }
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a(2)())
}
```

立即执行：

```go
func main() {
    var a = 123;
    (func(){
        a = 456
    })()
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a)
}
```

go 中处理函数参数可变的方式，是使用可变参数，而不是使用“同名但是签名不同”。但是我没有找到返回可变类型的办法，如果返回的类型是可变的，那只能通过“接口”之类的机制再做一层抽象。

可变参数在 go 中的处理，对于同种类型，作为最后一个参数，可以统一作为一个“切片”：

```go
func main() {
    var a = func(a int32, b ...int32) int32 {
        return a + b[1]
    };
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a(1, 2, 3, 4))
}
```


## 接口 ##

go 中没有“类”，但是它却搞了一个“接口”的概念出来。所以，“接口的实现”只能放到 ``struct`` 中去做。

另外，接口不能写在函数中。


```go
package main

import (
    "fmt"
    "unsafe"
)

type Runable interface {
    run(string) string
}

type Person struct {
    name string
}

func (p Person) run(name string) string {
    return p.name + ":" + name + ":" + "running"
}

func main() {

    var a = Person{name: "abc"}

    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", a.run("haha"))
}
```


上面代码中的：

```go
func (p Person) run(name string) string {
    return p.name + ":" + name + ":" + "running"
}
```

这个语法在我看来是很丑的。它的作用给 ``Person`` 这种类型添加了一个 ``run()`` 的方法。

首先，“方法”本身和“接口”并没有必然的联系，上面的代码中即使不定义 ``Runable`` 的接口，也不影响 ``Person`` 类型多一个 ``run()`` 方法。

其次， ``Person`` 的类型中，它的成员可以直接有一个名为 ``run`` 的函数：

```go
type Person struct {
    name string
    run func(string) string
}
```

那么这种情况， ``Person`` 算不算是实现了 ``Runable`` 接口呢？

``struct`` 本身应该是一个完整的结构，但它的方法却要和其它一些成员分开来写，这太别扭了。

还有，从上面的流程看，“接口”好像除了在编译期做一些检查，在运行期是完全没必要存在的。不知道 go 中怎么处理动态接口，或者一些运行时加载的功能怎么处理。


接口定义之后，我们就可以面向接口做函数的签名了：

```go
func main() {

    var a = Person{name: "abc"}
    var f = func(r Runable) string {
        return r.run("waa")
    }

    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", f(a))
}
```

顺便我们可以检查一下，对于：

```go
type Person struct {
    name string
    run func(string) string
}
```

这种，即使我们给了 ``run`` 的一个实现，编译器也不认为 ``Person`` 实现了 ``Runable`` 接口：

```go
package main

import (
    "fmt"
    "unsafe"
)

type Runable interface {
    run(string) string
}

type Person struct {
    name string
    run func(string) string
}


func main() {

    var a = Person{name: "abc", run: func(name string) string {return name + " is running"}}
    var f = func(r Runable) string {
        return r.run("waa")
    }

    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v\n", f(a))
}
```

编译会报错，说 ``Person.run`` 是一个 *field* ，不是一个 *method* 。

同时，你也不能给 ``int`` 添加一个方法：

```go
func (i int) run() string {
    return "running"
}
```

报的错是，不能一个 ``non-local`` 类型添加新的方法。


# 流程控制和操作符 #

go 的流程控制语句很简单，一共只有：

- ``if``  ``else``
- ``for`` , ``break``, ``continue``, ``range``
- ``switch``
- ``goto``


go 专门提供了 ``goto`` ，嗯，很暴力。


## if ##

``if`` 后面不用加括号：

```go
func main() {
    if true {
        println("hello")
    }
}
```

``if`` 后面强制需要 ``bool`` 类型，给个 ``1`` 是不行的。同时，各种类型的转换，也是使用特定的函数，比较死板。


go 的运算符没有什么特别的，“与否非”分别是 ``&&``， ``||``， ``!`` ：

```go
func main() {
    if (1 > 1) && (2 > 0) {
        println("hello")
    } else {
        println("world")
    }
}
```


## for ##


``for`` 是一个通用的迭代实现，它只看成是流程控制时同时有传统的 ``while`` 和 ``for`` 的作用：

传统 ``for`` 的形式是典型的三段：

```go
for i := 0; i < 10; i++ {
    println(i)
}
```

``for`` 里面的变量声明及赋值，就只能用 ``:=`` 了。

三段可以任意省略。

全省，就是一个死循环：

```go
var count int = 0;
for {
    println(count)
    count++
    if count == 10 { break }
}
```

``for`` 后面只跟一个表达式，则它的行为跟传统的 ``while`` 一样：

```go
var count int = 0;
for count < 10 {
    println(count)
    count++
}
```


本身的功能说完，就来看 ``for`` 的迭代表现。这里，应该说更像在语法层面给 ``for`` 和 ``range`` 开的后门。

是的， ``range`` 是一个 *statement* ，但是同时，你又可以像函数那么用它（有点像 Python2.x 时的 *print*）。


```go
var l = [3]int{2,3,4}
for a, n := range l {
    fmt.Printf("%v\n", unsafe.Sizeof(a))
    fmt.Printf("%v: %v\n", a, n)
}
```

遍历“列表”，两个值，一个是索引，另一个是列表成员值。

“切片”的行为同“列表”是一样的。

如果是 ``map`` 的话，则会迭代 ``key`` 和 ``vlaue`` ：

```go
func main() {
    var l = map[string]int{"a": 3, "b": 9, "c": 4}
    for a, n := range l {
        fmt.Printf("%v\n", unsafe.Sizeof(a))
        fmt.Printf("%v: %v\n", a, n)
    }

}
```


对于 ``string`` 则是字符索引和字符值（整数）：

```go
func main() {
    var l = "hello"
    for a, n := range l {
        fmt.Printf("%v\n", unsafe.Sizeof(a))
        fmt.Printf("%v: %v\n", a, n)
    }

}
```


## switch ##

``switch`` 是结构化的多路 ``if`` ，我其实比较怀疑在 ``map`` 简单好用的情况下它会有多少的出场率。

可以针对一个变量：

```go
func main() {
    var l = 3;
    switch l {
        case 1:
            println("1")
        case 2:
            println("2")
        default:
            println("other")
    }
}
```

针对单个变量时可以作多值判断：

```go
func main() {
    var l = 1;
    switch l {
        case 1,2,3:
            println("2")
        default:
            println("other")
    }
}
```


可以把逻辑表达式放在 ``case`` 中：

```go
func main() {
    var l = 3;
    switch {
        case l == 1:
            println("1")
        case l == 2:
            println("2")
        default:
            println("other")
    }
}
```


可以通过 ``fallthrough`` 实现 ``next`` 的功能，同时会跳过 ``case`` 的逻辑判断：

```go
func main() {
    var l = 1;
    switch {
        case l == 1:
            println("1")
            fallthrough
        case l == 2:
            println("2")
            break
        case l == 3:
            println("3")
        default:
            println("other")
    }
}
```


## goto ##


```go
func main() {
    var l = [3]int{1,2,3}


    for _, i := range l {
        if i == 3 {
            goto exit
        }
        println(i)
    }

    exit:
    println("exit")
}
```

注意一下 ``label`` 的语法，以 ``:`` 结尾。在行前加一个 ``label`` 对它之后的语句并没有额外影响。


# 错误和异常 #

## 错误 ##

go 中官方定义了专门的 ``errors`` 工具，和 ``error`` 接口：

```go
type error interface {
    Error() string
}
```

所以，错误本身，并没有什么特别的，用它或者不用它，不影响你写代码：

```go
package main

import (
    "errors"
)


func getError() error {
    return errors.New("this is a error")
}

type Cls struct {
    name string
}

func (c Cls) Error() string {
    return c.name
}

func main() {
    var e error = getError()
    var c Cls = Cls{name: "haha"}
    println(e.Error())
    println(c.Error())
}
```


## 异常 panic, recover, defer ##

go 中的异常，不像传统的 ``throw`` ``catch`` 那套，至少名字上不是。

看一个异常的例子：

```go
package main

func div(i int) int {
    return 10 / i
}

func main() {
    var i int = div(0)
    println(i)
}
```

说到异常，最先想到的就是 ``N / 0`` （当然，js 中有 ``Infinity`` 或者 ``NaN`` 人家就是不用异常） ，但是，你不能直接写 ``1 / 0`` ，编译器还是可以发现的，用函数包装一下编译器就不和你墨迹了。

成功编译，在执行的时候，就能看到报错，及调用栈。

要捕捉异常，在 go 中使用 ``recover()`` 函数，是的，一个函数。但是现在问题变成，这个函数如果放在前面，那么调用它时还没有异常。如果放在后面，因为异常中断了程序，无法调用。

结果， go 搞了一个 ``defer`` 语句，来把指定的语句在当前函数执行完后执行，有点 js 中 ``setTimeout`` 的感觉啊。


```go
func main() {
    defer func(){
        var p = recover()
        println("here xxxx", p)
    }()
    var i int = div(0)
    println(i)
}
```

这样一加，你就等于把异常处理了，能看到正常的 ``here xxxx`` 输出。

要手动抛出异常，可以使用 ``panic()`` 函数，它接受任何参数（反正是一个空接口）：

```go
func main() {
    defer func(){
        var p = recover()
        println("here xxxx", p)
    }()
    panic("hello")
    println("over")
}
```

看起来没异常的样子，倒像是一个 ``pipe`` 。

go 没有 ``try`` 的结构，异常只会延函数调用往上传播，直到被捕捉：

```go
package main


func aaa() {
    panic("throw in aaa")
}

func aa() {
    defer func(){
        var p = recover()
        if p != nil {
            println("aa", p)
            panic(p)
        }
    }()
    aaa()
}

func a() {
    defer func(){
        var p = recover()
        if p != nil {
            println("a", p)
        }
    }()
    aa()
}

func main() {
    a()
    println("over")
}
```


# goroutine, 通道, 并发 #

这些被看成是 go 的特点。 *goroutine* ，有些人称其为 go程，或者“协程”，我喜欢叫它“上下文”。

*通道* 是一种数据类型，听说是用于不同上下文的信息交换，行为类似操作系统的 *pipe* 。

*goroutine* 肯定是很轻量的东西，随时创建，创建销毁。但是我目前不清楚，它们到底是不是可以“并行”， go 本身是不是可以在多个进程间调度它们，在保持看起来是同一个运行时的前提下。


``go`` 语句可以开启一个 *goroutine* ：

```go
func main() {
    go func(){
        println("in go")
    }()
    println("over")
}
```

直接运行，你会发现看不到 ``in go`` ，打印 ``over`` 之后就结束了，嗯……，暂停一下才能看到 ``go func()`` 的输出：

```go
package main

import (
    "time"
)

func main() {
    go func(){
        println("in go")
    }()
    println("over")
    time.Sleep(5 * time.Second)
}
```

go 原生提供了 *goroutine* ，但不像 js 那种会默认自己控制一个 ``event loop`` ，也不像 Python 的某些工具，会显式地提供 ``event.start()`` 。

不过 *通道* 倒是提供了默认的“阻塞”特性：

```go
package main

func main() {
    var ch = make(chan string)
    var callback = func() {
        println("in go")
        var s string = <-ch
        println(s)
        println("here")
    }
    go callback()
    ch <- "write"
    println("over")
}
```

这段代码可以确定地得到：

```text
in go
write
here
over
```

这样的输出，看起来就像是 ``ch <- "write"`` 之后，再执行 ``callback()`` 一样。

如果你不把 ``ch`` 的读放在 ``callback()`` 中，在外面就立即读出：

```go
go callback()
ch <- "write"
var s string = <-ch
println(s)
println("over")
```

那么编译时就会给出死锁错误。

关于死锁，我试，你先读或者先写，都会死，似乎只有通过 *goroutine* “同时”读写才行。


但是，如果你从来就不往 ``ch`` 里写任何东西，又可以正常编译：

```go
func main() {
    var ch = make(chan string)
    var callback = func() {
        println("in go")
        var s string = <-ch
        println(s)
        println("here")
    }
    go callback()
    println("over")
}
```

最终只会有 ``over`` 输出就是了。

挻矛盾的，至少 ``<-ch`` 会阻塞的说法不准确。

```go
func main() {
    var ch = make(chan string)
    var callback = func() {
        println("in go")
        var s string = <-ch
        println(s)
        println("here")
    }
    go callback()
    time.Sleep(5 * time.Second)
    ch <- "write"
    println("over")
}
```

这段代码，最终只会输出：

```text
in go
over
```

目前搞不懂。

下面来求证最开始的那个问题， *goroutine* 是否在多进程上调度，写个死循环：


```go
package main

func main() {
    var count int = 0
    for {
        go func(){
            count += 1
            println(count)
            for {}
        }()
    }
    println("over")
}
```

通过操作系统的监控，可以发现能跑满所有 CPU 核心，哈，真香！

不过剩下的问题是，go 中哪些数据类型是进程安全的了。



# 指针，空间分配和存续 #

go 里面有像 C 中一样的指针，同时可以使用 ``new()`` 来分配一块指定类型所需大小的空间：

```go
var p *int = new(int)
*p = 123
println(*p)
println(p)
return
```

语法上，使用 ``*`` 对指针进行求值，使用 ``&`` 可以获取地址（并赋值给指针）：

```go
var m = map[string]string{"a": "123"}
var p *map[string]string
p = &m
fmt.Println((*p)["a"])
```

``new`` 分配的空间，由 go 统一管理，即使退出函数，也不会直接释放：

```go
func alloc() *int {
    var p *int = new(int)
    return p
}

func main() {
    var p *int = alloc()
    *p = 123
    println(p)
    println(&p)
    println(*p)
}
```

仅对于 *切片*， *映射*， *通道* ，可以使用 ``make()`` 来分配空间（但是我们可以不单独做 ``make`` ，而是声明时直接完成初始化了，这时，空间的分配由系统自动处理，可能会比初始值大）：

```go
var s []int = []int{1,2,3}
var s2 []int
s2 = make([]int, 20)
fmt.Println(s)
fmt.Println(s2)
return
```

go 里没有单独的指向函数的指针，感觉也不需要，函数本身就是“第一公民”。


# 链表 #

链表的实现在 ``container/list`` 中的两个对象， *List* 和 *Element* 。

*Element* 比较简单，它的成员有：

- ``Value interface{}``
- ``Next() *Element``
- ``Prev() *Element``


*List* 的方法多一些：

- static ``list.New() *List`` 初始化一个列表
- ``Init() *List`` 初始化或者清空列表
- ``Back() *Element`` 最后一个元素
- ``Front() *Element`` 第一个元素
- ``InsertAfter(v interface{}, mark *Element) *Element`` 在 ``mark`` 后面添加
- ``InsertBefore(v interface{}, mark *Element) *Element`` 在 ``mark`` 前面添加
- ``Len() int`` 链表长度
- ``MoveAfter(e *Element, mark *Element)`` 把 ``e`` 移动到 ``mark`` 后面
- ``MoveBefore(e *Element, mark *Element)`` 把 ``e`` 移动到 ``mark`` 前面
- ``MoveToBack(e *Element)`` 把 ``e`` 放到最后
- ``MoveToFront(e *Element)`` 把 ``e`` 放到最前
- ``PushBack(v interface{}) *Element`` 在末尾追加
- ``PushFront(v interface{}) *Element`` 在最前面添加
- ``PushBackList(l *List)`` 复制 ``l`` 并在末尾连接
- ``PushFrontList(l *List)`` 复制 ``l``并在最前面连接
- ``Remove(e *Element) interface{}`` 删除指定元素，同时返回元素的 ``Value``


简单的例子：

```go
package main

import (
    "container/list"
    "fmt"
)


func show(l *list.List) {
    var e *list.Element
    e = l.Front()
    if e == nil { return }
    for {
        fmt.Print(e.Value)
        e = e.Next()
        if e == nil { break }
        fmt.Print(" -> ")
    }
}


func main() {
    var p *list.List = list.New()
    (*p).PushBack(2)
    p.PushBack("3")
    show(p)
}
```

用自己 ``PushBackList`` 的例子：

```go
func main() {
    var p *list.List = list.New()
    var e *list.Element = (*p).PushBack(2)
    p.PushBack("3")
    show(p)
    println("\n\n")
    p.PushBackList(p)
    e.Value = 88
    show(p)
}
```

最后的输出是： ``88 -> 3 -> 2 -> 3`` ，能看出 ``p`` 是复制了一份添加的。


# 字符与字节 #

## rune, byte, string ##

先说一个限制，或者说一个前提，go 的源码限制为必须使用 UTF-8 编码。

前面说过， *rune* 是“字符”， *byte* 类型是字节。注意，“字符串” 是 *string* ，所以这里有三种数据类型。

```go
func main() {
    var s = "中文"
    fmt.Println(len(s))
}
```

上面的输出是 ``6`` ，所以，“字符串”应该被叫作“字节串”。


类型的转换在 go 中，倒是很直观，直接“声明”就可以完成转换了：

```go
func main() {
    var s = "中文go"
    var ss = []rune(s)
    fmt.Println(len(ss))
}
```

转换成 ``[]rune`` 就可以正确得到“字符个数”。 ``byte`` 同理：

```go
func main() {
    var s = "中文go"
    var ss = []byte(s)
    fmt.Println(len(ss), len(s))
}
```

转成字符串也是直接的：

```go
func main() {
    var b = []byte{'\x01', '\x64'}
    var ss = []rune{'中', '文'}
    fmt.Println(ss)
    var s = string(ss)
    var bs = string(b)
    fmt.Println(s, bs)
}
```

这些转换，都是基于 UTF-8 这个前提的。对于其它编码的情况怎么处理呢，哪只能依赖额外的模块了。

目前使用的是 ``golang.org/x/text`` ：

```go
package main

import (
    "fmt"
    "golang.org/x/text/encoding/simplifiedchinese"
)

func UTF8toGBK(s []byte) []byte {
    b, err := simplifiedchinese.GBK.NewEncoder().Bytes(s)
    if err != nil {
        panic(err)
    }
    return b
}
func GBKtoUTF8(s []byte) []byte {
    b, err := simplifiedchinese.GBK.NewDecoder().Bytes(s)
    if err != nil {
        panic(err)
    }
    return b
}


func main() {
    var b []byte = UTF8toGBK([]byte("中文"))
    fmt.Println(b)
    var u []byte = GBKtoUTF8(b)
    fmt.Println(u)
    var s = string(u)
    fmt.Println(s)
}
```

基本上，go 中的做法都是基于 UTF-8 的字节数据做直接的转换操作。

相较而言， Python3.x 中的字符串是抽象的真正的“字符串”，和字节没有直接关系的处理方式，我觉得是更现代的做法。


## strings 更多及“零值可用” ##

*string* 在 go 中，本来是一块不可变的字节内容，但是字符串的处理却又是很常见的场景，所以 go 提供了额外的工具来处理字符串的读写。

首先一定要记住的一点，就是“字节串”，而不是“字符串”：

```go
package main

import (
    "fmt"
)

func main() {
    var s string = "中文"
    fmt.Println(s[:3])
    fmt.Println(string([]rune(s)[:1]))
}
```

上面的代码都会输出“中”字。


如果对字符串的读写处理，有更多的一些需求，比如性能（普通的字符串拼接因为要重新分配空间，所以频繁的操作成本还是比较大的）， go 中有专门的工具：

```go
package main

import (
    "strings"
)

func main() {
    var s strings.Builder
    println(s.String(), s.Len(), s.Cap())
    s.WriteByte('a')
    s.WriteString("哈哈")
    s.WriteRune('中')
    s.Write([]byte("文"))
    println(s.String(), s.Len(), s.Cap())
    s.Grow(100)
    s.WriteString("123455669990")
    println(s.String(), s.Len(), s.Cap())
    println(strings.ToTitle(s.String()))
    s.Reset()
    println(s.String(), s.Len(), s.Cap())
}
```

关于上面的代码：

- ``strings.Builder`` 不需要显式的初始化，直接就可以用。这是 go 的 *零值可用* 机制。至于哪些东西是 *零值可用* 的，不一定。
- ``strings`` 这个包，除了 ``Builder`` ，还提供了其它针对字符串的工具，但是这些工具不能作用于 ``Builder`` 对象。
- 要获取 ``Builder`` 的长度，需要用 ``Len()`` 方法，你不能用 ``len(builder)`` ， ``len()`` 没办法通用（说好的“面向接口”呢）。
- ``Cap()`` 是获取当前对象的空间大小信息， ``Write()`` 的东西超出了预分配的大小， ``builder`` 会自动“整理重分配”。
- 你可以通过 ``Grow()`` 自己预先调整空间，结果是“至少”那么多。 ``Reset()`` 是重置，看起来可能也会直接释放空间。


go 的种种，真的谈不上美感，也许，实用吧。


# 文件IO #


## 文件读写 ##

go 中的文件相关功能，由 ``os`` 包提供支持，但是同时，还有像 ``io/ioutil`` 之类的工具封装。

``os`` 包中，有对 *File* ， *fd*，及各种具体的文件类型，文件权限的处理。

我去翻 ``os`` 的 API 时，找到了两个“打开文件”的方法，一个是 ``Open()`` 另一个 ``OpenFile()`` ，第一个只是为“读”打开，第二个有“读写”。这时我才知道， go 中，是不支持“参数默认值”机制的。如果一定要做，可以通过“可变参数”自己折腾。

不支持“参数默认值”是一种设计上的选择，无疑会带来很多的不便，但是我并不认为会带来多少“意图清晰”的收益。

当然，如果你在网上搜索一下为什么 go 不支持参数默认值，就会看到很多“屁话”，这种感觉，就像很多人无脑说 OSX 的设计是多么好一样，好到把 Enter 用成“改名”都是一种优越感（吐）。

直接用 ``os`` 读取完整的文件，还是有些麻烦的：


```go
package main

import (
    "fmt"
    "os"
    "strings"
    "io"
)

func main() {
    file, err := os.Open("/home/zys/temp/demo.go")
    if err != nil {
        fmt.Println(err)
        panic(err)
    }

    var data strings.Builder
    for {
        var buff []byte = make([]byte, 10)
        _, err := file.Read(buff)
        if err == io.EOF { break }
        data.Write(buff)
    }
    fmt.Println(data.String())
}
```

每次只能读取具体大小的字节，通过判断 ``EOF`` 决定下一步行为。

直接使用 ``ioutil`` 会方便一些：

```go
package main

import (
    "fmt"
    "os"
    "io/ioutil"
)

func main() {
    file, err := os.Open("/home/zys/temp/demo.go")
    if err != nil {
        fmt.Println(err)
        panic(err)
    }
    content, err := ioutil.ReadAll(file)
    fmt.Println(string(content))

    content2, err := ioutil.ReadFile("/home/zys/temp/demo.go")
    fmt.Println(string(content2))
}
```

写文件也是类似的：

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.OpenFile("/home/zys/temp/demo.txt", os.O_RDWR|os.O_CREATE, 0755)
    if err != nil {
        fmt.Println(err)
        panic(err)
    }
    n, err := file.Write([]byte("890"))
    n2, err := file.WriteString("中文")
    println(n, n2)
}
```

## 标准输入输出 ##


``os.Stdin``, ``os.Stdout``, ``os.Stderr`` 是三个 ``File Like`` 的对象。


标准输出和错误输出都很简单：

```go
package main

import (
    "os"
)

func main() {
    os.Stdout.WriteString("123")
    os.Stderr.WriteString("123")
}
```


输入处理直接地可以是：

```
package main

import (
    "os"
    "fmt"
    "strings"
)

func main() {
    var s strings.Builder
    for {
        var buff []byte = make([]byte, 1)
        _, err := os.Stdin.Read(buff)
        if err != nil {
            break
        }
        if buff[0] == '\n' {
            fmt.Println(s.String())
            break
        }
        s.Write(buff)
    }
}
```

## File Like ##


（暂时没找到现成的方案）



# 命令行参数 #

完善一些的工具是 ``flag`` 包，最直接的处理是使用 ``os.Args`` 。

```go
package main

import (
    "os"
)

func main() {
    for idx, args := range os.Args {
        println(idx, args)
    }
}
```

编译后执行：

```bash
./demo --abc = 123 -b 1 "1 2 3"
```

能看到输出的内容是：

```text
0 ./demo
1 --abc
2 =
3 123
4 -b
5 1
6 1 2 3
```

基本上就是以空格分割，但是额外处理了引号。


# 日志 #

go 官方自带了一个 ``log`` 包，有基本的配置能力，不过，最重要的 *Level* 没有，这就有点尴尬。自己处理的话，只能不同的 *Level* 单独定义一个“实例”，然后通过配置再处理 output 。当然，第三方有一些功能更完整的包。


```go
package main

import (
    "os"
    "log"
)

func main() {
    InfoLog := log.New(os.Stdout, "INFO ", log.Ldate|log.Ltime|log.Lshortfile)
    ErrorLog := log.New(os.Stdout, "ERROR ", log.Ldate|log.Ltime|log.Lshortfile)
    InfoLog.Print("here")
    ErrorLog.Print("here")
}
```

``INFO`` 部分是 *Prefix* ， ``log.Ldate...`` 是 *Flags* ，就提供了有限的几个配置。


# 测试 #

官方自带的测试支持，主要在两个方面，一是 ``go`` 这个命令行工具，专门有一组 ``go test`` 的功能，这套功能配合约定的“文件名”，“函数”等，可以直接一键运行项目中的测试用例。另一方面，官方提供了 ``testing`` 这个包，里面有测试的基本的功能实现，但是没有断言……


## 功能测试 ##

这里的几个规则包括：

- 文件名以 ``_test`` 结束。
- 函数以 ``Test`` 开头，参数是 ``*testing.T`` 。
- 或者一个 ``TestMain`` 的函数，参数是 ``*testing.M`` 。


下面的代码写在 ``demo_test.go`` 文件中。

```go
package main

import "testing"

func add(a int, b int) int {
    return a + b
}

func TestAdd(t *testing.T) {
    t.Run("first", func(t *testing.T){
        if add(1, 2) == 3 {
            t.Fail()
        }
    })

    t.Run("second", func(t *testing.T){
        if add(1, 2) == 3 {
        }
    })
}

func TestXX(t *testing.T) {
    t.Run("first", func(t *testing.T){
        if add(1, 2) == 3 {
        }
    })

    t.Run("second", func(t *testing.T){
        t.Run("another", func(t *testing.T){
            if add(1, 2) == 3 {
                t.Fail()
            }
        })
    })
}


func setup() {
    println("setup")
}

func teardown() {
    println("teardown")
}

func TestMain(m *testing.M) {
    setup()
    m.Run()
    teardown()
}
```

执行的时候：

```bash
go test demo_test.go
```

这样只能看到 *Fail* 的用例。要看全部的测试用例，可以：

```bash
go test demo_test.go -test.v
```


## 性能测试 ##

这里的几个规则包括：

- 文件名以 ``_test`` 结束。
- 函数以 ``Benchmark`` 开头，参数是 ``*testing.B`` 。
- 或者一个 ``TestMain`` 的函数，参数是 ``*testing.M`` 。
- 执行的时间要加上 ``bench`` 。


```go
package main

import "testing"
import "strings"

func add(a string, b string) string {
    return a + b
}

func add2(a string, b string) string {
    var s strings.Builder
    s.WriteString(a)
    s.WriteString(b)
    return s.String()
}

func BenchmarkAdd(b *testing.B) {
    b.Run("add", func (b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            add("1", "2")
        }
    })
    b.Run("add2", func (b *testing.B) {
        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            add2("1", "2")
        }
    })
}


func TestMain(t *testing.M) {
    t.Run()
}
```

和功能测试一样的，只是 ``*testing.B`` 提供了不同的功能。

执行的时候：

```bash
go test -bench=. demo_test.go -test.v
```


# 并发与锁 #


## 竞态 ##

## 原子操作 ##

## 互斥锁 ##

## 条件变量 ##

## 并发计数器 ##

## 上下文 ##

## 缓存共享池 ##




# 名字空间，包与项目结构 #




