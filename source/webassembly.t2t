WebAssembly 和 Emscripten
邹业盛
%%mtime(%Y-%m-%d %H:%M)
%!encoding: utf-8
%!options(xhtml): --google-analytics --disqus
%!qr: http://www.zouyesheng.com/webassembly.html
%!format: !email
%%toc



# 是什么东西？ #

*WebAssembly* 是一种字节码格式，执行它需要对应的一种虚拟机。

我们一般不会手写 WebAssembly ，而是通过其它高级语言，比如 C ，Rust，Go 等，利用编译器来得到 *WebAssembly* 格式（二进制格式类型）的输出。


执行 *WebAssembly* 需要的虚拟机，在不同的环境下，有不同的实现，比如，在浏览器中。当然，也有独立的实现，像：https://github.com/bytecodealliance/wasmtime 。


*WebAssembly* 的文本格式是采用类似 Lisp 语言的 S 表达式的形式，我们可以手写它（ *wasmtime* 也支持直接执行）：

```wst
(module
    (import "wasi_unstable" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
    (memory 1)
    (export "memory" (memory 0))
    (data (i32.const 8) "hello world\n")
    (func $main (export "_start")
        (i32.store (i32.const 0) (i32.const 8))
        (i32.store (i32.const 4) (i32.const 12))
        (call $fd_write
            (i32.const 1)
            (i32.const 0)
            (i32.const 1)
            (i32.const 20)
        )
        drop
    )
)
```

把这些内容保存成 ``demo.wat`` ，用前面的 *wasmtime* 执行它就可以输出 ``hello world`` 了：

```bash
wasmtime demo.wat
```

这里面其实除了 *WebAssembly* 语言本身的机制外，还有像 *fd_write* 这种 API 。只有具体的虚拟机，或者说运行时，提供了这些 API ，我们才能使用具体的语言去完成更业务性的事，否则只能一直做些四则运算的事。


坏消息是， API 层面，现在还不是一个稳定，完整的状态，在 https://github.com/WebAssembly/WASI 这里，能看到它们在被缓慢的推进着，一份简单的文档在 https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md 。

不要尝试去找针对 *WebAssembly* 的文本格式的完整的“语法手册”，因为根本找不到。官方的“语法手册”，是从 Token 层面说的，给编译器开发人员看的那种文档，或许没人会觉得手写 S 表达式是正常的行为吧。

后面我们会使用其它的高级语言，通过编译得到 *WebAssembly* 。之后的重点，其实已经不在 *WebAssembly* 这个语言本身，反正是编译器的事。相反，了解各个运行时环境，知道它们提供了哪些像前面的 ``fd_write`` 那样的东西，及怎么和 js 交互，才是更有意义的。


# C 编译 #

## 安装 ##

*emscripten* ，是一套构建与 SDK 方案，它在 https://emscripten.org/ 。

安装的方式，是先拉取 git 代码：

```bash
git clone https://github.com/emscripten-core/emsdk.git
```

进入目录后，执行安装，它会下载编辑器，nodejs 等一堆东西：

```bash
cd emsdk
./emsdk install latest
./emsdk activate latest
```

最后处理一下环境：

```bash
source ./emsdk_env.sh
```


## Hello World ##

先写个 *hello world* ：

```c
#include <stdio.h>

int main() {
    printf("Hello, World\n");
    return 0;
}
```

前面的环境如果处理好了，就可以用 ``emcc`` 去直接编译这个 ``demo.c`` ：

```bash
emcc demo.c
```

编译的结果，在当前目录下，会得到 ``a.out.js`` 和 ``a.out.wasm`` 两个文件。

``a.out.wasm`` 是前面介绍过的， *WebAssembly* 的二进制是格式的代码。

``a.out.js`` 处理加载和额外的依赖，同时，它支持 nodejs 。所以：

```bash
node a.out.js
```

就可以看到 ``Hello, World`` 的输出了。

这里，如果用前面的 ``wasmtime`` 去执行 ``a.out.wasm`` ，会看到报错，报措的原因是找不到一些定义。这就是前面说过的，语言问题是小事，麻烦的是环境。 *emcc* 做了一套方案，去兼容 c 的编程环境。当这些实现要跑在 nodejs ，或者浏览器中的时候，环境相关的一些东西就需要被重新解释，比如“标准输出”，要变成 ``console.log`` 。这些东西，不是 *WebAssembly* 范畴的，要么运行时在实现时提供一个内置标准，比如 ``wasmtime`` 里面可能提供了一些东西。要么运行时提供一个注入式的方案，比如 nodejs 或者浏览器上，都可以完成 *WebAssembly* 和 *javascript* 的互调用。那么“标准输入”在编译时就可以被解析成任何一个符号，执行时再由 *javascript* 提供这个符号的实现就可以了。

``wasmtime a.out.wasm`` 的报错，是找不到 ``env::emscripten_memcpy_big`` ，打开 ``a.out.js`` 找一下，就能找到 ``emscripten_memcpy_big`` 。

``a.out.js`` 中的“标准输出”，就是 ``_fd_write`` 这个函数，我们可以加一些 ``console.log`` 看看。事实上， ``fd_write`` 就是 *wasi* 中的一个标准。（但是 ``emscripten_memcpy_big`` 不是）

nodejs 可以执行 *WebAssembly* ，浏览器也可以：

```bash
emcc demo.c -o hello.html
```

这样的话，除了 ``hello.wasm`` , ``hello.js`` ，还会有一个 ``hello.html`` 。

可以直接执行：

```bash
node hello.js
```

也可以启动一个静态服务，在浏览器中访问这个 ``hello.html``  ：

```bash
python -mhttp.server
```

通过访问 ``http://localhost:8000/hello.html`` ，就可以看到下图了：

![](https://img.zys.me/NoftHfT.png)


（ ``hello.html`` ，别看它有很多行代码，其中有好多是 svg 图 …… ）


## js 调用 c ##

假设做一个 ``add`` 函数给 js 用，在 ``demo.c`` 文件中：

```c
int add(int a, int b) {
    return a + b;
}
```

``emcc`` 直接提供了编译工具，封装了 js 调用 WebAssembly 的过程：

```bash
emcc demo.c -o hello.html -sEXPORTED_FUNCTIONS=_add
```

- ``-sEXPORTED_FUNCTIONS`` 是导出的函数，需要加前置下划线。


同样，打开 ``http://localhost:8000/hello.html`` 之后，我们在控制台输入：

```javascript
Module._add(1,2)
```

就能看到 ``3`` 的返回。 ``Module`` 是 ``emcc`` 定义的全局量，调用中，是函数名，返回类型，参数类型。


如果要把 ``Module`` 作为模块，而不是全局量，加一个编译参数就可以了：

```bash
emcc demo.c -o demo.js -sEXPORTED_FUNCTIONS=_add  -sMODULARIZE
```

这样的话， ``demo.js`` ，会返回一个 *Promise* 对象， *resolve* 出 ``Module`` ：

```javascript
var f = require('./demo.js')
f().then(ins => console.log(ins._add(1,1)))
2
```


``-sEXPORTED_FUNCTIONS`` 觉得麻烦的话，可以在源码中“标记”要导出的函数：

```
#include <emscripten.h>

EMSCRIPTEN_KEEPALIVE
int add_1(int a) {
    return a + 1;
}
```

这样，直接编译就可以导出 ``add_1`` 这个函数了：

```bash
emcc demo.c -o demo.html
emcc demo.c -o demo.js -sMODULARIZE
```


## 参数传递，传入字符串 ##

因为 *WebAssembly* 本身设计上的限制，除了 *int* 和 *float* 可以作为值直接传递之外，其它的类型，比如字符串，数组，都只能通过地址来完成传递。这点上，倒是和 C 语言的机制很搭。


下面是一个 ``str_len`` 的例子，传入一个字符串，返回这个字符串的长度：


```c
#include <stdio.h>
#include <string.h>

#ifdef __EMSCRIPTEN__
    #include <emscripten.h>
#else
    #define EMSCRIPTEN_KEEPALIVE ;
#endif


EMSCRIPTEN_KEEPALIVE
int str_len(char* s) {
    return strlen(s);
}


#ifndef __EMSCRIPTEN__
int main() {
    printf("%d\n", str_len("hello"));
    return 0;
}
#endif
```

js 中调用的话：

```javascript
const demo = require('./demo');

demo().then( cbind => {
  const n = cbind._str_len("Hello11111111");
  console.log(n);
});
```

直接这样调用，结果是不对的。我猜，js 中的字符串传入的时候， *emcc* 是把它当地址处理的，所以这里看到的是 ``4`` 。 js 中的入参，到 c 函数的调用，参数在中间需要做显式的格式处理，这个处理， *emcc* 通过 ``ccall`` 有支持，编译时把 ``ccall`` 加入：


```bash
emcc demo.c -o demo.js -sMODULARIZE -sEXPORTED_RUNTIME_METHODS=ccall
```

``ccall`` 的用法是： ``ccall('func_name', 'return type', ['arg1 type', 'arg2 type'], [arg1, arg2])`` 。

js 中改成：

```javascript
const demo = require('./demo');

demo().then( cbind => {
  const n = cbind._str_len("Hello11111111");
  console.log(n);
  const l = cbind.ccall('str_len', 'number', ['string'], ["hello11111111"]);
  console.log(l);
});
```

除了 ``string`` ， ``ccall`` 还可以支持 ``number``, ``array`` （整数）， ``boolean`` 。



## 参数传递，传出字符串 ##


这里做一个随机字符串的例子：


```c
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>

#ifdef __EMSCRIPTEN__
    #include <emscripten.h>
#else
    #define EMSCRIPTEN_KEEPALIVE ;
#endif


const int MAX_LEN = 100;

int c_get_str(char* s) {
    srand(time(NULL));
    int r = rand() % MAX_LEN;
    int i;
    for(i = 0; i < r; i++) {
        s[i] = 'M';
    }
    return r;
}


EMSCRIPTEN_KEEPALIVE
int getRandomStr(char* s) {
    return c_get_str(s);
}


#ifndef __EMSCRIPTEN__
int main() {
    char* src = (char*)malloc(MAX_LEN);
    int len = getRandomStr(src);
    char* dest = (char*)malloc(len + 1);
    strcpy(dest, src);
    free(src);
    dest[len] = '\n';
    printf("%s", dest);
    free(dest);
    return 0;
}
#endif
```

- ``getRandomStr`` 是我们导出的函数，它接受一个字符串指标，会在里面填充一个字符串，并返回其长度。
- ``__EMSCRIPTEN__`` 是 *emcc* 编译时的宏。
- ``EMSCRIPTEN_KEEPALIVE`` 是 *emcc* 定义的宏。


代码比较简单，就是随机生成 N 个 ``M`` 。

要在 js 中使用 ``getRandomStr`` 函数，除了前面说的那些东西，这里在 *emcc* 编译时，还需要导出额外的函数：

```bash
emcc demo.c \
    -o demo.js \
    -sMODULARIZE \
    -sEXPORTED_RUNTIME_METHODS=UTF8ToString \
    -sEXPORTED_FUNCTIONS=_malloc,_free
```

- ``EXPORTED_RUNTIME_METHODS=UTF8ToString`` 导出的 ``UTF8ToString`` 可以帮助我们直接把一个字符指标转成 js 的字符串。
- ``EXPORTED_FUNCTIONS=_malloc,_free`` 导出的 ``malloc`` 和 ``free`` 类似 C 里面的内存分配与回收。看起来也是一个内存地址。


编译之后， nodejs 中就可以这样使用了：

```javascript
const demo = require('./demo');

demo().then( cbind => {
  const buffer = cbind._malloc(100);
  const r = cbind._getRandomStr(buffer);
  console.log('len is', r);
  console.log(cbind.UTF8ToString(buffer));
  cbind._free(buffer);
});
```


## 参数传递，传出结构体 ##

结构体本身只是一段连续内存，所以在 js 中处理结构体，通用的方法是“解析结构体”。但在实践中，其实可以避免这些事，对于结构体的成员，可以直接定义相关的方法来处理：

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef __EMSCRIPTEN__
    #include <emscripten.h>
#else
    #define EMSCRIPTEN_KEEPALIVE ;
#endif


typedef struct {
    char* name;
    char* desc;
    int age;
} Person;


EMSCRIPTEN_KEEPALIVE
void get_person(Person* p) {
    p -> name = "hello";
    p -> desc = "world";
    p -> age = 22;
}

EMSCRIPTEN_KEEPALIVE
char* get_person_name(Person *p) {
    return p -> name;
}


EMSCRIPTEN_KEEPALIVE
int get_person_type_size() {
    return sizeof(Person);
}


#ifndef __EMSCRIPTEN__
int main() {
    Person* p = malloc(sizeof(Person));
    get_person(p);
    printf("%s", p -> name);
    free(p);
    return 0;
}
#endif
```

上面的代码中，对于 ``Person`` 这个结构体，如果我们要获取它的名字，单独定义一个 ``get_person_name`` 函数总是可行的。

通用的办法，是使用 *emcc* 提供的 ``getValue`` 函数，直接按数据类型，一块一块地读内存结构。要使用 ``getValue`` ，编译时需要将它导出：

```bash
emcc demo.c \
    -o demo.js \
    -sMODULARIZE \
    -sEXPORTED_RUNTIME_METHODS=UTF8ToString,getValue \
    -sEXPORTED_FUNCTIONS=_malloc,_free
```

在 js 中：

```javascript
const demo = require('./demo');

demo().then( cbind => {
  const n = cbind._get_person_type_size();
  // console.log(n);
  const buffer = cbind._malloc(n);
  cbind._get_person(buffer);
  // console.log(cbind.UTF8ToString(cbind._get_person_name(buffer)));

  const name = cbind.getValue(buffer + 4, 'i32')
  console.log(cbind.UTF8ToString(name));
  const age = cbind.getValue(buffer + 8, 'i32')
  console.log(age);
});
```

这种直接知道 ``+4``，``+8`` 的偏移，是建立在完全了解 ``Person`` 结构定义前提下的。



## 参数传递，传入结构体 ##

结构体是连续内存地址，前面有 ``getValue`` ， ``UTF8ToString`` ，自然也有对应的 ``setValue``， ``stringToUTF8`` ，它们可以用来拼出指定内存地址上的数据状态，就可以实现结构体的传入了。


在前面 C 代码的基础上，添加一个函数，用于打印 ``Person`` 的信息：

```c
EMSCRIPTEN_KEEPALIVE
void print_person(Person *p) {
    printf("%s\n", p -> name);
    printf("%s\n", p -> desc);
    printf("%d\n", p -> age);
}
```

编译时把 ``setValue`` 和 ``stringToUTF8`` 加上，还有一个 ``lengthBytesUTF8`` 工具，用来计算字符串的字节数：

```bash
emcc demo.c \
    -o demo.js \
    -sMODULARIZE \
    -sEXPORTED_RUNTIME_METHODS=UTF8ToString,getValue,setValue,stringToUTF8,lengthBytesUTF8 \
    -sEXPORTED_FUNCTIONS=_malloc,_free
```


然后尝试从 js 中调用这个 ``print_person`` 函数：

```javascript
const demo = require('./demo');

demo().then( cbind => {
  const n = cbind._get_person_type_size();
  const buffer = cbind._malloc(n);

  const name = "FROM JS";
  const nameLen = cbind.lengthBytesUTF8(name) + 1;
  const nameBuffer = cbind._malloc(nameLen);
  cbind.stringToUTF8(name, nameBuffer, nameLen);

  const desc = "HAHAHA";
  const descLen = cbind.lengthBytesUTF8(desc) + 1;
  const descBuffer = cbind._malloc(descLen);
  cbind.stringToUTF8(desc, descBuffer, descLen);

  cbind.setValue(buffer, nameBuffer, 'i32');
  cbind.setValue(buffer + 4, descBuffer, 'i32');
  cbind.setValue(buffer + 8, 88, 'i32');

  cbind._print_person(buffer);

  cbind._free(descBuffer);
  cbind._free(nameBuffer);
  cbind._free(buffer);
});
```

基本过程，就是针对字符串的数据，需要为它们先单独分配空间，再把空间地址通过 ``setValue`` 设置到原地址上。


## 其它编译 ##

前面说的 *emcc* 也是支持 c++ 的。市面上还有 go, rust, 类 typescript 等各种实现。


# 例子，浏览器中嵌入 Python #

有了 C 的支持，很多东西都可以移植到浏览器跑了，从小的一些加密，散列算法，到大的完整的应用程序。不过这里又有一个问题，这些东西最好是 js 本来没有完整实现的，否则也没啥意义。

这个问题我纠结了不少时间，后来看到 *micropython* 中有现成的 js 的移植，还直接用的就是 *emcc* ，觉得直接用它实现一个小功能就很合适了。（网上还能找到一个法国大叔的 *brython* 的项目，是用 js 实现了把 Python 代码转换成 js 代码，也是狠）

这里，打算用 Python 作为配置语言，使用它完成一套 json 字符串配置的输出。

比如，系统需要的输入是：

```javascript
{
    "name": "Hello",
}
```

现在引入 Python ，可以做成（随便想的，实现时再调整）：

```python
import random
class Config(BaseConfig):
    name = random.choice(["Hello", "World"])

js.output(Config().as_config())
```


## 安装 ##

*emcc* 安装好，并且它的环境变量也处理之后（``source emsdk_env.sh``），直接在 *micropython* 的 ``ports/javascript`` 目录中 ``make`` 就可以了。

编译完成之后，会有一个 *build* 目录，里面的 ``micropython.js`` 和 ``fireware.wasm`` 是最终有用的。


## 用 js 实现 C 的 api ##

这大概是 *emcc* 结合 *WASI* 提供的一个功能，你可以用 js 实现 C 中调用的一个函数。原理，大概就是 C 编译到 *WebAssembly* 时，根据函数名事先在地址上留了坑位，比如只在头文件中声明了函数签名，运行时再用 js 实现的函数运行得到结果。当然，参数类型是有限制的，毕竟 *WebAssembly* 只有整型和浮点。

- ``library.h`` 中，使用 *extern* 声明了函数，比如 ``mp_js_write(const char *str, mp_uint_t len)`` ，这就是 *micropython* 中的标准输出函数。
- ``main.c`` 中引入了 ``library.h`` ，这样声明的函数在编译时可以被处理。
- ``mphalport.c`` 中 ``mp_hal_stdout_tx_strn`` 是一个标准输出的口子，在 js 的这个 *port* 中重新实现了它。
- 更多信息可以看 *micropython* 的 Porting 这部分的文档， https://docs.micropython.org/en/latest/develop/porting.html 。


## 自定义一个 Python 模块 ##

Python 和 js 之间，需要有一个信息传递的渠道，标准输出本来是现成的一个（ ``micropython`` 是用确定 ID 的 DOM 节点的 *print* 事件处理的它），但是考虑到，写 Python 代码的人，也需要有调试的手段，标准输出应该用在这里。那么业务场景需要的 Python 和 js 之间的信息传递，就需要自己再造一个了。

这里先完成模块的自定义，再考虑和 js 运行时的对接。

按文档，自定义一个模块，需要做两步：

- 单独的一个 c 源文件，里面定义模块，注册模块。
- 修改 *Makefile* ，重新编译。


我们期望的模块使用是：

```python
import js
js.emit("string")
```

即， ``js`` 模块，里面有一个 ``emit`` 方法，传入字符串。

这里使用单独的 ``js`` 模块，是优于直接添加 *builtin* 方法/模块的。如果是 *builtin* 的话，代码就是：

```python
jsemit("string")
```

看着像是少了一个 ``import`` 的动作，实际上这直接造成代码的无法兼容， ``jsemit("string")`` 无法在标准的 Python 环境下执行。如果是 js 模块，在标准的 Python 环境下用 python 代码定义一个这样的模块就太容易了，这样，同样的代码即可以在 *micropython* 环境下执行，也可以在标准的 Python 环境下开发。

下面开始做模块的开发。


新建一个 ``modjs.c`` 文件：

```c
#include "py/runtime.h" 
#include "py/objstr.h"

STATIC mp_obj_t js_emit(const mp_obj_t str) {
    const char* s = mp_obj_str_get_str(str);
    mp_printf(&mp_plat_print, s);
    return mp_const_none;
}
STATIC MP_DEFINE_CONST_FUN_OBJ_1(js_emit_obj, js_emit);

STATIC const mp_rom_map_elem_t js_module_globals_table[] = {
    { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_js) },
    { MP_ROM_QSTR(MP_QSTR_emit), MP_ROM_PTR(&js_emit_obj) },
};
STATIC MP_DEFINE_CONST_DICT(js_module_globals, js_module_globals_table);

const mp_obj_module_t js_module = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t *)&js_module_globals,
};

MP_REGISTER_MODULE(MP_QSTR_js, js_module, MICROPY_PY_JS);
```

这里的一些处理是基于名字的，像 ``js_emit_obj`` ， ``MP_DEFINE_CONST_FUN_OBJ_1`` 宏会按参数展开完成定义行为。

最后一行的 ``MICROPY_PY_JS`` 也是一个宏，需要在 ``mpconfigport.h`` 中添加它：

```c
#define MICROPY_PY_JS               (1)
```

当然，直接写死 ``1`` 也是可以的。定义 ``MICROPY_PY_JS`` 只是为了好控制。

最后，要修改 *Makefile* 的配置，打开 ``Makefile`` ，在 ``SRC_C`` 中添加刚才新建的 ``modjs.c`` ：

```makefile
SRC_C = \
	main.c \
	modjs.c \
	mphalport.c \
	modutime.c \
```

这样就可以了，重新编译后， ``js.emit("string")`` 就会在标准输出中显示它的参数。


## 自定义模块与 js 的对接 ##

这一步，最终的目的是 ``js.emit`` 调用之后，我们可以从一个确定的变量中，获取到 ``emit`` 出来的内容。

大概的思路是：

在 ``modjs.c`` 中的 ``js_emit`` 中，加入一个函数，传出字符串内容：

```c
extern void mp_on_emit(const char *s);

STATIC mp_obj_t js_emit(const mp_obj_t str) {
    const char* s = mp_obj_str_get_str(str);
    mp_on_emit(s);
    return mp_const_none;
}
```

``mp_on_emit`` 在 ``main.c`` 中定义，把接收到的字符串马上复制下来，保存在一个静态变量中：

```c
STATIC char *mp_current_emit_str = "";
void mp_on_emit(const char *s) {
    strcpy(mp_current_emit_str, s);
}
```

同时在 ``main.c`` 中提供一个 ``mp_js_resiger_emit_handler(char *s)`` ，之后会被导出到 js ，它的参数是一个内存地址，实现上将会赋值给静态变量 ``mp_current_emit_str`` ：

```c
void mp_js_register_emit_handler(char *s) {
    mp_current_emit_str = s;
}
```

因为 ``mp_js_resiger_emit_handler`` 的参数是由 js 传入的，所以，在 ``js_emit`` 调用完之后，我们就可以从 js 传入的地址那里，得到可能存在的 ``emit`` 内容了。整体的 nodejs 过程如下：

```javascript
var mp_js = require('./build/micropython.js');
mp_js().then(Module => {
  var mp_js_init = Module.cwrap('mp_js_init', 'null', ['number']);
  var mp_js_do_str = Module.cwrap('mp_js_do_str', 'number', ['string']);
  const buffer = Module._malloc(200 * 1024);
  Module._mp_js_register_emit_handler(buffer);
  mp_js_init(64 * 1024);
  const py = `
import js
import json
js.emit(json.dumps({"a": 123}))
  `
  mp_js_do_str(py);
  const str = Module.UTF8ToString(buffer);
  Module._free(buffer);
  console.log(str);
});
```

额外注意的是，这里用到了更多的 *emcc* 导出函数，同时还以 *Promise* 的方式使用模块，所以 *Makefile* 中的 *FLAGS* 部分也要作相应的修改：

```makefile
JSFLAGS += -s EXPORTED_FUNCTIONS="['_malloc', '_free', '_mp_js_register_emit_handler', \
                                   '_mp_js_init', '_mp_js_init_repl', '_mp_js_do_str', \
                                   '_mp_js_process_char', '_mp_hal_get_interrupt_char', \
                                   '_mp_sched_keyboard_interrupt']" \
           -s EXPORTED_RUNTIME_METHODS="['ccall', 'cwrap', 'UTF8ToString']" \
           -s --memory-init-file 0 --js-library library.js -s MODULARIZE
```

除了加入额外导出的函数，还添加了 ``-s MODULARIZE`` ，否则无法判断模块初始化完成的时机（REPL中使用没有这个问题）。


## 实际的应用使用 ##

前面已经处理好了 ``micropython.js`` 和 ``fireware.wasm`` ，现在把它们应用到实际的业务场景中。

要做的事，是对于下图这样的一个数据可视化的场景，本来有一个简单，固定的描述结构（JSON）：

![](https://img.zys.me/FtFtH8d.png)


我们使用 Python ，替换原来固定的，静态的 JSON 结构。完整的编程语言语法，不光为结构描述带来了抽象能力，还为以后加入更完整的功能直接铺平了道路，比如数据的获取及数据获取后的再加工。

![](https://img.zys.me/FtFtHbJ.png)


要把 Python 用于这个场景，前面的工作，已经做得差不多了，剩下的，多是处理一些环境方面的问题：

把 ``micropython.js`` 和 ``fireware.wasm`` 直接复制到项目中就可以使用。 这里注意的点，是 ``micropython.js`` 中有 ``fs`` 相关的东西，最简单的处理方式，就是在 ``webpack`` 的配置中，加一条 ``node: {"fs": "empty"}`` ：

```javascript
const webpackConfig = {
    mode: 'development',
    node: {"fs": "empty"},
    entry: [
        'webpack-dev-server/client?http://localhost:8080',
        ...
```

``micropython.js`` 原来默认的那个 ``_mp_js_write()`` 实际，可以使用 ``UTF8ToString`` 改掉，否则中文显示有问题：

```javascript
function _mp_js_write(ptr, len) {
    var str = UTF8ToString(ptr, len);
    var mp_js_stdout = document.getElementById('mp_js_stdout');
    var print = new Event('print');
    print.data = str;
    mp_js_stdout.dispatchEvent(print);
}
```

``mp_js_init`` ，初始化的栈大小，需要给的大点，比如 5M ，否则执行现实的功能实现代码，存储空间可能会不够。

最后执行的 Python 代码，可以在 https://gist.github.com/yszou/14e894cb20fc6f017aa077626749c70e 看到。功能上，就是实现随机生成右侧的图。过程中遇到了没有 *uuid* 模块，及 *micropython* 不支持 gb2312 编码的问题。


## 小结 ##

- *emcc* + *WebAssembly* ，提供了一个很简单直接的环境，可以在浏览器中方便地使用 C 的实现。
- *micropython* 借助 *emcc* ，直接就在浏览器环境提供了一个比较完善的 Python 语言。
- 更美的是， *micropython* 中要使用 C 写模块，也是非常简单和直接的。



# 相互调用背后的东西 #

目前，浏览器中使用 *WebAssembly* ，是通过一组 *WebAssembly* 的 API 完成的。大概的过程是：

- 通过 HTTP ，获取原始 *WebAssembly* 二进制格式的字节流。
- 使用 ``WebAssembly.compile`` 对字节流进行编译得到 *Module* 。
- 也可以使用 ``WebAssembly.instantiateStreaming`` 或者 ``WebAssembly.instantiate`` 直接完成实例化过程。
- *Module* 实例化之后，开始使用里面暴露出来的方法。


前面说过，因为我们不需要手写 *WebAssembly* 语言，所以这个过程大概知道就行了。具体使用时，像 *emcc* ，它又会根据 C 编译结果的情况，对这一过程做自己的定制。所以，现在各种编译到 *WebAssembly* 的方案，产出物除了 *wasm* 文件之外，都会包括对应的 js 加载辅助实现。直接拿到 *wasm* 源文件，不知道它的导入导出依赖，也是没法用的。



# 可能的应用场景 #

- 计算密集型的纯计算场景，比较图片，音视频编解码。（但是同时典型场景方面浏览器 API 中已经有可以直接利用硬件的相关实现了）
- 复用其它语言中的已有实现，移植到浏览器。包括某种编程语言的实现。
- 重量级的，但又不那么专业的，工具。
- 大型的 DSL 。


