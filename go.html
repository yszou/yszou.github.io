<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
    <link rel="shortcut icon" type="image/x-icon" href="fav.ico" />
    <meta charset="UTF-8" />
    <title>Go学习笔记 - YS.Zou</title>
    <meta name="generator" content="http://txt2tags.org" />
    <meta name="author" content="Yesheng Zou,YS.Zou,邹业盛"/>
</head>

<body class="z" style="color: #333; font-size: 16px; letter-spacing: 0.2em; font-family: 'Microsoft YaHei','WenQuanYi Micro Hei',SimHei,tahoma,sans-serif; -webkit-font-smoothing: antialiased; margin: 0;">
    <div class="content" style="width: 900px; margin: auto; padding: 30px; box-sizing: border-box; position: relative">
        <div class="header">
            <h1 style="text-align: center; font-size: 26px; margin: 0;">Go学习笔记</h1>
            <div class="user" style="margin: 20px auto; text-align: center;">
                <span>邹业盛</span>
                <span>2021-11-21 20:11 更新</span>
            </div>
        </div>

<div class="toc">

  <ol style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
  <li style="margin: 10px auto;"><a href="#toc1" style="color: #0184b7; text-decoration: none" target="_self">安装</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc2" style="color: #0184b7; text-decoration: none" target="_self">Hello World</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc3" style="color: #0184b7; text-decoration: none" target="_self">变量声明与赋值</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc4" style="color: #0184b7; text-decoration: none" target="_self">数据类型</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc5" style="color: #0184b7; text-decoration: none" target="_self">4.1. 基本静态类型</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc6" style="color: #0184b7; text-decoration: none" target="_self">4.2. 类型别名</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc7" style="color: #0184b7; text-decoration: none" target="_self">4.3. 字节，字符，字符串</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc8" style="color: #0184b7; text-decoration: none" target="_self">4.4. 数组与切片</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc9" style="color: #0184b7; text-decoration: none" target="_self">4.5. 映射</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc10" style="color: #0184b7; text-decoration: none" target="_self">4.6. 结构体与函数</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc11" style="color: #0184b7; text-decoration: none" target="_self">4.7. 函数与可变参数</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc12" style="color: #0184b7; text-decoration: none" target="_self">4.8. 接口</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc13" style="color: #0184b7; text-decoration: none" target="_self">4.9. 结构体，值使用和指针使用</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc14" style="color: #0184b7; text-decoration: none" target="_self">4.10. 类型断言，类型转换</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc15" style="color: #0184b7; text-decoration: none" target="_self">流程控制和操作符</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc16" style="color: #0184b7; text-decoration: none" target="_self">5.1. if</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc17" style="color: #0184b7; text-decoration: none" target="_self">5.2. for</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc18" style="color: #0184b7; text-decoration: none" target="_self">5.3. switch</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc19" style="color: #0184b7; text-decoration: none" target="_self">5.4. goto</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc20" style="color: #0184b7; text-decoration: none" target="_self">错误和异常</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc21" style="color: #0184b7; text-decoration: none" target="_self">6.1. 错误</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc22" style="color: #0184b7; text-decoration: none" target="_self">6.2. 异常 panic, recover, defer</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc23" style="color: #0184b7; text-decoration: none" target="_self">goroutine, 通道, 并发</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc24" style="color: #0184b7; text-decoration: none" target="_self">指针，空间分配和存续</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc25" style="color: #0184b7; text-decoration: none" target="_self">链表</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc26" style="color: #0184b7; text-decoration: none" target="_self">字符与字节</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc27" style="color: #0184b7; text-decoration: none" target="_self">10.1. rune, byte, string</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc28" style="color: #0184b7; text-decoration: none" target="_self">10.2. strings 更多及“零值可用”</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc29" style="color: #0184b7; text-decoration: none" target="_self">文件IO</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc30" style="color: #0184b7; text-decoration: none" target="_self">11.1. 文件读写</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc31" style="color: #0184b7; text-decoration: none" target="_self">11.2. 标准输入输出</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc32" style="color: #0184b7; text-decoration: none" target="_self">11.3. File Like</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc33" style="color: #0184b7; text-decoration: none" target="_self">命令行参数</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc34" style="color: #0184b7; text-decoration: none" target="_self">日志</a>
  </li>
  <li style="margin: 10px auto;"><a href="#toc35" style="color: #0184b7; text-decoration: none" target="_self">测试</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc36" style="color: #0184b7; text-decoration: none" target="_self">14.1. 功能测试</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc37" style="color: #0184b7; text-decoration: none" target="_self">14.2. 性能测试</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc38" style="color: #0184b7; text-decoration: none" target="_self">并发与锁</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc39" style="color: #0184b7; text-decoration: none" target="_self">15.1. go 的调度能力</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc40" style="color: #0184b7; text-decoration: none" target="_self">15.2. 竞态</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc41" style="color: #0184b7; text-decoration: none" target="_self">15.3. 原子操作</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc42" style="color: #0184b7; text-decoration: none" target="_self">15.4. 互斥锁</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc43" style="color: #0184b7; text-decoration: none" target="_self">15.5. 并发计数器</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc44" style="color: #0184b7; text-decoration: none" target="_self">15.6. 锁的条件应用</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc45" style="color: #0184b7; text-decoration: none" target="_self">15.7. 层级 Context</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc46" style="color: #0184b7; text-decoration: none" target="_self">15.8. 缓存共享池</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc47" style="color: #0184b7; text-decoration: none" target="_self">项目模块，包，名字空间</a>
    <ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
    <li style="margin: 10px auto;"><a href="#toc48" style="color: #0184b7; text-decoration: none" target="_self">16.1. 安装环境</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc49" style="color: #0184b7; text-decoration: none" target="_self">16.2. 项目模块</a>
    </li>
    <li style="margin: 10px auto;"><a href="#toc50" style="color: #0184b7; text-decoration: none" target="_self">16.3. 包 package</a>
    </li>
    </ul>
  </li>
  <li style="margin: 10px auto;"><a href="#toc51" style="color: #0184b7; text-decoration: none" target="_self">最后自己的一点看法</a>
  </li>
  </ol>

</div>

<a class="anchor" name="toc1"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">1. 安装</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
新版本的 Go 编译器，是使用 go 自己实现的，不是用 C ，所以直接下载源码编译不了，一般也不用折腾了。可以直接到官网下载二进制可执行文件，比如 <a href="https://golang.org/dl/go1.17.3.linux-amd64.tar.gz" style="color: #0184b7; text-decoration: none" target="_blank">https://golang.org/dl/go1.17.3.linux-amd64.tar.gz</a> 。解压后使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">bin</code> 里面的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go</code> 命令即可。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
过程中，要使用第三方的包，或者要找官方包的文档，可以在 <a href="https://pkg.go.dev/" style="color: #0184b7; text-decoration: none" target="_blank">https://pkg.go.dev/</a> 搜索。（这里的“包”，说成是“模块”更合适）
</p>

<a class="anchor" name="toc2"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">2. Hello World</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
创建一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">demo.go</code> 文件：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;Hello World!&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
注意两点，要直接可执行，需要有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main</code> 包，它里面要有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main</code> 函数。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
之后可以直接：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">go</span> run demo.<span style="color: #000000; font-weight: bold">go</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
也可以：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go build demo.go
./demo
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">-o</code> 参数可以指定编译出的文件名。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go build -o a demo.go
./a
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc3"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">3. 变量声明与赋值</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 有不同的数据类型，变量声明的类型与数据类型需要匹配。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> text <span style="color: #445588; font-weight: bold">string</span>
text = <span style="color: #dd1144">&quot;Hello World!&quot;</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样可以，也可以直接：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> text = <span style="color: #dd1144">&quot;hello world&quot;</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 会自动推断类型，知道 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text</code> 类型是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">string</code> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
还有一种声明方式，涉及“重声明”机制：
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
先看：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> text = <span style="color: #dd1144">&quot;1&quot;</span>
<span style="color: #000000; font-weight: bold">var</span> text = <span style="color: #dd1144">&quot;2&quot;</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样写，不能通过编译，因为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text</code> 已经声明过。你可以重新赋值，但是不能重新声明：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> text = <span style="color: #dd1144">&quot;1&quot;</span>
text = <span style="color: #dd1144">&quot;2&quot;</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
本来声明和赋值是很分得很清楚的，但是当赋值的能力涉及到“模式匹配”，或者说“多值赋值”（我现在还不知道 go 有没有模式匹配能力）时，问题就麻烦一点了。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> a, b = <span style="color: #dd1144">&quot;1&quot;</span>, <span style="color: #dd1144">&quot;2&quot;</span>
a, b = <span style="color: #dd1144">&quot;3&quot;</span>, <span style="color: #dd1144">&quot;3&quot;</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果多值当中，有新声明的变量要“声明且赋值”，有旧的变量要“重新赋值”，那怎么办？
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> a, b = <span style="color: #dd1144">&quot;1&quot;</span>, <span style="color: #dd1144">&quot;2&quot;</span>
<span style="color: #000000; font-weight: bold">var</span> c, b = <span style="color: #dd1144">&quot;3&quot;</span>, <span style="color: #dd1144">&quot;3&quot;</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
语法上选择了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">a, b</code> 可以省略多余的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">var</code> ，那么第二行就不能解释成只新声明 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">c</code> ，不声明 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">b</code> 了。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
也许是为了解决这种状况， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go</code> 搞了一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">:=</code> 出来：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> a, b = <span style="color: #dd1144">&quot;1&quot;</span>, <span style="color: #dd1144">&quot;2&quot;</span>
    c, b <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #dd1144">&quot;3&quot;</span>, <span style="color: #dd1144">&quot;3&quot;</span>
    e <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #dd1144">&quot;s&quot;</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v %v %v %v\n&quot;</span>, a, b, c, e)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">:=</code> 的规则就是，左侧至少有一个新声明的变量，这样，它就会自动对旧变量作不声明，只重赋值。嗯，感觉是在给编译器擦屁股。
</p>

<a class="anchor" name="toc4"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">4. 数据类型</h1>

<a class="anchor" name="toc5"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.1. 基本静态类型</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
基本静态类型，个人把它们看成四大类：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">布尔型
</li>
<li style="margin: 10px auto;">整数型
</li>
<li style="margin: 10px auto;">浮点型
</li>
<li style="margin: 10px auto;">字节，字符，字符串
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
说具体类型之前，先介绍一个工具， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">unsafe.Sizeof</code> ，它可以输出变量所占的“字节数”。（有些变量是“引用类型”的，所以它的值发生的变化时本身所占的字节数并不会变）
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;fmt&quot;</span>
    <span style="color: #dd1144">&quot;unsafe&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> b <span style="color: #445588; font-weight: bold">bool</span>
    b = <span style="color: #000000; font-weight: bold">true</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(b))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
能看到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">1</code> 的输出，所以 布尔型的数据，会占 1 个 Byte ，即 8 Bits 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
布尔型，整数，浮点，都比较简单，直接列出下面的表格就行：
</p>

<table border="1" style="border: 1px solid gray; border-collapse: collapse; margin: 25px auto; line-height: 1.4em; font-size: 14px;">
<tr>
<th style="border: 1px solid gray; font-weight: bold; text-align: center; padding: 3px 10px;">类型名</th>
<th style="border: 1px solid gray; font-weight: bold; text-align: center; padding: 3px 10px;">名称</th>
<th style="border: 1px solid gray; font-weight: bold; text-align: center; padding: 3px 10px;">占用字节</th>
<th colspan="2" style="border: 1px solid gray; font-weight: bold; text-align: center; padding: 3px 10px;">范围</th>
</tr>
<tr>
<td style="border: 1px solid gray; padding: 3px 10px;">bool</td>
<td style="border: 1px solid gray; padding: 3px 10px;">布尔量</td>
<td style="border: 1px solid gray; padding: 3px 10px;">1</td>
<td style="border: 1px solid gray; padding: 3px 10px;">true 和 false</td>
</tr>
<tr>
<td style="border: 1px solid gray; padding: 3px 10px;">uint8, uint16, uint32, uint64</td>
<td style="border: 1px solid gray; padding: 3px 10px;">无符号整数</td>
<td style="border: 1px solid gray; padding: 3px 10px;">1,2,4,8</td>
<td style="border: 1px solid gray; padding: 3px 10px;">255, 65535, 42亿, MAX</td>
</tr>
<tr>
<td style="border: 1px solid gray; padding: 3px 10px;">int8, int16, int32, int64</td>
<td style="border: 1px solid gray; padding: 3px 10px;">有符号整数</td>
<td style="border: 1px solid gray; padding: 3px 10px;">1,2,4,8</td>
<td style="border: 1px solid gray; padding: 3px 10px;">127, 32767, 21亿, MAX</td>
</tr>
<tr>
<td style="border: 1px solid gray; padding: 3px 10px;">float32, float64</td>
<td style="border: 1px solid gray; padding: 3px 10px;">有符号浮点</td>
<td style="border: 1px solid gray; padding: 3px 10px;">4,8</td>
<td style="border: 1px solid gray; padding: 3px 10px;">MAX</td>
</tr>
</table>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
另外还有一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">int</code> 类型，会因为操作系统的位数不同，而使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">int32</code> 或者 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">int64</code> 。在我的机器上是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">int64</code> ，占 8 个字节。
</p>

<a class="anchor" name="toc6"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.2. 类型别名</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">type</code> ，可以指定一个自定义的类型名字：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">type</span> myInt <span style="color: #445588; font-weight: bold">int32</span>
<span style="color: #000000; font-weight: bold">var</span> n myInt
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc7"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.3. 字节，字符，字符串</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中，仍然有双引号表示“字符串”，单引号表示“字符”的传统方法。不过，这里说的单引号的“字符”指的是 Unicode 真正的字符抽象表示（不是字节那种具体形式），占 4 个字节。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> b  = <span style="color: #dd1144">&#39;a&#39;</span>
    <span style="color: #000000; font-weight: bold">var</span> c  =  b <span style="color: #000000; font-weight: bold">+</span> <span style="color: #009999">1</span>
    <span style="color: #000000; font-weight: bold">var</span> d  =  <span style="color: #a61717; background-color: #e3d2d2">&#39;\</span>xFF<span style="color: #a61717; background-color: #e3d2d2">&#39;</span>
    <span style="color: #000000; font-weight: bold">var</span> e = <span style="color: #dd1144">&quot;abcdefghikk918298371jkjfkhh832&quot;</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(b))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, b)
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, c)
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, d)
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(e))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, e)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的例子，可以看出：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">'a'</code> 是一个字符，占 4 个字节。本身是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">uint32</code> 。它有一个专门的类型名叫 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rune</code> 。
</li>
<li style="margin: 10px auto;">可以使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">'\xFF'</code> 来表示“字符”。
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">e</code> 这个字符串占了 16 个字节，所以，字符串应该不是一个基本类型，更像是一个内置的对象。
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rune</code> 是字符， go 中自然有对应的“字节”类型，就是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">byte</code> 。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> b <span style="color: #445588; font-weight: bold">byte</span>
    b = <span style="color: #dd1144">&#39;a&#39;</span>
    <span style="color: #000000; font-weight: bold">var</span> c  =  b <span style="color: #000000; font-weight: bold">+</span> <span style="color: #009999">1</span>
    <span style="color: #000000; font-weight: bold">var</span> d  =  <span style="color: #a61717; background-color: #e3d2d2">&#39;\</span>xFF<span style="color: #a61717; background-color: #e3d2d2">&#39;</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(b))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, b)
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, c)
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, d)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
直接把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">b</code> 声明成 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">byte</code> 之后，上面的代码都是完全没问题的， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">byte</code> 本身是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">uint8</code> （这里有一隐式的类型转换）。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
对于 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rune</code> ，它的数字值是字符对应的 Unicode 编码的直接数字表达值：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> b <span style="color: #445588; font-weight: bold">rune</span>
    b  = <span style="color: #dd1144">&#39;邹&#39;</span>
    <span style="color: #000000; font-weight: bold">var</span> c  =  b <span style="color: #000000; font-weight: bold">+</span> <span style="color: #009999">1</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(b))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, b)
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, c)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">邹</code> 的 Unicode 是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">\x90B9</code> ，直接看成数字就是 37049 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
简单来说，就是对于 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">byte</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">rune</code> ，都可以直接用数字来处理。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
字符串我现在搞不懂，暂时把它当成内置对象看了。
</p>

<a class="anchor" name="toc8"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.4. 数组与切片</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
其实我一直“数组”的这个名字比较纠结，因为它里面不一定是“数字”啊，所以一般我喜欢叫它们“列表”。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中，列表是一种静态类型，即大小固定，值传递。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> b [<span style="color: #009999">3</span>]<span style="color: #445588; font-weight: bold">bool</span>
    b = [<span style="color: #009999">3</span>]<span style="color: #445588; font-weight: bold">bool</span>{<span style="color: #000000; font-weight: bold">true</span>, <span style="color: #000000; font-weight: bold">true</span>}
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(b))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, b[<span style="color: #009999">0</span>])
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这种写法下，需要把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">[3]bool</code> 整体看成是一种类型，而不是只看 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">[]bool</code> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在 go 中， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">[]bool</code> 这类长度留空的“列表”，不是列表类型，而是“切片”类型！（ <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">slice</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">array</code> 或者说 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">list</code> 不是一回事）
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">type</span> myBoolList [<span style="color: #009999">3</span>]<span style="color: #445588; font-weight: bold">bool</span>
    <span style="color: #000000; font-weight: bold">var</span> b myBoolList
    b = myBoolList{<span style="color: #000000; font-weight: bold">true</span>, <span style="color: #000000; font-weight: bold">true</span>}
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(b))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, b[<span style="color: #009999">0</span>])
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样处理是正确的。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">type</span> myBoolList []<span style="color: #445588; font-weight: bold">bool</span>
    <span style="color: #000000; font-weight: bold">var</span> b myBoolList
    b = myBoolList{<span style="color: #000000; font-weight: bold">true</span>, <span style="color: #000000; font-weight: bold">true</span>}
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(b))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, b[<span style="color: #009999">0</span>])
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样处理也正确，但是你会看到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">[]bool</code> 的对象，会占用 24 个字节，所以“切片”已经不是一种静态结构了。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果要实现“自动分配固定长度”的列表，需要使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">[...]</code> 语法：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> b = [<span style="color: #000000; font-weight: bold">...</span>]<span style="color: #445588; font-weight: bold">bool</span>{<span style="color: #000000; font-weight: bold">true</span>, <span style="color: #000000; font-weight: bold">true</span>}
fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(b))
fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, b[<span style="color: #009999">0</span>])
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">b</code> 就只占 2 个字节。但是不能使用：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">type</span> myBoolList [<span style="color: #000000; font-weight: bold">...</span>]<span style="color: #445588; font-weight: bold">bool</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这种 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">myBoolList</code> 算啥？没法解释。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
“列表”和“切片”都支持切片操作。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> b = [<span style="color: #000000; font-weight: bold">...</span>]<span style="color: #445588; font-weight: bold">int32</span>{<span style="color: #009999">1</span>,<span style="color: #009999">2</span>,<span style="color: #009999">3</span>,<span style="color: #009999">4</span>}
    <span style="color: #000000; font-weight: bold">var</span> a = b[<span style="color: #009999">1</span>:<span style="color: #009999">2</span>]
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a[<span style="color: #009999">0</span>])
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
区间取值是前闭后开，前后都可以省略：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> a = b[:]
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
不过不支持负值索引。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">len()</code> 函数可以获取数组和切片的长度（注意，数组是定长，它的长度不一定等于成员个数）：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> l = [<span style="color: #009999">5</span>]<span style="color: #445588; font-weight: bold">int</span>{<span style="color: #009999">1</span>,<span style="color: #009999">2</span>,<span style="color: #009999">3</span>}
<span style="color: #0086B3">println</span>(<span style="color: #0086B3">len</span>(l))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>


<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> l = []<span style="color: #445588; font-weight: bold">int</span>{<span style="color: #009999">1</span>,<span style="color: #009999">2</span>,<span style="color: #009999">3</span>}
<span style="color: #0086B3">println</span>(<span style="color: #0086B3">len</span>(l))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>


<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> l = [<span style="color: #000000; font-weight: bold">...</span>]<span style="color: #445588; font-weight: bold">int</span>{<span style="color: #009999">1</span>,<span style="color: #009999">2</span>,<span style="color: #009999">3</span>}
<span style="color: #0086B3">println</span>(<span style="color: #0086B3">len</span>(l))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
切片可变化，使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">append()</code> 可以在尾部添加成员，并返回新的引用：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> l = []<span style="color: #445588; font-weight: bold">int</span>{<span style="color: #009999">1</span>,<span style="color: #009999">2</span>,<span style="color: #009999">3</span>}
<span style="color: #0086B3">println</span>(<span style="color: #0086B3">len</span>(l))
l = <span style="color: #0086B3">append</span>(l, <span style="color: #009999">2</span>, <span style="color: #009999">3</span>, <span style="color: #009999">4</span>)
<span style="color: #0086B3">println</span>(<span style="color: #0086B3">len</span>(l))
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc9"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.5. 映射</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
映射，也叫字典， <em style="color: #d75100; font-style: normal;">map</em> 。这种类型，或者说这种对象， go 的封装程度比较高：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> a <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">int32</span>]<span style="color: #445588; font-weight: bold">int32</span>
    a = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">int32</span>]<span style="color: #445588; font-weight: bold">int32</span>{}
    a[<span style="color: #009999">1</span>] = <span style="color: #009999">123</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a[<span style="color: #009999">1</span>])
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
声明时，通过直观的语法声明 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">key</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">value</code> 的类型即可。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
还可以声明和赋值一起：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> a = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">int32</span>]<span style="color: #445588; font-weight: bold">int32</span>{<span style="color: #009999">1</span>: <span style="color: #009999">123</span>}
<span style="color: #000000; font-weight: bold">var</span> b = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">string</span>]<span style="color: #445588; font-weight: bold">int32</span>{<span style="color: #dd1144">&quot;1&quot;</span>: <span style="color: #009999">123</span>}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
个人猜测任何 <em style="color: #d75100; font-style: normal;">hashable</em> 的对象都可以作为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">key</code> ，后面验证一下。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
获取一个不存在的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">key</code> ，不会引发错误：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> m = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">string</span>]<span style="color: #445588; font-weight: bold">string</span>{}
m[<span style="color: #dd1144">&quot;a&quot;</span>] = <span style="color: #dd1144">&quot;123&quot;</span>
<span style="color: #000000; font-weight: bold">var</span> s <span style="color: #445588; font-weight: bold">string</span> = m[<span style="color: #dd1144">&quot;b&quot;</span>]
<span style="color: #0086B3">println</span>(s <span style="color: #000000; font-weight: bold">==</span> <span style="color: #dd1144">&quot;&quot;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
没有办法直接判断 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">key</code> 是否存在，只能取值，通过第二个返回值判断：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> m = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">string</span>]<span style="color: #445588; font-weight: bold">string</span>{}
m[<span style="color: #dd1144">&quot;a&quot;</span>] = <span style="color: #dd1144">&quot;123&quot;</span>
s, ok <span style="color: #000000; font-weight: bold">:=</span> m[<span style="color: #dd1144">&quot;b&quot;</span>]
<span style="color: #0086B3">println</span>(s <span style="color: #000000; font-weight: bold">==</span> <span style="color: #dd1144">&quot;&quot;</span>)
<span style="color: #0086B3">println</span>(ok)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">delete</code> 函数删除 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">key</code> ：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> m = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">string</span>]<span style="color: #445588; font-weight: bold">string</span>{}
<span style="color: #000000; font-weight: bold">var</span> s <span style="color: #445588; font-weight: bold">string</span>
<span style="color: #000000; font-weight: bold">var</span> ok <span style="color: #445588; font-weight: bold">bool</span>

m[<span style="color: #dd1144">&quot;a&quot;</span>] = <span style="color: #dd1144">&quot;123&quot;</span>
s, ok = m[<span style="color: #dd1144">&quot;a&quot;</span>]
<span style="color: #0086B3">println</span>(s <span style="color: #000000; font-weight: bold">==</span> <span style="color: #dd1144">&quot;&quot;</span>)
<span style="color: #0086B3">println</span>(ok)
<span style="color: #0086B3">delete</span>(m, <span style="color: #dd1144">&quot;a&quot;</span>)
s, ok = m[<span style="color: #dd1144">&quot;a&quot;</span>]
<span style="color: #0086B3">println</span>(s <span style="color: #000000; font-weight: bold">==</span> <span style="color: #dd1144">&quot;&quot;</span>)
<span style="color: #0086B3">println</span>(ok)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc10"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.6. 结构体与函数</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
和 C 一样，通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">type</code> 可以声明一个类型的“别名”，也可以直接通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">type</code> 声明新的类型：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">type</span> point <span style="color: #000000; font-weight: bold">struct</span> {
        x <span style="color: #445588; font-weight: bold">int32</span>
        y <span style="color: #445588; font-weight: bold">int32</span>
    }
    <span style="color: #000000; font-weight: bold">var</span> a = point{x: <span style="color: #009999">1</span>, y: <span style="color: #009999">2</span>}
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a.x)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
可以：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> a point
a.x = <span style="color: #009999">1</span>; a.y = <span style="color: #009999">2</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
但是不可以：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> a point = {x: <span style="color: #009999">1</span>, y: <span style="color: #009999">2</span>}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
还可以使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">new</code> ，像指针那样操作：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> a = <span style="color: #0086B3">new</span>(point)
a.x = <span style="color: #009999">1</span>; a.y = <span style="color: #009999">2</span>
fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, (<span style="color: #000000; font-weight: bold">*</span>a).y)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里把“函数”和结构体一起讲，是希望突出一个关键的语言特性，即我们常看到的一种说法——“函数是一等公民”。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在 go 中，函数是一种基本类型，可以被用于成员定义，参数传入，返回。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">type</span> point <span style="color: #000000; font-weight: bold">struct</span> {
        x <span style="color: #445588; font-weight: bold">int32</span>
        y <span style="color: #445588; font-weight: bold">int32</span>
        add <span style="color: #000000; font-weight: bold">func</span>(<span style="color: #445588; font-weight: bold">int32</span>, <span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">int32</span>
    }
    <span style="color: #000000; font-weight: bold">var</span> a point
    a.x = <span style="color: #009999">1</span>; a.y = <span style="color: #009999">2</span>
    a.add = <span style="color: #000000; font-weight: bold">func</span>(a <span style="color: #445588; font-weight: bold">int32</span>, b <span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">int32</span> {
        <span style="color: #000000; font-weight: bold">return</span> a <span style="color: #000000; font-weight: bold">+</span> b
    }
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a.add(a.x, a.y))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">point</code> 的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add</code> 成员，是一个函数，函数签名是两个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">int32</code> 的参数，返回 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">int32</code> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
实际的使用中，我们可以直接给 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">a.add</code> 赋值一个匿名函数。
</p>

<a class="anchor" name="toc11"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.7. 函数与可变参数</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上一部分说到了函数是基本类型，现在细看一下函数的行为。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
作为类型声明：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">type</span> onePFunc <span style="color: #000000; font-weight: bold">func</span>(<span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">string</span>
    <span style="color: #000000; font-weight: bold">var</span> a onePFunc = <span style="color: #000000; font-weight: bold">func</span>(a <span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">string</span> {
        <span style="color: #000000; font-weight: bold">return</span> <span style="color: #dd1144">&quot;hello&quot;</span>
    }
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a(<span style="color: #009999">1</span>))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">a</code> 参数即使没有用到，编译器也不会提醒的。但是某个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">import</code> 的东西没有用到，却会提醒。（个人很烦这个限制）
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
作为结构体成员：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">type</span> hasFunc <span style="color: #000000; font-weight: bold">struct</span> {
        f <span style="color: #000000; font-weight: bold">func</span>(<span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">string</span>
    }
    <span style="color: #000000; font-weight: bold">var</span> a = hasFunc{f: <span style="color: #000000; font-weight: bold">func</span>(a <span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">string</span> {<span style="color: #000000; font-weight: bold">return</span> <span style="color: #dd1144">&quot;hello&quot;</span>}}
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a.f(<span style="color: #009999">1</span>))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
作为参数：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> a = <span style="color: #000000; font-weight: bold">func</span>(f <span style="color: #000000; font-weight: bold">func</span>(<span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">int32</span>{
        <span style="color: #000000; font-weight: bold">return</span> f(<span style="color: #009999">1</span>)
    }
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a(<span style="color: #000000; font-weight: bold">func</span>(n <span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">int32</span> { <span style="color: #000000; font-weight: bold">return</span> n<span style="color: #000000; font-weight: bold">+</span><span style="color: #009999">1</span>}))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
作为函数返回：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> a = <span style="color: #000000; font-weight: bold">func</span>(n <span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #000000; font-weight: bold">func</span>() <span style="color: #445588; font-weight: bold">int32</span>{
        <span style="color: #000000; font-weight: bold">return</span> <span style="color: #000000; font-weight: bold">func</span>() <span style="color: #445588; font-weight: bold">int32</span> {
            <span style="color: #000000; font-weight: bold">return</span> n <span style="color: #000000; font-weight: bold">+</span> <span style="color: #009999">1</span>
        }
    }
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a(<span style="color: #009999">2</span>)())
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
立即执行：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> a = <span style="color: #009999">123</span>;
    (<span style="color: #000000; font-weight: bold">func</span>(){
        a = <span style="color: #009999">456</span>
    })()
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中处理函数参数可变的方式，是使用可变参数，而不是使用“同名但是签名不同”。但是我没有找到返回可变类型的办法，如果需要返回的类型可变，那只能通过“接口”之类的机制再做一层抽象。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
可变参数在 go 中的处理方式，是对于同种类型，最后一个参数，统一作为一个“切片”：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> a = <span style="color: #000000; font-weight: bold">func</span>(a <span style="color: #445588; font-weight: bold">int32</span>, b <span style="color: #000000; font-weight: bold">...</span><span style="color: #445588; font-weight: bold">int32</span>) <span style="color: #445588; font-weight: bold">int32</span> {
        <span style="color: #000000; font-weight: bold">return</span> a <span style="color: #000000; font-weight: bold">+</span> b[<span style="color: #009999">1</span>]
    };
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a(<span style="color: #009999">1</span>, <span style="color: #009999">2</span>, <span style="color: #009999">3</span>, <span style="color: #009999">4</span>))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc12"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.8. 接口</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中没有“类”，但是它有“接口”的机制。对应地，“接口的实现”变成放到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">struct</code> 中去做。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
还有，接口不能写在函数中。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;fmt&quot;</span>
    <span style="color: #dd1144">&quot;unsafe&quot;</span>
)

<span style="color: #000000; font-weight: bold">type</span> Runable <span style="color: #000000; font-weight: bold">interface</span> {
    run(<span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span>
}

<span style="color: #000000; font-weight: bold">type</span> Person <span style="color: #000000; font-weight: bold">struct</span> {
    name <span style="color: #445588; font-weight: bold">string</span>
}

<span style="color: #000000; font-weight: bold">func</span> (p Person) run(name <span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span> {
    <span style="color: #000000; font-weight: bold">return</span> p.name <span style="color: #000000; font-weight: bold">+</span> <span style="color: #dd1144">&quot;:&quot;</span> <span style="color: #000000; font-weight: bold">+</span> name <span style="color: #000000; font-weight: bold">+</span> <span style="color: #dd1144">&quot;:&quot;</span> <span style="color: #000000; font-weight: bold">+</span> <span style="color: #dd1144">&quot;running&quot;</span>
}

<span style="color: #000000; font-weight: bold">func</span> main() {

    <span style="color: #000000; font-weight: bold">var</span> a = Person{name: <span style="color: #dd1144">&quot;abc&quot;</span>}

    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, a.run(<span style="color: #dd1144">&quot;haha&quot;</span>))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面代码中：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> (p Person) run(name <span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span> {
    <span style="color: #000000; font-weight: bold">return</span> p.name <span style="color: #000000; font-weight: bold">+</span> <span style="color: #dd1144">&quot;:&quot;</span> <span style="color: #000000; font-weight: bold">+</span> name <span style="color: #000000; font-weight: bold">+</span> <span style="color: #dd1144">&quot;:&quot;</span> <span style="color: #000000; font-weight: bold">+</span> <span style="color: #dd1144">&quot;running&quot;</span>
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这个语法在个人看来很丑。它的作用是给 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Person</code> 这种类型添加了一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">run()</code> 的方法。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
“方法”本身和“接口”没有必然的联系，上面的代码中即使不定义 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Runable</code> 的接口，也不影响 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Person</code> 类型多一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">run()</code> 方法。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
还有， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Person</code> 的类型中，它的成员可以直接有一个名为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">run</code> 的函数：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">type</span> Person <span style="color: #000000; font-weight: bold">struct</span> {
    name <span style="color: #445588; font-weight: bold">string</span>
    run <span style="color: #000000; font-weight: bold">func</span>(<span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span>
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这种情况下， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Person</code> 算不算是实现了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Runable</code> 接口呢？（对 go 来说不算）
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
个人观点，<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">struct</code> 本身应该是一个完整的结构，但它的方法却要和其它一些成员分开来写，这太别扭了。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
还有，从上面的流程看，“接口”除了在编译期做一些检查，在运行期是完全没必要存在的。不知道 go 中怎么处理动态接口，或者一些运行时加载的功能怎么处理。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
接口定义之后，就可以面向接口做函数的签名了：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {

    <span style="color: #000000; font-weight: bold">var</span> a = Person{name: <span style="color: #dd1144">&quot;abc&quot;</span>}
    <span style="color: #000000; font-weight: bold">var</span> f = <span style="color: #000000; font-weight: bold">func</span>(r Runable) <span style="color: #445588; font-weight: bold">string</span> {
        <span style="color: #000000; font-weight: bold">return</span> r.run(<span style="color: #dd1144">&quot;waa&quot;</span>)
    }

    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, f(a))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
顺便可以检查一下，对于：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">type</span> Person <span style="color: #000000; font-weight: bold">struct</span> {
    name <span style="color: #445588; font-weight: bold">string</span>
    run <span style="color: #000000; font-weight: bold">func</span>(<span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span>
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这种，即使给了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">run</code> 的一个实现，编译器也不认为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Person</code> 实现了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Runable</code> 接口：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;fmt&quot;</span>
    <span style="color: #dd1144">&quot;unsafe&quot;</span>
)

<span style="color: #000000; font-weight: bold">type</span> Runable <span style="color: #000000; font-weight: bold">interface</span> {
    run(<span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span>
}

<span style="color: #000000; font-weight: bold">type</span> Person <span style="color: #000000; font-weight: bold">struct</span> {
    name <span style="color: #445588; font-weight: bold">string</span>
    run <span style="color: #000000; font-weight: bold">func</span>(<span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span>
}


<span style="color: #000000; font-weight: bold">func</span> main() {

    <span style="color: #000000; font-weight: bold">var</span> a = Person{name: <span style="color: #dd1144">&quot;abc&quot;</span>, run: <span style="color: #000000; font-weight: bold">func</span>(name <span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span> {<span style="color: #000000; font-weight: bold">return</span> name <span style="color: #000000; font-weight: bold">+</span> <span style="color: #dd1144">&quot; is running&quot;</span>}}
    <span style="color: #000000; font-weight: bold">var</span> f = <span style="color: #000000; font-weight: bold">func</span>(r Runable) <span style="color: #445588; font-weight: bold">string</span> {
        <span style="color: #000000; font-weight: bold">return</span> r.run(<span style="color: #dd1144">&quot;waa&quot;</span>)
    }

    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, f(a))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
编译会报错，提示说 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Person.run</code> 是一个 <em style="color: #d75100; font-style: normal;">field</em> ，不是一个 <em style="color: #d75100; font-style: normal;">method</em> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
同时，你也不能给 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">int</code> 添加一个方法：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> (i <span style="color: #445588; font-weight: bold">int</span>) run() <span style="color: #445588; font-weight: bold">string</span> {
    <span style="color: #000000; font-weight: bold">return</span> <span style="color: #dd1144">&quot;running&quot;</span>
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
报的错是，不能给一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">non-local</code> 类型添加新的方法。
</p>

<a class="anchor" name="toc13"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.9. 结构体，值使用和指针使用</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
我们可以以“值”，或者以“指针”来使用结构体，它们之间是参数传递的东西不同的区别：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">package main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>

<span style="color: #0086B3">type</span> Add interface {
    add(<span style="color: #0086B3">int</span>, <span style="color: #0086B3">int</span>) <span style="color: #0086B3">int</span>
    add2(<span style="color: #0086B3">int</span>, <span style="color: #0086B3">int</span>) <span style="color: #0086B3">int</span>
}

<span style="color: #0086B3">type</span> point struct {
    x int32
    y int32
}

func (p point) add(a <span style="color: #0086B3">int</span>, b <span style="color: #0086B3">int</span>) <span style="color: #0086B3">int</span> {
    p<span style="color: #000000; font-weight: bold">.</span>x <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">9</span>
    <span style="color: #000000; font-weight: bold">return</span> a <span style="color: #000000; font-weight: bold">+</span> b
}

func (p <span style="color: #000000; font-weight: bold">*</span>point) add2(a <span style="color: #0086B3">int</span>, b <span style="color: #0086B3">int</span>) <span style="color: #0086B3">int</span> {
    p<span style="color: #000000; font-weight: bold">.</span>x <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">9</span>
    <span style="color: #000000; font-weight: bold">return</span> a <span style="color: #000000; font-weight: bold">+</span> b
}

func main() {
    var p point <span style="color: #000000; font-weight: bold">=</span> point{}
    p<span style="color: #000000; font-weight: bold">.</span>x <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">1</span>; p<span style="color: #000000; font-weight: bold">.</span>y <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">2</span>
    p<span style="color: #000000; font-weight: bold">.</span>add(<span style="color: #009999">2</span>, <span style="color: #009999">3</span>)
    fmt<span style="color: #000000; font-weight: bold">.</span>Println(p)

    var p2 <span style="color: #000000; font-weight: bold">*</span>point <span style="color: #000000; font-weight: bold">=</span> <span style="color: #000000; font-weight: bold">&amp;</span>point{}
    p2<span style="color: #000000; font-weight: bold">.</span>x <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">1</span>; p2<span style="color: #000000; font-weight: bold">.</span>y <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">2</span>
    p2<span style="color: #000000; font-weight: bold">.</span>add2(<span style="color: #009999">2</span>, <span style="color: #009999">3</span>)
    fmt<span style="color: #000000; font-weight: bold">.</span>Println(p2)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面示例中， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add2</code> 因为使用了指针，所以可以把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">p2</code> 的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">x</code> 改了。而 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">add</code> 因为是直接使用的值，传递时已经复制了对象，所以改的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">p.x</code> 已经不是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main()</code> 中的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">p</code> 了。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
当然，这里接口的实现，跟 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">p</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">p2</code> 使用两种不同的初始化方式没有关系。在这里，不同的初始化方式，只是单纯为了演示。
</p>

<a class="anchor" name="toc14"></a>
<h2 style="font-size: 18px; margin: 30px auto;">4.10. 类型断言，类型转换</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 专门有一种后置的“类型断言”语法，用于通用的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">interface{}</code> 往特定的类型转换（基本类型，像整数，字符串，有专门的函数做转换）：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>

<span style="color: #000000; font-weight: bold">type</span> Point <span style="color: #000000; font-weight: bold">struct</span> {
    x <span style="color: #445588; font-weight: bold">int32</span>
    y <span style="color: #445588; font-weight: bold">int32</span>
}

<span style="color: #000000; font-weight: bold">type</span> Location <span style="color: #000000; font-weight: bold">struct</span> {
    x <span style="color: #445588; font-weight: bold">int32</span>
    y <span style="color: #445588; font-weight: bold">int32</span>
    z <span style="color: #445588; font-weight: bold">int32</span>
}

<span style="color: #000000; font-weight: bold">func</span> getType() <span style="color: #000000; font-weight: bold">interface</span>{} {
    <span style="color: #000000; font-weight: bold">return</span> Point{x: <span style="color: #009999">1</span>, y: <span style="color: #009999">2</span>}
}

<span style="color: #000000; font-weight: bold">func</span> getType2() <span style="color: #000000; font-weight: bold">interface</span>{} {
    <span style="color: #000000; font-weight: bold">return</span> <span style="color: #000000; font-weight: bold">&amp;</span>Point{x: <span style="color: #009999">1</span>, y: <span style="color: #009999">2</span>}
}

<span style="color: #000000; font-weight: bold">func</span> getType3() <span style="color: #000000; font-weight: bold">interface</span>{} {
    <span style="color: #000000; font-weight: bold">return</span> Location{x: <span style="color: #009999">1</span>, y: <span style="color: #009999">2</span>}
}


<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> p0 = getType()
    <span style="color: #000000; font-weight: bold">var</span> p1 <span style="color: #000000; font-weight: bold">interface</span>{} = getType()
    <span style="color: #000000; font-weight: bold">var</span> p2 Point = getType().(Point)
    <span style="color: #000000; font-weight: bold">var</span> p3 <span style="color: #000000; font-weight: bold">*</span>Point = getType2().(<span style="color: #000000; font-weight: bold">*</span>Point)
    <span style="color: #000000; font-weight: bold">var</span> p4 <span style="color: #000000; font-weight: bold">interface</span>{} = getType3()
    <span style="color: #000000; font-weight: bold">var</span> p5 = p4.(Location)
    fmt.Println(p0, p1, p2, p3, p4, p5)

    <span style="color: #000000; font-weight: bold">switch</span> value <span style="color: #000000; font-weight: bold">:=</span> p4.(<span style="color: #000000; font-weight: bold">type</span>) {
    <span style="color: #000000; font-weight: bold">case</span> Location:
        fmt.Println(<span style="color: #dd1144">&quot;Location&quot;</span>, value)
    <span style="color: #000000; font-weight: bold">case</span> Point:
        fmt.Println(<span style="color: #dd1144">&quot;Point&quot;</span>, value)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">p4.(Location)</code> 来完成类型的转换（具象化）。
</p>

<a class="anchor" name="toc15"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">5. 流程控制和操作符</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 的流程控制语句很简单，一共只有：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">if</code>  <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">else</code>
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">for</code> , <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">break</code>, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">continue</code>, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">range</code>
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">switch</code>
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">goto</code>
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
还专门提供了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">goto</code> ，嗯，很暴力。
</p>

<a class="anchor" name="toc16"></a>
<h2 style="font-size: 18px; margin: 30px auto;">5.1. if</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">if</code> 后面不用加括号：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">if</span> <span style="color: #000000; font-weight: bold">true</span> {
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;hello&quot;</span>)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">if</code> 后面强制需要 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">bool</code> 类型，给个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">1</code> 是不行的。同时，各种类型的转换，也是使用特定的函数，比较死板。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
运算符没有什么特别的，“与否非”分别是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">&amp;&amp;</code>， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">||</code>， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">!</code> ：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">if</span> (<span style="color: #009999">1</span> &gt; <span style="color: #009999">1</span>) <span style="color: #000000; font-weight: bold">&amp;&amp;</span> (<span style="color: #009999">2</span> &gt; <span style="color: #009999">0</span>) {
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;hello&quot;</span>)
    } <span style="color: #000000; font-weight: bold">else</span> {
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;world&quot;</span>)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc17"></a>
<h2 style="font-size: 18px; margin: 30px auto;">5.2. for</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">for</code> 是一个通用的迭代实现，可以看成是流程控制，同时兼具传统的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">while</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">for</code> 的作用：
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
传统 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">for</code> 的形式是典型的三段：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">10</span>; i<span style="color: #000000; font-weight: bold">++</span> {
    <span style="color: #0086B3">println</span>(i)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">for</code> 里面的变量声明及赋值，只能用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">:=</code> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
三段可以任意省略。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
全省，就是一个死循环：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int</span> = <span style="color: #009999">0</span>;
<span style="color: #000000; font-weight: bold">for</span> {
    <span style="color: #0086B3">println</span>(count)
    count<span style="color: #000000; font-weight: bold">++</span>
    <span style="color: #000000; font-weight: bold">if</span> count <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">10</span> { <span style="color: #000000; font-weight: bold">break</span> }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">for</code> 后面只跟一个表达式，则它的行为跟传统的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">while</code> 一样：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int</span> = <span style="color: #009999">0</span>;
<span style="color: #000000; font-weight: bold">for</span> count &lt; <span style="color: #009999">10</span> {
    <span style="color: #0086B3">println</span>(count)
    count<span style="color: #000000; font-weight: bold">++</span>
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
再来看 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">for</code> 的迭代表现。这里，感觉更像在语法层面给 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">for</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">range</code> 开的后门。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
是的， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">range</code> 是一个 <em style="color: #d75100; font-style: normal;">statement</em> ，但同时，又可以像函数那么用它（有点像 Python2.x 的 <em style="color: #d75100; font-style: normal;">print</em>）。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> l = [<span style="color: #009999">3</span>]<span style="color: #445588; font-weight: bold">int</span>{<span style="color: #009999">2</span>,<span style="color: #009999">3</span>,<span style="color: #009999">4</span>}
<span style="color: #000000; font-weight: bold">for</span> a, n <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #000000; font-weight: bold">range</span> l {
    fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
    fmt.Printf(<span style="color: #dd1144">&quot;%v: %v\n&quot;</span>, a, n)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
遍历“列表”，两个值，一个是索引，另一个是列表成员。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
“切片”的行为同“列表”一样。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">map</code> 的话，则会迭代 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">key</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">vlaue</code> ：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> l = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">string</span>]<span style="color: #445588; font-weight: bold">int</span>{<span style="color: #dd1144">&quot;a&quot;</span>: <span style="color: #009999">3</span>, <span style="color: #dd1144">&quot;b&quot;</span>: <span style="color: #009999">9</span>, <span style="color: #dd1144">&quot;c&quot;</span>: <span style="color: #009999">4</span>}
    <span style="color: #000000; font-weight: bold">for</span> a, n <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #000000; font-weight: bold">range</span> l {
        fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
        fmt.Printf(<span style="color: #dd1144">&quot;%v: %v\n&quot;</span>, a, n)
    }

}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
对于 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">string</code> 则是字符索引和字符值（整数）：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> l = <span style="color: #dd1144">&quot;hello&quot;</span>
    <span style="color: #000000; font-weight: bold">for</span> a, n <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #000000; font-weight: bold">range</span> l {
        fmt.Printf(<span style="color: #dd1144">&quot;%v\n&quot;</span>, unsafe.Sizeof(a))
        fmt.Printf(<span style="color: #dd1144">&quot;%v: %v\n&quot;</span>, a, n)
    }

}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">range</code> 还可以持续读取一个通道，行为像生成器：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>


<span style="color: #000000; font-weight: bold">func</span> gen() <span style="color: #000000; font-weight: bold">chan</span> <span style="color: #445588; font-weight: bold">int</span> {
    <span style="color: #000000; font-weight: bold">var</span> ch = <span style="color: #0086B3">make</span>(<span style="color: #000000; font-weight: bold">chan</span> <span style="color: #445588; font-weight: bold">int</span>)
    <span style="color: #000000; font-weight: bold">var</span> i = <span style="color: #009999">0</span>
    <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
        <span style="color: #000000; font-weight: bold">for</span> {
            i <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
            ch <span style="color: #000000; font-weight: bold">&lt;-</span> i
            time.Sleep(<span style="color: #009999">1</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
        }
    }()
    <span style="color: #000000; font-weight: bold">return</span> ch
}

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #000000; font-weight: bold">range</span> gen() {
        fmt.Println(i)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc18"></a>
<h2 style="font-size: 18px; margin: 30px auto;">5.3. switch</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">switch</code> 是结构化的多路 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">if</code> ，我在想，在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">map</code> 简单好用的情况下它会有多少的出场率。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
可以针对一个变量：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> l = <span style="color: #009999">3</span>;
    <span style="color: #000000; font-weight: bold">switch</span> l {
        <span style="color: #000000; font-weight: bold">case</span> <span style="color: #009999">1</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;1&quot;</span>)
        <span style="color: #000000; font-weight: bold">case</span> <span style="color: #009999">2</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;2&quot;</span>)
        <span style="color: #000000; font-weight: bold">default</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;other&quot;</span>)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
针对单个变量时也可以做多值判断：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> l = <span style="color: #009999">1</span>;
    <span style="color: #000000; font-weight: bold">switch</span> l {
        <span style="color: #000000; font-weight: bold">case</span> <span style="color: #009999">1</span>,<span style="color: #009999">2</span>,<span style="color: #009999">3</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;2&quot;</span>)
        <span style="color: #000000; font-weight: bold">default</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;other&quot;</span>)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
可以把逻辑表达式放在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">case</code> 中：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> l = <span style="color: #009999">3</span>;
    <span style="color: #000000; font-weight: bold">switch</span> {
        <span style="color: #000000; font-weight: bold">case</span> l <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">1</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;1&quot;</span>)
        <span style="color: #000000; font-weight: bold">case</span> l <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">2</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;2&quot;</span>)
        <span style="color: #000000; font-weight: bold">default</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;other&quot;</span>)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
可以通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">fallthrough</code> 实现 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">next</code> 的功能，同时会跳过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">case</code> 的逻辑判断：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> l = <span style="color: #009999">1</span>;
    <span style="color: #000000; font-weight: bold">switch</span> {
        <span style="color: #000000; font-weight: bold">case</span> l <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">1</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;1&quot;</span>)
            <span style="color: #000000; font-weight: bold">fallthrough</span>
        <span style="color: #000000; font-weight: bold">case</span> l <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">2</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;2&quot;</span>)
            <span style="color: #000000; font-weight: bold">break</span>
        <span style="color: #000000; font-weight: bold">case</span> l <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">3</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;3&quot;</span>)
        <span style="color: #000000; font-weight: bold">default</span>:
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;other&quot;</span>)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc19"></a>
<h2 style="font-size: 18px; margin: 30px auto;">5.4. goto</h2>


<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> l = [<span style="color: #009999">3</span>]<span style="color: #445588; font-weight: bold">int</span>{<span style="color: #009999">1</span>,<span style="color: #009999">2</span>,<span style="color: #009999">3</span>}


    <span style="color: #000000; font-weight: bold">for</span> _, i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #000000; font-weight: bold">range</span> l {
        <span style="color: #000000; font-weight: bold">if</span> i <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">3</span> {
            <span style="color: #000000; font-weight: bold">goto</span> exit
        }
        <span style="color: #0086B3">println</span>(i)
    }

    exit:
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;exit&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
注意一下 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">label</code> 的语法，以 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">:</code> 结尾。在行前加一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">label</code> 对它之后的语句并没有额外影响。
</p>

<a class="anchor" name="toc20"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">6. 错误和异常</h1>

<a class="anchor" name="toc21"></a>
<h2 style="font-size: 18px; margin: 30px auto;">6.1. 错误</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中官方提供了专门的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">errors</code> 工具包，和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">error</code> 接口：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">type</span> <span style="color: #445588; font-weight: bold">error</span> <span style="color: #000000; font-weight: bold">interface</span> {
    Error() <span style="color: #445588; font-weight: bold">string</span>
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
所以，错误本身，并没有什么特别，用它或者不用它，不影响你写代码：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;errors&quot;</span>
)


<span style="color: #000000; font-weight: bold">func</span> getError() <span style="color: #445588; font-weight: bold">error</span> {
    <span style="color: #000000; font-weight: bold">return</span> errors.New(<span style="color: #dd1144">&quot;this is a error&quot;</span>)
}

<span style="color: #000000; font-weight: bold">type</span> Cls <span style="color: #000000; font-weight: bold">struct</span> {
    name <span style="color: #445588; font-weight: bold">string</span>
}

<span style="color: #000000; font-weight: bold">func</span> (c Cls) Error() <span style="color: #445588; font-weight: bold">string</span> {
    <span style="color: #000000; font-weight: bold">return</span> c.name
}

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> e <span style="color: #445588; font-weight: bold">error</span> = getError()
    <span style="color: #000000; font-weight: bold">var</span> c Cls = Cls{name: <span style="color: #dd1144">&quot;haha&quot;</span>}
    <span style="color: #0086B3">println</span>(e.Error())
    <span style="color: #0086B3">println</span>(c.Error())
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc22"></a>
<h2 style="font-size: 18px; margin: 30px auto;">6.2. 异常 panic, recover, defer</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中的异常，不像传统的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">throw</code> <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">catch</code> 那套，至少名字上不是。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
看一个异常的例子：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">func</span> div(i <span style="color: #445588; font-weight: bold">int</span>) <span style="color: #445588; font-weight: bold">int</span> {
    <span style="color: #000000; font-weight: bold">return</span> <span style="color: #009999">10</span> <span style="color: #000000; font-weight: bold">/</span> i
}

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> i <span style="color: #445588; font-weight: bold">int</span> = div(<span style="color: #009999">0</span>)
    <span style="color: #0086B3">println</span>(i)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
说到异常，最先想到的就是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">N / 0</code> （当然，js 中有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Infinity</code> 或者 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">NaN</code> 人家就是不用异常） ，但是，不能直接写 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">1 / 0</code> ，这种编译器还是可以发现的，得用函数包装一下编译器就不和你墨迹了。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
成功编译，在执行的时候，就能看到运行时报错，及调用栈。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
要捕捉异常，在 go 中使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">recover()</code> 函数，是的，一个函数。但是现在问题变成，这个函数如果放在前面，那么调用它时还没有异常。如果放在后面，因为异常中断了程序，无法调用。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
因此， go 搞了一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">defer</code> 语句，来把指定的语句推到当前函数执行完后再执行，有点 js 中 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">setTimeout</code> 的感觉。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">defer</span> <span style="color: #000000; font-weight: bold">func</span>(){
        <span style="color: #000000; font-weight: bold">var</span> p = <span style="color: #0086B3">recover</span>()
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;here xxxx&quot;</span>, p)
    }()
    <span style="color: #000000; font-weight: bold">var</span> i <span style="color: #445588; font-weight: bold">int</span> = div(<span style="color: #009999">0</span>)
    <span style="color: #0086B3">println</span>(i)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样一加，你就等于把异常处理了，能看到正常的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">here xxxx</code> 输出。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
要手动抛出异常，可以使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">panic()</code> 函数，它接受任何参数（反正是一个空接口）：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">defer</span> <span style="color: #000000; font-weight: bold">func</span>(){
        <span style="color: #000000; font-weight: bold">var</span> p = <span style="color: #0086B3">recover</span>()
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;here xxxx&quot;</span>, p)
    }()
    <span style="color: #0086B3">panic</span>(<span style="color: #dd1144">&quot;hello&quot;</span>)
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
看起来没异常的样子，倒像是一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">pipe</code> ， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">panic</code> 的调用值通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">recover()</code> 传递出去了。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 没有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">try</code> 的结构，异常只会延函数调用往上传播，直到被捕获：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main


<span style="color: #000000; font-weight: bold">func</span> aaa() {
    <span style="color: #0086B3">panic</span>(<span style="color: #dd1144">&quot;throw in aaa&quot;</span>)
}

<span style="color: #000000; font-weight: bold">func</span> aa() {
    <span style="color: #000000; font-weight: bold">defer</span> <span style="color: #000000; font-weight: bold">func</span>(){
        <span style="color: #000000; font-weight: bold">var</span> p = <span style="color: #0086B3">recover</span>()
        <span style="color: #000000; font-weight: bold">if</span> p <span style="color: #000000; font-weight: bold">!=</span> <span style="color: #000000; font-weight: bold">nil</span> {
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;aa&quot;</span>, p)
            <span style="color: #0086B3">panic</span>(p)
        }
    }()
    aaa()
}

<span style="color: #000000; font-weight: bold">func</span> a() {
    <span style="color: #000000; font-weight: bold">defer</span> <span style="color: #000000; font-weight: bold">func</span>(){
        <span style="color: #000000; font-weight: bold">var</span> p = <span style="color: #0086B3">recover</span>()
        <span style="color: #000000; font-weight: bold">if</span> p <span style="color: #000000; font-weight: bold">!=</span> <span style="color: #000000; font-weight: bold">nil</span> {
            <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;a&quot;</span>, p)
        }
    }()
    aa()
}

<span style="color: #000000; font-weight: bold">func</span> main() {
    a()
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc23"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">7. goroutine, 通道, 并发</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这些被看成是 go 的特点。 <em style="color: #d75100; font-style: normal;">goroutine</em> ，有些人称其为 go程，或者“协程”，我喜欢叫它“独立上下文”。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">通道</em> 是一种数据类型，听说是用于不同独立上下文的信息交换，行为类似操作系统的 <em style="color: #d75100; font-style: normal;">pipe</em> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">goroutine</em> 肯定是很轻量的东西，随时创建，创建销毁。但是我目前不清楚，它们到底是不是可以“并行”， go 本身是不是可以在多个进程间调度它们，在保持看起来是同一个运行时的前提下。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go</code> 语句可以开启一个 <em style="color: #d75100; font-style: normal;">goroutine</em> ：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;in go&quot;</span>)
    }()
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
直接运行，会发现看不到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">in go</code> ，打印 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">over</code> 之后就结束了，嗯……，暂停一下才能看到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go func()</code> 的输出：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;time&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;in go&quot;</span>)
    }()
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
    time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 原生提供了 <em style="color: #d75100; font-style: normal;">goroutine</em> ，但不像 js 那种会默认自己控制一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">event loop</code> ，也不像 Python 的某些工具，会显式地提供 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">event.start()</code> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
不过 <em style="color: #d75100; font-style: normal;">通道</em> 倒是提供了默认的“阻塞”特性：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> ch = <span style="color: #0086B3">make</span>(<span style="color: #000000; font-weight: bold">chan</span> <span style="color: #445588; font-weight: bold">string</span>)
    <span style="color: #000000; font-weight: bold">var</span> callback = <span style="color: #000000; font-weight: bold">func</span>() {
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;in go&quot;</span>)
        <span style="color: #000000; font-weight: bold">var</span> s <span style="color: #445588; font-weight: bold">string</span> = <span style="color: #000000; font-weight: bold">&lt;-</span>ch
        <span style="color: #0086B3">println</span>(s)
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;here&quot;</span>)
    }
    <span style="color: #000000; font-weight: bold">go</span> callback()
    ch <span style="color: #000000; font-weight: bold">&lt;-</span> <span style="color: #dd1144">&quot;write&quot;</span>
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这段代码可以确定地得到：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">in go
write
here
over
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样的输出，看起来就像是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">ch &lt;- "write"</code> 之后，再执行 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback()</code> 一样。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果不把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">ch</code> 的读放在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">callback()</code> 中，在外面就立即读出：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">go</span> callback()
ch <span style="color: #000000; font-weight: bold">&lt;-</span> <span style="color: #dd1144">&quot;write&quot;</span>
<span style="color: #000000; font-weight: bold">var</span> s <span style="color: #445588; font-weight: bold">string</span> = <span style="color: #000000; font-weight: bold">&lt;-</span>ch
<span style="color: #0086B3">println</span>(s)
<span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
那么编译时就会给出死锁错误。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
关于死锁，我试过，先读或者先写，都会死，似乎只有通过 <em style="color: #d75100; font-style: normal;">goroutine</em> “同时”读写才行。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
但是，如果从来就不往 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">ch</code> 里写任何东西，又可以正常编译：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> ch = <span style="color: #0086B3">make</span>(<span style="color: #000000; font-weight: bold">chan</span> <span style="color: #445588; font-weight: bold">string</span>)
    <span style="color: #000000; font-weight: bold">var</span> callback = <span style="color: #000000; font-weight: bold">func</span>() {
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;in go&quot;</span>)
        <span style="color: #000000; font-weight: bold">var</span> s <span style="color: #445588; font-weight: bold">string</span> = <span style="color: #000000; font-weight: bold">&lt;-</span>ch
        <span style="color: #0086B3">println</span>(s)
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;here&quot;</span>)
    }
    <span style="color: #000000; font-weight: bold">go</span> callback()
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
最终只会有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">over</code> 输出就是了。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
挻矛盾的，至少 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">&lt;-ch</code> 会阻塞的说法不准确。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> ch = <span style="color: #0086B3">make</span>(<span style="color: #000000; font-weight: bold">chan</span> <span style="color: #445588; font-weight: bold">string</span>)
    <span style="color: #000000; font-weight: bold">var</span> callback = <span style="color: #000000; font-weight: bold">func</span>() {
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;in go&quot;</span>)
        <span style="color: #000000; font-weight: bold">var</span> s <span style="color: #445588; font-weight: bold">string</span> = <span style="color: #000000; font-weight: bold">&lt;-</span>ch
        <span style="color: #0086B3">println</span>(s)
        <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;here&quot;</span>)
    }
    <span style="color: #000000; font-weight: bold">go</span> callback()
    time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
    ch <span style="color: #000000; font-weight: bold">&lt;-</span> <span style="color: #dd1144">&quot;write&quot;</span>
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这段代码，最终只会输出：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">in go
over
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
目前搞不懂。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
下面来求证最开始的那个问题， <em style="color: #d75100; font-style: normal;">goroutine</em> 是否在多进程上调度，写个死循环：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int</span> = <span style="color: #009999">0</span>
    <span style="color: #000000; font-weight: bold">for</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            count <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
            <span style="color: #0086B3">println</span>(count)
            <span style="color: #000000; font-weight: bold">for</span> {}
        }()
    }
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
通过操作系统的监控，可以发现能跑满所有 CPU 核心，哈，这个机制还是很可以的，特别是针对计算密集的场景。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
不过剩下的问题是，go 中哪些数据类型是进程并行安全的？
</p>

<a class="anchor" name="toc24"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">8. 指针，空间分配和存续</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 里面有像 C 中一样的指针，同时可以使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">new()</code> 来分配一块指定类型所需大小的空间：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> p <span style="color: #000000; font-weight: bold">*</span><span style="color: #445588; font-weight: bold">int</span> = <span style="color: #0086B3">new</span>(<span style="color: #445588; font-weight: bold">int</span>)
<span style="color: #000000; font-weight: bold">*</span>p = <span style="color: #009999">123</span>
<span style="color: #0086B3">println</span>(<span style="color: #000000; font-weight: bold">*</span>p)
<span style="color: #0086B3">println</span>(p)
<span style="color: #000000; font-weight: bold">return</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
语法上，使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">*</code> 对指针进行求值，使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">&amp;</code> 可以获取地址（并赋值给指针）：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> m = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">string</span>]<span style="color: #445588; font-weight: bold">string</span>{<span style="color: #dd1144">&quot;a&quot;</span>: <span style="color: #dd1144">&quot;123&quot;</span>}
<span style="color: #000000; font-weight: bold">var</span> p <span style="color: #000000; font-weight: bold">*map</span>[<span style="color: #445588; font-weight: bold">string</span>]<span style="color: #445588; font-weight: bold">string</span>
p = <span style="color: #000000; font-weight: bold">&amp;</span>m
fmt.Println((<span style="color: #000000; font-weight: bold">*</span>p)[<span style="color: #dd1144">&quot;a&quot;</span>])
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">new</code> 分配的空间，由 go 统一管理，即使退出函数，也不会直接释放：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> alloc() <span style="color: #000000; font-weight: bold">*</span><span style="color: #445588; font-weight: bold">int</span> {
    <span style="color: #000000; font-weight: bold">var</span> p <span style="color: #000000; font-weight: bold">*</span><span style="color: #445588; font-weight: bold">int</span> = <span style="color: #0086B3">new</span>(<span style="color: #445588; font-weight: bold">int</span>)
    <span style="color: #000000; font-weight: bold">return</span> p
}

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> p <span style="color: #000000; font-weight: bold">*</span><span style="color: #445588; font-weight: bold">int</span> = alloc()
    <span style="color: #000000; font-weight: bold">*</span>p = <span style="color: #009999">123</span>
    <span style="color: #0086B3">println</span>(p)
    <span style="color: #0086B3">println</span>(<span style="color: #000000; font-weight: bold">&amp;</span>p)
    <span style="color: #0086B3">println</span>(<span style="color: #000000; font-weight: bold">*</span>p)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
仅对于 <em style="color: #d75100; font-style: normal;">切片</em>， <em style="color: #d75100; font-style: normal;">映射</em>， <em style="color: #d75100; font-style: normal;">通道</em> ，可以使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">make()</code> 来分配空间（但是也可以不单独调用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">make</code> ，而是声明时直接完成初始化了，这时，空间的分配由系统自动处理，可能会比初始值大）：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">var</span> s []<span style="color: #445588; font-weight: bold">int</span> = []<span style="color: #445588; font-weight: bold">int</span>{<span style="color: #009999">1</span>,<span style="color: #009999">2</span>,<span style="color: #009999">3</span>}
<span style="color: #000000; font-weight: bold">var</span> s2 []<span style="color: #445588; font-weight: bold">int</span>
s2 = <span style="color: #0086B3">make</span>([]<span style="color: #445588; font-weight: bold">int</span>, <span style="color: #009999">20</span>)
fmt.Println(s)
fmt.Println(s2)
<span style="color: #000000; font-weight: bold">return</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 里没有单独的指向函数的指针，也不需要，函数本身就是“第一公民”。
</p>

<a class="anchor" name="toc25"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">9. 链表</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
链表的实现在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">container/list</code> 中的两个结构， <em style="color: #d75100; font-style: normal;">List</em> 和 <em style="color: #d75100; font-style: normal;">Element</em> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">Element</em> 比较简单，成员有：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Value interface{}</code>
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Next() *Element</code>
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Prev() *Element</code>
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">List</em> 的方法多一些：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">static <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">list.New() *List</code> 初始化一个列表
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Init() *List</code> 初始化或者清空列表
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Back() *Element</code> 最后一个元素
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Front() *Element</code> 第一个元素
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">InsertAfter(v interface{}, mark *Element) *Element</code> 在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">mark</code> 后面添加
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">InsertBefore(v interface{}, mark *Element) *Element</code> 在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">mark</code> 前面添加
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Len() int</code> 链表长度
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">MoveAfter(e *Element, mark *Element)</code> 把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">e</code> 移动到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">mark</code> 后面
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">MoveBefore(e *Element, mark *Element)</code> 把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">e</code> 移动到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">mark</code> 前面
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">MoveToBack(e *Element)</code> 把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">e</code> 放到最后
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">MoveToFront(e *Element)</code> 把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">e</code> 放到最前
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">PushBack(v interface{}) *Element</code> 在末尾追加
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">PushFront(v interface{}) *Element</code> 在最前面添加
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">PushBackList(l *List)</code> 复制 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">l</code> 并在末尾连接
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">PushFrontList(l *List)</code> 复制 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">l</code>并在最前面连接
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Remove(e *Element) interface{}</code> 删除指定元素，同时返回元素的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Value</code>
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
简单的例子：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;container/list&quot;</span>
    <span style="color: #dd1144">&quot;fmt&quot;</span>
)


<span style="color: #000000; font-weight: bold">func</span> show(l <span style="color: #000000; font-weight: bold">*</span>list.List) {
    <span style="color: #000000; font-weight: bold">var</span> e <span style="color: #000000; font-weight: bold">*</span>list.Element
    e = l.Front()
    <span style="color: #000000; font-weight: bold">if</span> e <span style="color: #000000; font-weight: bold">==</span> <span style="color: #000000; font-weight: bold">nil</span> { <span style="color: #000000; font-weight: bold">return</span> }
    <span style="color: #000000; font-weight: bold">for</span> {
        fmt.Print(e.Value)
        e = e.Next()
        <span style="color: #000000; font-weight: bold">if</span> e <span style="color: #000000; font-weight: bold">==</span> <span style="color: #000000; font-weight: bold">nil</span> { <span style="color: #000000; font-weight: bold">break</span> }
        fmt.Print(<span style="color: #dd1144">&quot; -&gt; &quot;</span>)
    }
}


<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> p <span style="color: #000000; font-weight: bold">*</span>list.List = list.New()
    (<span style="color: #000000; font-weight: bold">*</span>p).PushBack(<span style="color: #009999">2</span>)
    p.PushBack(<span style="color: #dd1144">&quot;3&quot;</span>)
    show(p)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
用自己 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">PushBackList</code> 的例子：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> p <span style="color: #000000; font-weight: bold">*</span>list.List = list.New()
    <span style="color: #000000; font-weight: bold">var</span> e <span style="color: #000000; font-weight: bold">*</span>list.Element = (<span style="color: #000000; font-weight: bold">*</span>p).PushBack(<span style="color: #009999">2</span>)
    p.PushBack(<span style="color: #dd1144">&quot;3&quot;</span>)
    show(p)
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;\n\n&quot;</span>)
    p.PushBackList(p)
    e.Value = <span style="color: #009999">88</span>
    show(p)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
最后的输出是： <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">88 -&gt; 3 -&gt; 2 -&gt; 3</code> ，能看出 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">p</code> 是复制了一份添加的。
</p>

<a class="anchor" name="toc26"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">10. 字符与字节</h1>

<a class="anchor" name="toc27"></a>
<h2 style="font-size: 18px; margin: 30px auto;">10.1. rune, byte, string</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
先说一个限制，或者说一个前提，go 的源码被限制为必须使用 UTF-8 编码。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
前面说过， <em style="color: #d75100; font-style: normal;">rune</em> 是“字符”， <em style="color: #d75100; font-style: normal;">byte</em> 类型是字节，而 “字符串” 是 <em style="color: #d75100; font-style: normal;">string</em> ，所以注意，这里其实有三种数据类型。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> s = <span style="color: #dd1144">&quot;中文&quot;</span>
    fmt.Println(<span style="color: #0086B3">len</span>(s))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的输出是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">6</code> ，显然，“字符串”应该被叫作“字节串”。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这几个基本类型的转换在 go 中，倒是很直观，直接“声明”就可以完成转换了：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> s = <span style="color: #dd1144">&quot;中文go&quot;</span>
    <span style="color: #000000; font-weight: bold">var</span> ss = []<span style="color: #0086B3">rune</span>(s)
    fmt.Println(<span style="color: #0086B3">len</span>(ss))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
转换成 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">[]rune</code> 就可以正确得到“字符个数”。 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">byte</code> 同理：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> s = <span style="color: #dd1144">&quot;中文go&quot;</span>
    <span style="color: #000000; font-weight: bold">var</span> ss = []<span style="color: #0086B3">byte</span>(s)
    fmt.Println(<span style="color: #0086B3">len</span>(ss), <span style="color: #0086B3">len</span>(s))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
转成字符串也是直接的：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> b = []<span style="color: #445588; font-weight: bold">byte</span>{<span style="color: #a61717; background-color: #e3d2d2">&#39;\</span>x01<span style="color: #a61717; background-color: #e3d2d2">&#39;</span>, <span style="color: #a61717; background-color: #e3d2d2">&#39;\</span>x64<span style="color: #a61717; background-color: #e3d2d2">&#39;</span>}
    <span style="color: #000000; font-weight: bold">var</span> ss = []<span style="color: #445588; font-weight: bold">rune</span>{<span style="color: #dd1144">&#39;中&#39;</span>, <span style="color: #dd1144">&#39;文&#39;</span>}
    fmt.Println(ss)
    <span style="color: #000000; font-weight: bold">var</span> s = <span style="color: #0086B3">string</span>(ss)
    <span style="color: #000000; font-weight: bold">var</span> bs = <span style="color: #0086B3">string</span>(b)
    fmt.Println(s, bs)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这些转换，都是基于 UTF-8 这个前提。对于其它编码的情况怎么处理呢？那只能依赖额外的模块了。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
目前使用的是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">golang.org/x/text</code> ：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;fmt&quot;</span>
    <span style="color: #dd1144">&quot;golang.org/x/text/encoding/simplifiedchinese&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> UTF8toGBK(s []<span style="color: #445588; font-weight: bold">byte</span>) []<span style="color: #445588; font-weight: bold">byte</span> {
    b, err <span style="color: #000000; font-weight: bold">:=</span> simplifiedchinese.GBK.NewEncoder().Bytes(s)
    <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">!=</span> <span style="color: #000000; font-weight: bold">nil</span> {
        <span style="color: #0086B3">panic</span>(err)
    }
    <span style="color: #000000; font-weight: bold">return</span> b
}
<span style="color: #000000; font-weight: bold">func</span> GBKtoUTF8(s []<span style="color: #445588; font-weight: bold">byte</span>) []<span style="color: #445588; font-weight: bold">byte</span> {
    b, err <span style="color: #000000; font-weight: bold">:=</span> simplifiedchinese.GBK.NewDecoder().Bytes(s)
    <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">!=</span> <span style="color: #000000; font-weight: bold">nil</span> {
        <span style="color: #0086B3">panic</span>(err)
    }
    <span style="color: #000000; font-weight: bold">return</span> b
}


<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> b []<span style="color: #445588; font-weight: bold">byte</span> = UTF8toGBK([]<span style="color: #0086B3">byte</span>(<span style="color: #dd1144">&quot;中文&quot;</span>))
    fmt.Println(b)
    <span style="color: #000000; font-weight: bold">var</span> u []<span style="color: #445588; font-weight: bold">byte</span> = GBKtoUTF8(b)
    fmt.Println(u)
    <span style="color: #000000; font-weight: bold">var</span> s = <span style="color: #0086B3">string</span>(u)
    fmt.Println(s)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
基本上，go 中的做法都是基于 UTF-8 的字节数据做直接的转换操作。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
相较而言， Python3.x 中的字符串是抽象的真正的“字符串”，和字节没有直接关系的处理方式，我觉得是更现代的做法。
</p>

<a class="anchor" name="toc28"></a>
<h2 style="font-size: 18px; margin: 30px auto;">10.2. strings 更多及“零值可用”</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">string</em> 在 go 中，本来是一块不可变的字节内容，但是字符串的处理却又是很常见的场景，所以 go 提供了额外的工具来处理字符串的读写。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
首先一定要记住的一点，就是“字节串”，而不是“字符串”：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;fmt&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> s <span style="color: #445588; font-weight: bold">string</span> = <span style="color: #dd1144">&quot;中文&quot;</span>
    fmt.Println(s[:<span style="color: #009999">3</span>])
    fmt.Println(<span style="color: #0086B3">string</span>([]<span style="color: #0086B3">rune</span>(s)[:<span style="color: #009999">1</span>]))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的代码都会输出“中”字。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果对字符串的读写处理，有更多的一些需求，比如性能（普通的字符串拼接因为要重新分配空间，所以频繁的操作成本还是比较大的）， 那么 go 中有专门的工具：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;strings&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> s strings.Builder
    <span style="color: #0086B3">println</span>(s.String(), s.Len(), s.Cap())
    s.WriteByte(<span style="color: #dd1144">&#39;a&#39;</span>)
    s.WriteString(<span style="color: #dd1144">&quot;哈哈&quot;</span>)
    s.WriteRune(<span style="color: #dd1144">&#39;中&#39;</span>)
    s.Write([]<span style="color: #0086B3">byte</span>(<span style="color: #dd1144">&quot;文&quot;</span>))
    <span style="color: #0086B3">println</span>(s.String(), s.Len(), s.Cap())
    s.Grow(<span style="color: #009999">100</span>)
    s.WriteString(<span style="color: #dd1144">&quot;123455669990&quot;</span>)
    <span style="color: #0086B3">println</span>(s.String(), s.Len(), s.Cap())
    <span style="color: #0086B3">println</span>(strings.ToTitle(s.String()))
    s.Reset()
    <span style="color: #0086B3">println</span>(s.String(), s.Len(), s.Cap())
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
关于上面的代码：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">strings.Builder</code> 不需要显式的初始化，直接就可以用。这是 go 的 <em style="color: #d75100; font-style: normal;">零值可用</em> 机制。至于哪些东西是 <em style="color: #d75100; font-style: normal;">零值可用</em> 的，不一定。
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">strings</code> 这个包，除了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Builder</code> ，还提供了其它针对字符串的工具，但是这些工具不能作用于 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Builder</code> 对象。
</li>
<li style="margin: 10px auto;">要获取 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Builder</code> 的长度，需要用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Len()</code> 方法，你不能用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">len(builder)</code> ， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">len()</code> 没办法通用（说好的“面向接口”呢）。
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Cap()</code> 是获取当前对象的空间大小信息， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Write()</code> 的东西超出了预分配的大小， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">builder</code> 会自动“整理重分配”。
</li>
<li style="margin: 10px auto;">你可以通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Grow()</code> 自己预先调整空间，结果是“至少”那么多。 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Reset()</code> 是重置，看起来可能也会直接释放空间。
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
从这里看 go 的种种，真的谈不上美感，也许是实用吧。
</p>

<a class="anchor" name="toc29"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">11. 文件IO</h1>

<a class="anchor" name="toc30"></a>
<h2 style="font-size: 18px; margin: 30px auto;">11.1. 文件读写</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中的文件相关功能，由 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">os</code> 模块提供支持，但同时，还有像 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">io/ioutil</code> 之类的工具封装。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">os</code> 中，有对 <em style="color: #d75100; font-style: normal;">File</em> ， <em style="color: #d75100; font-style: normal;">fd</em>，及各种具体的文件类型，文件权限的处理。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
我去翻 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">os</code> 的 API 时，找到了两个“打开文件”的方法，一个是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Open()</code> 另一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">OpenFile()</code> ，第一个只是为“读”打开，第二个有“读写”。这时我才知道， go 中，是不支持“参数默认值”机制的。如果一定要做，可以通过“可变参数”自己折腾。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
不支持“参数默认值”是一种设计上的选择，无疑会带来很多的不便，但是我并不认为会带来多少“意图清晰”的收益。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
当然，如果你在网上搜索一下为什么 go 不支持参数默认值，就会看到很多“屁话”，这种感觉，就像很多人无脑说 OSX 的设计是多么好一样，好到把 Enter 用成“改名”都是一种优越感（吐）。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
直接用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">os</code> 读取完整的文件，还是有些麻烦的：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;fmt&quot;</span>
    <span style="color: #dd1144">&quot;os&quot;</span>
    <span style="color: #dd1144">&quot;strings&quot;</span>
    <span style="color: #dd1144">&quot;io&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    file, err <span style="color: #000000; font-weight: bold">:=</span> os.Open(<span style="color: #dd1144">&quot;/home/zys/temp/demo.go&quot;</span>)
    <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">!=</span> <span style="color: #000000; font-weight: bold">nil</span> {
        fmt.Println(err)
        <span style="color: #0086B3">panic</span>(err)
    }

    <span style="color: #000000; font-weight: bold">var</span> data strings.Builder
    <span style="color: #000000; font-weight: bold">for</span> {
        <span style="color: #000000; font-weight: bold">var</span> buff []<span style="color: #445588; font-weight: bold">byte</span> = <span style="color: #0086B3">make</span>([]<span style="color: #445588; font-weight: bold">byte</span>, <span style="color: #009999">10</span>)
        _, err <span style="color: #000000; font-weight: bold">:=</span> file.Read(buff)
        <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">==</span> io.EOF { <span style="color: #000000; font-weight: bold">break</span> }
        data.Write(buff)
    }
    fmt.Println(data.String())
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
每次只能读取具体大小的字节，通过判断 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">EOF</code> 决定下一步行为。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
直接使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">ioutil</code> 会方便一些：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;fmt&quot;</span>
    <span style="color: #dd1144">&quot;os&quot;</span>
    <span style="color: #dd1144">&quot;io/ioutil&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    file, err <span style="color: #000000; font-weight: bold">:=</span> os.Open(<span style="color: #dd1144">&quot;/home/zys/temp/demo.go&quot;</span>)
    <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">!=</span> <span style="color: #000000; font-weight: bold">nil</span> {
        fmt.Println(err)
        <span style="color: #0086B3">panic</span>(err)
    }
    content, err <span style="color: #000000; font-weight: bold">:=</span> ioutil.ReadAll(file)
    fmt.Println(<span style="color: #0086B3">string</span>(content))

    content2, err <span style="color: #000000; font-weight: bold">:=</span> ioutil.ReadFile(<span style="color: #dd1144">&quot;/home/zys/temp/demo.go&quot;</span>)
    fmt.Println(<span style="color: #0086B3">string</span>(content2))
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
写文件也是类似的：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;fmt&quot;</span>
    <span style="color: #dd1144">&quot;os&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    file, err <span style="color: #000000; font-weight: bold">:=</span> os.OpenFile(<span style="color: #dd1144">&quot;/home/zys/temp/demo.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span style="color: #009999">0755</span>)
    <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">!=</span> <span style="color: #000000; font-weight: bold">nil</span> {
        fmt.Println(err)
        <span style="color: #0086B3">panic</span>(err)
    }
    n, err <span style="color: #000000; font-weight: bold">:=</span> file.Write([]<span style="color: #0086B3">byte</span>(<span style="color: #dd1144">&quot;890&quot;</span>))
    n2, err <span style="color: #000000; font-weight: bold">:=</span> file.WriteString(<span style="color: #dd1144">&quot;中文&quot;</span>)
    <span style="color: #0086B3">println</span>(n, n2)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc31"></a>
<h2 style="font-size: 18px; margin: 30px auto;">11.2. 标准输入输出</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">os.Stdin</code>, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">os.Stdout</code>, <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">os.Stderr</code> 是三个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">File Like</code> 的对象。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
标准输出和错误输出都很简单：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;os&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    os.Stdout.WriteString(<span style="color: #dd1144">&quot;123&quot;</span>)
    os.Stderr.WriteString(<span style="color: #dd1144">&quot;123&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
输入处理直接地可以是：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">package main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;os&quot;</span>
    <span style="color: #dd1144">&quot;fmt&quot;</span>
    <span style="color: #dd1144">&quot;strings&quot;</span>
)

func main() {
    var s strings<span style="color: #000000; font-weight: bold">.</span>Builder
    <span style="color: #000000; font-weight: bold">for</span> {
        var buff []byte <span style="color: #000000; font-weight: bold">=</span> make([]byte, <span style="color: #009999">1</span>)
        _, err :<span style="color: #000000; font-weight: bold">=</span> os<span style="color: #000000; font-weight: bold">.</span>Stdin<span style="color: #000000; font-weight: bold">.</span>Read(buff)
        <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">!=</span> nil {
            <span style="color: #000000; font-weight: bold">break</span>
        }
        <span style="color: #000000; font-weight: bold">if</span> buff[<span style="color: #009999">0</span>] <span style="color: #000000; font-weight: bold">==</span> <span style="color: #dd1144">&#39;\n&#39;</span> {
            fmt<span style="color: #000000; font-weight: bold">.</span>Println(s<span style="color: #000000; font-weight: bold">.</span>String())
            <span style="color: #000000; font-weight: bold">break</span>
        }
        s<span style="color: #000000; font-weight: bold">.</span>Write(buff)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc32"></a>
<h2 style="font-size: 18px; margin: 30px auto;">11.3. File Like</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
（暂时没找到现成的方案）
</p>

<a class="anchor" name="toc33"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">12. 命令行参数</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
完善一些的工具，就是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">flag</code> 这个模块。不过最直接的处理是使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">os.Args</code> 。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;os&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">for</span> idx, args <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #000000; font-weight: bold">range</span> os.Args {
        <span style="color: #0086B3">println</span>(idx, args)
    }
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
编译后执行：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">./demo --abc <span style="color: #000000; font-weight: bold">=</span> <span style="color: #009999">123</span> -b <span style="color: #009999">1</span> <span style="color: #dd1144">&quot;1 2 3&quot;</span>
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
能看到输出的内容是：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">0 ./demo
1 --abc
2 =
3 123
4 -b
5 1
6 1 2 3
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
基本上就是以空格分割，但是额外处理了引号。
</p>

<a class="anchor" name="toc34"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">13. 日志</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 官方自带了一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">log</code> 模块，有基本的配置能力。但是最重要的 <em style="color: #d75100; font-style: normal;">Level</em> 没有，这就有点尴尬。自己处理的话，只能不同的 <em style="color: #d75100; font-style: normal;">Level</em> 单独定义一个“实例”，然后通过配置再处理 output 。当然，第三方有一些功能更完整的模块。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> (
    <span style="color: #dd1144">&quot;os&quot;</span>
    <span style="color: #dd1144">&quot;log&quot;</span>
)

<span style="color: #000000; font-weight: bold">func</span> main() {
    InfoLog <span style="color: #000000; font-weight: bold">:=</span> log.New(os.Stdout, <span style="color: #dd1144">&quot;INFO &quot;</span>, log.Ldate|log.Ltime|log.Lshortfile)
    ErrorLog <span style="color: #000000; font-weight: bold">:=</span> log.New(os.Stdout, <span style="color: #dd1144">&quot;ERROR &quot;</span>, log.Ldate|log.Ltime|log.Lshortfile)
    InfoLog.Print(<span style="color: #dd1144">&quot;here&quot;</span>)
    ErrorLog.Print(<span style="color: #dd1144">&quot;here&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">INFO</code> 部分是 <em style="color: #d75100; font-style: normal;">Prefix</em> ， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">log.Ldate...</code> 是 <em style="color: #d75100; font-style: normal;">Flags</em> ，就提供了有限的几个配置。
</p>

<a class="anchor" name="toc35"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">14. 测试</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 有自带测试支持，主要在两个方面。一是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go</code> 这个命令行工具，专门有一组 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go test</code> 功能，这套功能配合约定的“文件名”，“函数”等，可以直接一键运行项目中的测试用例。另一方面，官方提供了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">testing</code> 这个包，里面有测试的基本的功能实现，但是没有断言……
</p>

<a class="anchor" name="toc36"></a>
<h2 style="font-size: 18px; margin: 30px auto;">14.1. 功能测试</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里的几个规则包括：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">文件名以 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_test</code> 结束。
</li>
<li style="margin: 10px auto;">函数以 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Test</code> 开头，参数是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">*testing.T</code> 。
</li>
<li style="margin: 10px auto;">或者一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">TestMain</code> 的函数，参数是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">*testing.M</code> 。
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
下面的代码写在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">demo_test.go</code> 文件中。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;testing&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> add(a <span style="color: #445588; font-weight: bold">int</span>, b <span style="color: #445588; font-weight: bold">int</span>) <span style="color: #445588; font-weight: bold">int</span> {
    <span style="color: #000000; font-weight: bold">return</span> a <span style="color: #000000; font-weight: bold">+</span> b
}

<span style="color: #000000; font-weight: bold">func</span> TestAdd(t <span style="color: #000000; font-weight: bold">*</span>testing.T) {
    t.Run(<span style="color: #dd1144">&quot;first&quot;</span>, <span style="color: #000000; font-weight: bold">func</span>(t <span style="color: #000000; font-weight: bold">*</span>testing.T){
        <span style="color: #000000; font-weight: bold">if</span> add(<span style="color: #009999">1</span>, <span style="color: #009999">2</span>) <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">3</span> {
            t.Fail()
        }
    })

    t.Run(<span style="color: #dd1144">&quot;second&quot;</span>, <span style="color: #000000; font-weight: bold">func</span>(t <span style="color: #000000; font-weight: bold">*</span>testing.T){
        <span style="color: #000000; font-weight: bold">if</span> add(<span style="color: #009999">1</span>, <span style="color: #009999">2</span>) <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">3</span> {
        }
    })
}

<span style="color: #000000; font-weight: bold">func</span> TestXX(t <span style="color: #000000; font-weight: bold">*</span>testing.T) {
    t.Run(<span style="color: #dd1144">&quot;first&quot;</span>, <span style="color: #000000; font-weight: bold">func</span>(t <span style="color: #000000; font-weight: bold">*</span>testing.T){
        <span style="color: #000000; font-weight: bold">if</span> add(<span style="color: #009999">1</span>, <span style="color: #009999">2</span>) <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">3</span> {
        }
    })

    t.Run(<span style="color: #dd1144">&quot;second&quot;</span>, <span style="color: #000000; font-weight: bold">func</span>(t <span style="color: #000000; font-weight: bold">*</span>testing.T){
        t.Run(<span style="color: #dd1144">&quot;another&quot;</span>, <span style="color: #000000; font-weight: bold">func</span>(t <span style="color: #000000; font-weight: bold">*</span>testing.T){
            <span style="color: #000000; font-weight: bold">if</span> add(<span style="color: #009999">1</span>, <span style="color: #009999">2</span>) <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">3</span> {
                t.Fail()
            }
        })
    })
}


<span style="color: #000000; font-weight: bold">func</span> setup() {
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;setup&quot;</span>)
}

<span style="color: #000000; font-weight: bold">func</span> teardown() {
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;teardown&quot;</span>)
}

<span style="color: #000000; font-weight: bold">func</span> TestMain(m <span style="color: #000000; font-weight: bold">*</span>testing.M) {
    setup()
    m.Run()
    teardown()
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
执行的时候：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go <span style="color: #0086B3">test</span> demo_test.go
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样只能看到 <em style="color: #d75100; font-style: normal;">Fail</em> 的用例。要看全部的测试用例，可以：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go <span style="color: #0086B3">test</span> demo_test.go -test.v
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc37"></a>
<h2 style="font-size: 18px; margin: 30px auto;">14.2. 性能测试</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
它的几个规则包括：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">文件名以 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">_test</code> 结束。
</li>
<li style="margin: 10px auto;">函数以 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Benchmark</code> 开头，参数是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">*testing.B</code> 。
</li>
<li style="margin: 10px auto;">或者一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">TestMain</code> 的函数，参数是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">*testing.M</code> 。
</li>
<li style="margin: 10px auto;">在命令行执行的时候，需要加上 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">bench</code> 参数。
</li>
</ul>


<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;testing&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;strings&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> add(a <span style="color: #445588; font-weight: bold">string</span>, b <span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span> {
    <span style="color: #000000; font-weight: bold">return</span> a <span style="color: #000000; font-weight: bold">+</span> b
}

<span style="color: #000000; font-weight: bold">func</span> add2(a <span style="color: #445588; font-weight: bold">string</span>, b <span style="color: #445588; font-weight: bold">string</span>) <span style="color: #445588; font-weight: bold">string</span> {
    <span style="color: #000000; font-weight: bold">var</span> s strings.Builder
    s.WriteString(a)
    s.WriteString(b)
    <span style="color: #000000; font-weight: bold">return</span> s.String()
}

<span style="color: #000000; font-weight: bold">func</span> BenchmarkAdd(b <span style="color: #000000; font-weight: bold">*</span>testing.B) {
    b.Run(<span style="color: #dd1144">&quot;add&quot;</span>, <span style="color: #000000; font-weight: bold">func</span> (b <span style="color: #000000; font-weight: bold">*</span>testing.B) {
        b.ResetTimer()
        <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; b.N; i<span style="color: #000000; font-weight: bold">++</span> {
            add(<span style="color: #dd1144">&quot;1&quot;</span>, <span style="color: #dd1144">&quot;2&quot;</span>)
        }
    })
    b.Run(<span style="color: #dd1144">&quot;add2&quot;</span>, <span style="color: #000000; font-weight: bold">func</span> (b <span style="color: #000000; font-weight: bold">*</span>testing.B) {
        b.ResetTimer()
        <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; b.N; i<span style="color: #000000; font-weight: bold">++</span> {
            add2(<span style="color: #dd1144">&quot;1&quot;</span>, <span style="color: #dd1144">&quot;2&quot;</span>)
        }
    })
}


<span style="color: #000000; font-weight: bold">func</span> TestMain(t <span style="color: #000000; font-weight: bold">*</span>testing.M) {
    t.Run()
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
和功能测试一样的，只是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">*testing.B</code> 提供了不同的功能。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
执行的时候：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go <span style="color: #0086B3">test</span> -bench<span style="color: #000000; font-weight: bold">=</span>. demo_test.go -test.v
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<a class="anchor" name="toc38"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">15. 并发与锁</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
作为一个把并发并行作为特性来设计的语言，却还有如此复杂多样的处理机制。同时在语法层面，对于是否“并行安全”也没有单独的设计，这样，当你使用某个数据结构，或者某个方法的时候，除非看文档，否则，你是不知道它是否是并行安全的。如此，我觉得，可能是会存在层层加锁的问题。
</p>

<a class="anchor" name="toc39"></a>
<h2 style="font-size: 18px; margin: 30px auto;">15.1. go 的调度能力</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这个前面提到过。下面的死循环代码是可以跑满所有 CPU 核心的：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int</span> = <span style="color: #009999">0</span>
    <span style="color: #000000; font-weight: bold">for</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            count <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
            <span style="color: #0086B3">println</span>(count)
            <span style="color: #000000; font-weight: bold">for</span> {}
        }()
    }
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
但是不用 <em style="color: #d75100; font-style: normal;">goroutine</em> 的编译后的 go 程序，就没有特别之处了：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int64</span> = <span style="color: #009999">0</span>
    <span style="color: #000000; font-weight: bold">var</span> a <span style="color: #445588; font-weight: bold">float64</span> = <span style="color: #009999">3.1415926</span>
    <span style="color: #000000; font-weight: bold">var</span> m = <span style="color: #000000; font-weight: bold">map</span>[<span style="color: #445588; font-weight: bold">float64</span>]<span style="color: #445588; font-weight: bold">float64</span>{}
    <span style="color: #000000; font-weight: bold">for</span> {
        <span style="color: #000000; font-weight: bold">for</span> {
            count <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
            a = a <span style="color: #000000; font-weight: bold">*</span> <span style="color: #0086B3">float64</span>(count) <span style="color: #000000; font-weight: bold">/</span> <span style="color: #0086B3">float64</span>(count)
            m[<span style="color: #0086B3">float64</span>(count)] = a <span style="color: #000000; font-weight: bold">+</span> <span style="color: #009999">0.0001</span>
            <span style="color: #000000; font-weight: bold">if</span> count <span style="color: #000000; font-weight: bold">%</span> <span style="color: #009999">10000</span> <span style="color: #000000; font-weight: bold">==</span> <span style="color: #009999">0</span> {
                <span style="color: #0086B3">println</span>(count, a)
            }
        }
    }
    <span style="color: #0086B3">println</span>(<span style="color: #dd1144">&quot;over&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
可以看到，程序会在多个 CPU 核心之间调度。
</p>

<a class="anchor" name="toc40"></a>
<h2 style="font-size: 18px; margin: 30px auto;">15.2. 竞态</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
即使是最简单的数据结构，最简单的操作，也不要以为它们是并行安全的：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int</span> = <span style="color: #009999">0</span>
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">100</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            <span style="color: #000000; font-weight: bold">for</span> j <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; j &lt; <span style="color: #009999">100</span>; j<span style="color: #000000; font-weight: bold">++</span> {
                count <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
            }
        }()
    }
    time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
    fmt.Println(<span style="color: #dd1144">&quot;count is&quot;</span>, count)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
多执行几次，一定会看到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">count</code> 最后的结果是会比 10000 小。 go 虽然可以在多 CPU 核心之间并行调度，也可以帮你把所有进程同步的事做好，但是，数据结构及操作行为的并行同步的工作，必须要自己处理。也许有的数据结构是并行安全的，那也需要你自己确认。
</p>

<a class="anchor" name="toc41"></a>
<h2 style="font-size: 18px; margin: 30px auto;">15.3. 原子操作</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
“原子操作”的意思，是 CPU 指令中本身提供了并行安全的计算指令，直接在相应的内存地址上使用这些指令，那么 CPU 会保证它们的操作是原子性的，不会遇到并行计算问题。然而，这些操作基本只支持整数，也只支持有限的一些简单运算。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync/atomic</code> 包来提供这方面的支持。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;sync/atomic&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int32</span> = <span style="color: #009999">0</span>
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">100</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            <span style="color: #000000; font-weight: bold">for</span> j <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; j &lt; <span style="color: #009999">100</span>; j<span style="color: #000000; font-weight: bold">++</span> {
                atomic.AddInt32(<span style="color: #000000; font-weight: bold">&amp;</span>count, <span style="color: #009999">1</span>)
            }
        }()
    }
    time.Sleep(<span style="color: #009999">2</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
    fmt.Println(<span style="color: #dd1144">&quot;count is&quot;</span>, count)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">atomic.AddInt32</code> 执行的加 1，就不会有并行问题，所以，结果必然是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">10000</code> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">atomic</code> ，提供了针对整数和指针的这几类操作：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">加法，<em style="color: #d75100; font-style: normal;">Add</em> 。（记得可以加一个负数）
</li>
<li style="margin: 10px auto;">比较和交换， <em style="color: #d75100; font-style: normal;">CompareAndSwap</em> ，如果当前值和指定值相同，则赋值为新值，返回 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">true</code> 。
</li>
<li style="margin: 10px auto;">getter， <em style="color: #d75100; font-style: normal;">Load</em>
</li>
<li style="margin: 10px auto;">setter， <em style="color: #d75100; font-style: normal;">Store</em>
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
同时， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">atomic</code> 还提供了一个比如通用的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Value</code> 类型，我猜，可能是内部使用指针实现了一些操作吧。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">Load</em> 和 <em style="color: #d75100; font-style: normal;">Store</em> 单独看别以为是字面上那么简单，它后面还涉及“指令序”等知识。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
所以，原子操作的功能，像我们这种对底层不太了解的人，尽量少碰了。
</p>

<a class="anchor" name="toc42"></a>
<h2 style="font-size: 18px; margin: 30px auto;">15.4. 互斥锁</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
互斥锁就是通常我们理解的“锁”，这里要注意，它是一种工具，而不是一种保证机制。工具的意思是，大家都用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Lock()</code> ，那么可以达到同步的目的。而如果有些并行内容它本身不使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Lock()</code> ，那么它就可以无视其它并行使用了的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Lock()</code> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync.Mutex</code> 提供锁的功能。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;sync&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>


<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int</span> = <span style="color: #009999">0</span>
    <span style="color: #000000; font-weight: bold">var</span> m sync.Mutex
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">100</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            <span style="color: #000000; font-weight: bold">for</span> j <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; j &lt; <span style="color: #009999">100</span>; j<span style="color: #000000; font-weight: bold">++</span> {
                m.Lock()
                count <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
                m.Unlock()
            }
        }()
    }
    time.Sleep(<span style="color: #009999">2</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
    fmt.Println(<span style="color: #dd1144">&quot;count is&quot;</span>, count)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
同样是锁, go 中还有控制得更细一些的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">RWMutex</code> ，区分了读写的锁，它的规则是：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">同一时间只能一个写。
</li>
<li style="margin: 10px auto;">同一时间可以多个读。
</li>
<li style="margin: 10px auto;">读写互斥。
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
方法上子 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Mutex</code> 多两个：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Lock()</code> 写锁定
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Unlock()</code> 写释放
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">RLock()</code> 读锁定
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">RUnlock()</code> 读释放
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
前面的例子，加“写锁”可以，只加“读锁”是没用的：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;sync&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>


<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> count <span style="color: #445588; font-weight: bold">int</span> = <span style="color: #009999">0</span>
    <span style="color: #000000; font-weight: bold">var</span> m sync.RWMutex
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">100</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            <span style="color: #000000; font-weight: bold">for</span> j <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; j &lt; <span style="color: #009999">100</span>; j<span style="color: #000000; font-weight: bold">++</span> {
                m.RLock()
                count <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
                m.RUnlock()
            }
        }()
    }
    time.Sleep(<span style="color: #009999">2</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
    fmt.Println(<span style="color: #dd1144">&quot;count is&quot;</span>, count)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
下面的例子，是模拟一个写要很长时间，而且中途还会写入不完整内容，读也要很长时间，而且还有多个读的场景：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;sync&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;io&quot;</span>


<span style="color: #000000; font-weight: bold">func</span> writer(callback <span style="color: #000000; font-weight: bold">func</span>(<span style="color: #445588; font-weight: bold">string</span>, <span style="color: #445588; font-weight: bold">error</span>)) {
    <span style="color: #000000; font-weight: bold">for</span> {
        fmt.Println(<span style="color: #dd1144">&quot;I am writing...&quot;</span>)
        callback(<span style="color: #dd1144">&quot;xxx&quot;</span>, <span style="color: #000000; font-weight: bold">nil</span>)
        time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
        callback(time.Now().Format(<span style="color: #dd1144">&quot;2006-01-02 15:04:05&quot;</span>), io.EOF)
    }
}


<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> current <span style="color: #000000; font-weight: bold">*</span><span style="color: #445588; font-weight: bold">string</span> = <span style="color: #0086B3">new</span>(<span style="color: #445588; font-weight: bold">string</span>)
    <span style="color: #000000; font-weight: bold">var</span> m sync.RWMutex
    <span style="color: #000000; font-weight: bold">go</span> writer(<span style="color: #000000; font-weight: bold">func</span>(s <span style="color: #445588; font-weight: bold">string</span>, err <span style="color: #445588; font-weight: bold">error</span>){
        <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">==</span> <span style="color: #000000; font-weight: bold">nil</span> {
            m.Lock()
        }
        <span style="color: #000000; font-weight: bold">*</span>current = s
        fmt.Println(<span style="color: #dd1144">&quot;Writed&quot;</span>, s)
        <span style="color: #000000; font-weight: bold">if</span> err <span style="color: #000000; font-weight: bold">==</span> io.EOF {
            m.Unlock()
        }
    })

    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">3</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            <span style="color: #000000; font-weight: bold">for</span> {
                m.RLock()
                fmt.Println(<span style="color: #dd1144">&quot;I am reading...&quot;</span>)
                time.Sleep(<span style="color: #009999">2</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
                fmt.Println(<span style="color: #dd1144">&quot;Read out &quot;</span>, <span style="color: #000000; font-weight: bold">*</span>current)
                m.RUnlock()
            }
        }()
    }

    time.Sleep(<span style="color: #009999">30</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
不加锁，基本上永远只能读到不完整的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">xxx</code>。<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">RLock()</code> 换成 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Lock()</code> 的话，读的部分就严重阻塞了，没有了并发能力。
</p>

<a class="anchor" name="toc43"></a>
<h2 style="font-size: 18px; margin: 30px auto;">15.5. 并发计数器</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
并发计数器，可以看成是一个简单的计数器实现，只是额外处理了并行安全。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync.WaitGroup</code> ，主要有 3 个方法：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Add()</code>
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Done()</code>
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Wait()</code>
</li>
</ul>


<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;sync&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> counter sync.WaitGroup
    counter.Add(<span style="color: #009999">10</span>)
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">10</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">var</span> n = i
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            <span style="color: #000000; font-weight: bold">defer</span> counter.Done()
            fmt.Println(n)
        }()
    }
    counter.Wait()
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
使用还是比较简单的，不过要注意，不要在 <em style="color: #d75100; font-style: normal;">goroutine</em> 中调用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Add()</code> ，可能在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Add()</code> 之前 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Wait()</code> 都结束了，所以记得把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Add()</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Wait()</code> 保持在同一个上下文中。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
另外，这个工具和 <em style="color: #d75100; font-style: normal;">goroutine</em> 也没有必然联系，如果你想，可以在任何场景下使用。
</p>

<a class="anchor" name="toc44"></a>
<h2 style="font-size: 18px; margin: 30px auto;">15.6. 锁的条件应用</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里说的“条件应用”，指的是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync.Cond</code> 。它是基于锁的一套上层工具，提供了一种跨上下文的“通知机制”，并且这个“通知”过程是伴随锁状态交替的。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync.Cond</code> 主要提供三个方法：
</p>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync.NewCond(l Lock)</code> 初始化。
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">cond.Wait()</code> 阻塞等待通知。
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">cond.Signal() / cond.Broadcase()</code> 通知使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Wait()</code> 阻塞的地方。
</li>
</ul>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
一个例子：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;sync&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>


<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> cond = sync.NewCond(<span style="color: #0086B3">new</span>(sync.Mutex))
    <span style="color: #000000; font-weight: bold">var</span> counter sync.WaitGroup
    <span style="color: #000000; font-weight: bold">var</span> c = <span style="color: #009999">10</span>
    counter.Add(c)
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; c; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">var</span> n = i
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
            cond.L.Lock()
            cond.Wait()
            <span style="color: #000000; font-weight: bold">defer</span> counter.Done()
            fmt.Println(<span style="color: #dd1144">&quot;start&quot;</span>, n)
            time.Sleep(<span style="color: #009999">10</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
            fmt.Println(<span style="color: #dd1144">&quot;end&quot;</span>, n)
            cond.L.Unlock()
        }()
    }

    <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(){
        <span style="color: #000000; font-weight: bold">for</span> {
            time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
            fmt.Println(<span style="color: #dd1144">&quot;out&quot;</span>)
            cond.Signal()
            <span style="color: #999988">//cond.Broadcast()</span>
        }
    }()
    counter.Wait()
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<ul style="line-height: 1.6em; list-style: inside square; padding: 0px; padding-left: 50px; margin: auto;">
<li style="margin: 10px auto;">初始化 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">cond</code> 使用： <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync.Newcond(new(sync.Mutex))</code> 。
</li>
<li style="margin: 10px auto;">代码的执行行为，就是“通知”之后， 10 个 <em style="color: #d75100; font-style: normal;">goroutine</em> 共花 100 秒全部执行一遍输出，然后结束。
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">cond.L.Lock()</code> / <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">cond.L.Unlock()</code> 都需要显式手动控制不太理解。
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Wait()</code> 的实现里面，其实有对 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">L</code> 的加锁，释放的操作。
</li>
<li style="margin: 10px auto;"><code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Signal()</code> / <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Broadcast()</code> 不会阻塞，它们跟锁没关系。只是可能得不到任何响应就是了。
</li>
<li style="margin: 10px auto;">与其说是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Wait()</code> 阻塞了，不如说是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Wait()</code> 前一行的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Lock()</code> 阻塞了。
</li>
<li style="margin: 10px auto;">与锁有关的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Wait()</code> 配合与锁无关的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Signal()</code> / <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Broadcast()</code> ，在锁之上实现了新的抽象层作为多个上下文的同步工具。
</li>
<li style="margin: 10px auto;">不说 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">channel</code> ，这个例子如果不直接用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">cond</code> ，要实现竞态的一组 <em style="color: #d75100; font-style: normal;">goroutine</em> ，被不关心竞态的一个 <em style="color: #d75100; font-style: normal;">goroutine</em> 调度，你自己做出来的工具估计也就是像 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">cond</code> 这样的实现了。
</li>
</ul>

<a class="anchor" name="toc45"></a>
<h2 style="font-size: 18px; margin: 30px auto;">15.7. 层级 Context</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
前面介绍了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">WaitGroup</code> ，它是一个简单，限制比较大的工具。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Context</code> 则是一个使用“通道”实现的，比较灵活的工具。它功能也很简单，就是在合适的时候，手动发出“取消信号”。这个“合适的时候”，包括内置的计时器。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;context&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> root = context.Background()
    <span style="color: #000000; font-weight: bold">var</span> current = <span style="color: #009999">0</span>
    context, cancel <span style="color: #000000; font-weight: bold">:=</span> context.WithCancel(root)
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">10</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>() {
            <span style="color: #000000; font-weight: bold">for</span> {
                current <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
                time.Sleep(<span style="color: #009999">1</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)

                fmt.Println(current)
                <span style="color: #000000; font-weight: bold">if</span> current &gt; <span style="color: #009999">20</span> {
                    cancel()
                    fmt.Println(<span style="color: #dd1144">&quot;cancel&quot;</span>)
                }
            }
        }()
    }
    <span style="color: #000000; font-weight: bold">&lt;-</span>context.Done()
    fmt.Println(<span style="color: #dd1144">&quot;complete&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">context</code> 本身是层级结构， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Background()</code> 可以得到一个“根”， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">WithCancel()</code> 又继续得到一个“子”。当 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">cancel()</code> 的时候，这个信息会往父级传递，然后 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">context.Done()</code> 这个通道会关闭。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
注意，上面的例子，只是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main()</code> 执行完毕，并没有显式地去处理 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">goroutine</code> 的结束问题。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
要显式处理 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">goroutine</code> ，我搜索到的方式都是把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">context</code> 传递给一个函数,函数内部再处理 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Done()</code> ，感觉挻别扭的。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
除了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">WithCancel()</code> ， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">context</code> 还提供了 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">WithDeadline()</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">WithTimeout()</code> ，它们两个其实是一样的，前者是给一个绝对时间，后者是给一个相对时间（绝对时间等于当前时间加相对时间嘛）。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;context&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> root = context.Background()
    <span style="color: #000000; font-weight: bold">var</span> current = <span style="color: #009999">0</span>
    context, cancel <span style="color: #000000; font-weight: bold">:=</span> context.WithTimeout(root, time.Second <span style="color: #000000; font-weight: bold">*</span> <span style="color: #009999">2</span>)
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">10</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>() {
            <span style="color: #000000; font-weight: bold">for</span> {
                current <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
                time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)

                fmt.Println(current)
                <span style="color: #000000; font-weight: bold">if</span> current &gt; <span style="color: #009999">20</span> {
                    cancel()
                    fmt.Println(<span style="color: #dd1144">&quot;cancel&quot;</span>)
                }
            }
        }()
    }
    <span style="color: #000000; font-weight: bold">&lt;-</span>context.Done()

    fmt.Println(<span style="color: #dd1144">&quot;here&quot;</span>)
    <span style="color: #000000; font-weight: bold">for</span> {
        time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
        <span style="color: #000000; font-weight: bold">break</span>
    }

    fmt.Println(<span style="color: #dd1144">&quot;complete&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面的例子，能看到 2 秒之后， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Done()</code> 通道就有动作了，这里 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go func()</code> 里还在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Sleep</code> 。同时也能看到，虽然代码已经跳到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">here</code> 那里了，但是上面的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">goroutine</code> 其实仍然不受影响地继续执行着的。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
要处理好 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go func()</code> 的退出，可以传入 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">context</code> ，并使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">select</code> ：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;context&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;time&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> root = context.Background()
    <span style="color: #000000; font-weight: bold">var</span> current = <span style="color: #009999">0</span>
    ctx, cancel <span style="color: #000000; font-weight: bold">:=</span> context.WithTimeout(root, time.Second <span style="color: #000000; font-weight: bold">*</span> <span style="color: #009999">2</span>)
    <span style="color: #000000; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">:=</span> <span style="color: #009999">0</span>; i &lt; <span style="color: #009999">1</span>; i<span style="color: #000000; font-weight: bold">++</span> {
        <span style="color: #000000; font-weight: bold">go</span> <span style="color: #000000; font-weight: bold">func</span>(ctx context.Context) {
            <span style="color: #000000; font-weight: bold">for</span> {
                <span style="color: #000000; font-weight: bold">select</span> {
                    <span style="color: #000000; font-weight: bold">case</span> <span style="color: #000000; font-weight: bold">&lt;-</span>ctx.Done():
                        fmt.Println(<span style="color: #dd1144">&quot;select return&quot;</span>)
                        <span style="color: #000000; font-weight: bold">return</span>
                    <span style="color: #000000; font-weight: bold">default</span>:
                        fmt.Println(<span style="color: #dd1144">&quot;select default&quot;</span>)
                        current <span style="color: #000000; font-weight: bold">+=</span> <span style="color: #009999">1</span>
                        time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)

                        fmt.Println(current)
                        <span style="color: #000000; font-weight: bold">if</span> current &gt; <span style="color: #009999">20</span> {
                            cancel()
                            fmt.Println(<span style="color: #dd1144">&quot;cancel&quot;</span>)
                        }
                }
            }
        }(ctx)
    }
    <span style="color: #000000; font-weight: bold">&lt;-</span>ctx.Done()

    fmt.Println(<span style="color: #dd1144">&quot;here&quot;</span>)
    <span style="color: #000000; font-weight: bold">for</span> {
        time.Sleep(<span style="color: #009999">5</span> <span style="color: #000000; font-weight: bold">*</span> time.Second)
        <span style="color: #000000; font-weight: bold">break</span>
    }

    fmt.Println(<span style="color: #dd1144">&quot;complete&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
虽然时间上没有办法在 2 秒时就马上中断 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go func()</code> ，但是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">select</code> 中的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">return</code> 是总会执行到的，对于有死循环的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">goroutine</code> 可以避免泄漏。
</p>

<a class="anchor" name="toc46"></a>
<h2 style="font-size: 18px; margin: 30px auto;">15.8. 缓存共享池</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里的关键点不是“池”，而是“缓存”，所以在使用时要记得，它可能随时消失。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync.Pool</code> 结构体提供了一个简单直接的并行安全的“单对象内存块缓存”方案。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
它通过“复用”来减轻内存变动的消耗，对于应用来说，只要得到一个可用的“对象”，本身也不必在乎这个对象是新的，还是二手的。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>

<span style="color: #000000; font-weight: bold">type</span> Foo <span style="color: #000000; font-weight: bold">struct</span> {
    name <span style="color: #445588; font-weight: bold">string</span>
    value <span style="color: #445588; font-weight: bold">string</span>
}

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> f <span style="color: #000000; font-weight: bold">*</span>Foo = <span style="color: #000000; font-weight: bold">&amp;</span>Foo{}
    f.name = <span style="color: #dd1144">&quot;123&quot;</span>
    f.value = <span style="color: #dd1144">&quot;333&quot;</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v %p\n&quot;</span>, f, f)


    <span style="color: #000000; font-weight: bold">var</span> f2 <span style="color: #000000; font-weight: bold">*</span>Foo = <span style="color: #000000; font-weight: bold">&amp;</span>Foo{}
    f2.name = <span style="color: #dd1144">&quot;321&quot;</span>
    f2.value = <span style="color: #dd1144">&quot;889&quot;</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v %p\n&quot;</span>, f2, f2)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
（这里我们通过指针的方式使用结构体，而不是直接引用，是为了避免“值传递”时的内容复制行为）
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
上面这个原始的例子是要拿两次 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Foo</code> ，然后每次给它们赋值 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">name</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">value</code> 之后，打印出来。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">f</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">f2</code> 的地址值，可以看出来它们在两块内存上。
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;fmt&quot;</span>
<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;sync&quot;</span>

<span style="color: #000000; font-weight: bold">type</span> Foo <span style="color: #000000; font-weight: bold">struct</span> {
    name <span style="color: #445588; font-weight: bold">string</span>
    value <span style="color: #445588; font-weight: bold">string</span>
}

<span style="color: #000000; font-weight: bold">func</span> main() {
    <span style="color: #000000; font-weight: bold">var</span> cache sync.Pool
    cache = sync.Pool{
        New: <span style="color: #000000; font-weight: bold">func</span>() <span style="color: #000000; font-weight: bold">interface</span>{} {
            fmt.Println(<span style="color: #dd1144">&quot;New&quot;</span>)
            <span style="color: #000000; font-weight: bold">return</span> <span style="color: #000000; font-weight: bold">&amp;</span>Foo{}
        },
    }

    <span style="color: #000000; font-weight: bold">var</span> f <span style="color: #000000; font-weight: bold">*</span>Foo = cache.Get().(<span style="color: #000000; font-weight: bold">*</span>Foo)
    f.name = <span style="color: #dd1144">&quot;123&quot;</span>
    f.value = <span style="color: #dd1144">&quot;333&quot;</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v %p\n&quot;</span>, f, f)

    f.name = <span style="color: #dd1144">&quot;&quot;</span>
    f.value = <span style="color: #dd1144">&quot;&quot;</span>
    cache.Put(f)

    <span style="color: #000000; font-weight: bold">var</span> f2 <span style="color: #000000; font-weight: bold">*</span>Foo = cache.Get().(<span style="color: #000000; font-weight: bold">*</span>Foo)
    f2.name = <span style="color: #dd1144">&quot;321&quot;</span>
    f2.value = <span style="color: #dd1144">&quot;889&quot;</span>
    fmt.Printf(<span style="color: #dd1144">&quot;%v %p\n&quot;</span>, f2, f2)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这个改进后的使用 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">sync.Pool</code> 的例子，能看到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">f</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">f2</code> 是在同一块内存位置，我们在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Put()</code> 前把 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Foo</code> 的属性手动重置掉的话，对于 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">f2</code> 来说，是用的旧东西，还是全新的东西，不重要。
</p>

<a class="anchor" name="toc47"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">16. 项目模块，包，名字空间</h1>

<a class="anchor" name="toc48"></a>
<h2 style="font-size: 18px; margin: 30px auto;">16.1. 安装环境</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
最开始说过如何安装，在安装完之后，可以使用：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go env
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
来查看当前的环境，比如：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">GO111MODULE=&quot;&quot;
...
GOBIN=&quot;&quot;
GOCACHE=&quot;/home/zys/.cache/go-build&quot;
GOENV=&quot;/home/zys/.config/go/env&quot;
...
GOOS=&quot;linux&quot;
GOPATH=&quot;/home/zys/go&quot;
...
GOPROXY=&quot;https://proxy.golang.org,direct&quot;
GOROOT=&quot;/opt/go&quot;
...
GOTMPDIR=&quot;&quot;
GOTOOLDIR=&quot;/opt/go/pkg/tool/linux_amd64&quot;
...
GOVERSION=&quot;go1.17.2&quot;
...
PKG_CONFIG=&quot;pkg-config&quot;
GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build2853245378=/tmp/go-build -gno-record-gcc-switches&quot;
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<em style="color: #d75100; font-style: normal;">GOPATH</em> 是后面安装的包会放的地方。 <em style="color: #d75100; font-style: normal;">GOROOT</em> 是整个环境的根目录。
</p>

<a class="anchor" name="toc49"></a>
<h2 style="font-size: 18px; margin: 30px auto;">16.2. 项目模块</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 中的 <em style="color: #d75100; font-style: normal;">mod</em> ，我理解就是一个“项目”的意思。类似于 Node 中的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">package.json</code> ， go 中也有 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go.mod</code> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
创建一个名为 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">foo</code> 的目录，然后进入目录，键入：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go mod init zys.me/foo
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
就可以把当前目录做成一个 go 模块，它会在当前目录创建一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go.mod</code> 的文件，内容是：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">module zys.me/foo

go 1.17
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">module</code> 后面就是模块名，也算是一个顶级的名字空间。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
之后，通过 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go get</code> 安装的依赖包，也会写入到 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go.mod</code> 中，比如：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go get github.com/fatih/color
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这是一个终端的颜色封装，安装之后，查看 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go.mod</code> 会看到：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">module zys.me<span style="color: #000000; font-weight: bold">/</span>foo

<span style="color: #000000; font-weight: bold">go</span> <span style="color: #009999">1.17</span>

require (
	github.com<span style="color: #000000; font-weight: bold">/</span>fatih<span style="color: #000000; font-weight: bold">/</span>color v1<span style="color: #009999">.13.0</span> <span style="color: #999988">// indirect</span>
	github.com<span style="color: #000000; font-weight: bold">/</span>mattn<span style="color: #000000; font-weight: bold">/go-</span>colorable v0<span style="color: #009999">.1.9</span> <span style="color: #999988">// indirect</span>
	github.com<span style="color: #000000; font-weight: bold">/</span>mattn<span style="color: #000000; font-weight: bold">/go-</span>isatty v0<span style="color: #009999">.0.14</span> <span style="color: #999988">// indirect</span>
	golang.org<span style="color: #000000; font-weight: bold">/</span>x<span style="color: #000000; font-weight: bold">/</span>sys v0<span style="color: #009999">.0.0</span><span style="color: #000000; font-weight: bold">-</span><span style="color: #009999">20210630005230</span><span style="color: #000000; font-weight: bold">-</span><span style="color: #009999">0</span>f9fa26af87c <span style="color: #999988">// indirect</span>
)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
依赖的内容就添加上了。记得结尾那些 <em style="color: #d75100; font-style: normal;">indirect</em> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
我们再新添加一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">foo/main.go</code> 文件：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;github.com/fatih/color&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    color.Cyan(<span style="color: #dd1144">&quot;你好&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
执行能看到蓝色的字。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
执行一下：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">go mod tidy
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
整理依赖。再查看 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go.mod</code> ，结果变成了：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">module zys.me<span style="color: #000000; font-weight: bold">/</span>foo

<span style="color: #000000; font-weight: bold">go</span> <span style="color: #009999">1.17</span>

require github.com<span style="color: #000000; font-weight: bold">/</span>fatih<span style="color: #000000; font-weight: bold">/</span>color v1<span style="color: #009999">.13.0</span>

require (
	github.com<span style="color: #000000; font-weight: bold">/</span>mattn<span style="color: #000000; font-weight: bold">/go-</span>colorable v0<span style="color: #009999">.1.9</span> <span style="color: #999988">// indirect</span>
	github.com<span style="color: #000000; font-weight: bold">/</span>mattn<span style="color: #000000; font-weight: bold">/go-</span>isatty v0<span style="color: #009999">.0.14</span> <span style="color: #999988">// indirect</span>
	golang.org<span style="color: #000000; font-weight: bold">/</span>x<span style="color: #000000; font-weight: bold">/</span>sys v0<span style="color: #009999">.0.0</span><span style="color: #000000; font-weight: bold">-</span><span style="color: #009999">20210630005230</span><span style="color: #000000; font-weight: bold">-</span><span style="color: #009999">0</span>f9fa26af87c <span style="color: #999988">// indirect</span>
)
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
从现在的配置能看出，项目直接依赖了 <em style="color: #d75100; font-style: normal;">color</em> 。其它三个，估计是 <em style="color: #d75100; font-style: normal;">color</em> 它依赖的，所以对我们来说是“间接”依赖。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
刚才下载的 <em style="color: #d75100; font-style: normal;">color</em> 包，文件会保存到 <em style="color: #d75100; font-style: normal;">/home/zys/go/pkg/mod/github.com/fatih/color@v1.13.0/</em> 。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
能看出，依赖的处理，也考虑了版本号。
</p>

<a class="anchor" name="toc50"></a>
<h2 style="font-size: 18px; margin: 30px auto;">16.3. 包 package</h2>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
在学习的过程中，只用到一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main</code> 的包就可以了。但是正式的项目，就可能会有多个包存在。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
一个模块，看成是一个项目的话，那么一个模块中，就可能有多个包。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
包通过在代码文件开头的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">package</code> 结构写明。一个包，可以来自多个文件，但是一个包的文件只能放在同一个目录中，反之也限制了一个目录只能有一个包。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果我们要新加一个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text.go</code> 的文件，并且把它放到新的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text</code> 的包中，那么之前的代码结构就要做一些调整，直接地：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">foo/main.go
foo/text.go
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这各目录结构肯定不行，会报找不到包的错误。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
需要变成：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">foo/main/main.go
foo/text/text.go
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这样， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main</code> 目录下是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main</code> 包， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text</code> 目录下是 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text</code> 包，就没有问题。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text.go</code> 的内容是：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> text

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;github.com/fatih/color&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> Echo() {
    color.Cyan(<span style="color: #dd1144">&quot;haha&quot;</span>)
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
<code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main.go</code> 的内容是：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;zys.me/foo/text&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    text.Echo()
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
能看到使用自己的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text</code> 包，也是一个绝对地址引用。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这个地址，其实是“模块名+目录”，跟包名没有关系，跟源代码文件名也没有关系。先通过目录定位到了包，之后 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main()</code> 中的那个 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">text</code> 才是包名。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
如果我们把代码结构改成：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;">.
├── a
│   └── 123
│       └── t.go
├── go.mod
└── main
    └── main.go
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
那 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main.go</code> 也需要改成：
</p>

<div class="code" style="margin: 25px auto;">
<div style="background: white"><div style="width: 30%; height: 20px; border-top: 1px dashed gray; border-left: 1px dashed gray;"></div><pre style="white-space: pre; font-size: 12px; line-height: 1.5em; margin-left: 15px; letter-spacing: 0;"><span style="color: #000000; font-weight: bold">package</span> main

<span style="color: #000000; font-weight: bold">import</span> <span style="color: #dd1144">&quot;zys.me/foo/a/123&quot;</span>

<span style="color: #000000; font-weight: bold">func</span> main() {
    text.Echo()
}
</pre><div style="width: 30%; height: 20px; border-bottom: 1px dashed gray; border-left: 1px dashed gray;"></div></div>

</div>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
这里还要注意一点， <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">Echo()</code> 这个方法名，必须首字大写，否则这个方法在 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">main</code> 包中找不到。（首字大写表示 <em style="color: #d75100; font-style: normal;">public</em>）
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
多说一点，这里的 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">zys.me/foo/a/123</code> 起的是包的名字空间的作用，也是按目录起包的定位作用。如果 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">123</code> 目录还有子目录，那么 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">123</code> 和 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">123/sub</code> 就是不同的定位，表示的也是不同的包。不过即使是不同的包，也可能具有相同的名字。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
说到这里，可以看出，项目依赖的东西（ <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">go get</code> 安装的那些），应该说依赖的是“模块”，不是“包”。一个“模块”中可能有多个“包”。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
而在使用时，却只是以“包”为粒度，先 <code style="margin: auto 3px; color: #228b22; font-family: monospace; letter-spacing: 0;">import</code> ，然后再用。
</p>

<a class="anchor" name="toc51"></a>
<h1 style="font-size: 20px; margin: 35px auto; border-bottom: 1px solid gray; padding-top: 5px; padding-bottom: 5px;">17. 最后自己的一点看法</h1>

<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
作为比较新的静态编译类型的语言， go 并没有带来新的理念，它也不纠结是否自己有完备的一些模型。感觉很多地方，都是向着实用的方向去设计的。所以社区中也有声音认为 go 是在开历史的倒车。同时，相较于经常被拿来两者比较的 Rust ， go 的上手难度要小很多，可能也是因为这个原因，很多公司会选择用 go 做应用层的开发。我个人对此，是不太能理解的。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
go 相较于 C ，那肯定方便不少。但是应用层，对比的是 jvm 那套啊。即使先不论 jvm 系的多了虚拟机和容器两层抽象，在服务管理方面有先天的优势。go 没有 <em style="color: #d75100; font-style: normal;">try/catch</em> ，没有 <em style="color: #d75100; font-style: normal;">class</em> 的 <em style="color: #d75100; font-style: normal;">OO</em> ，没有泛型。是，没有这些不影响实现功能，但是要考虑开发人员的心智嘛。纯函数式的机制，我认为确实有比 <em style="color: #d75100; font-style: normal;">class</em> 的 <em style="color: #d75100; font-style: normal;">OO</em> 更高的抽象能力，但是代价却是开发人员的额外设计投入，模型推演上花的额外的时间。对于应用层开发，这点上显然是得不偿失的。业务本身的变化又不会看技术设计的上限。所以简单直接，方法论完整的 <em style="color: #d75100; font-style: normal;">class</em> 的 <em style="color: #d75100; font-style: normal;">OO</em> 就是一个最好的选择。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
另外一点， go 提供了 <em style="color: #d75100; font-style: normal;">goroutine</em> 这个工具，如果用到网络编程的场景，它本质上跟“线程/进程”模型，是一样的。不会因为资源代价更小，就改变了的这个模型先天的问题。现在都 2021 年了，异步 IO 的模型应该已经成为大家的共识，现在又倒回“线程/进程”模型（go 的底层虽然用了 <em style="color: #d75100; font-style: normal;">epoll</em> ，但是官方包的上层仍然是使用 <em style="color: #d75100; font-style: normal;">goroutine</em> 做的同步模型）。有人做过测算，如果一个 <em style="color: #d75100; font-style: normal;">goroutine</em> 占 4KB 的内存，那么单机收到 100 万连接请求的话，就会占到 8G 的内存（IO的读写，go 中好像是分成 2 个 <em style="color: #d75100; font-style: normal;">goroutine</em> 处理的）。问题是，应用层收纳了 100 万的请求连接，除了占内存，并没有什么用啊。CPU 的核心只有 8 个或者 16 个，数据库的连接也是瓶颈。不要让连接过早进入应用服务，留在网络层调度要容易得多。当然，如果这 100 万都是需要长期保持连接的直连长连接，那 go 确实是非常合适的方案。除了官方库，其它的第三方网络相关的实现，也能找到异步 IO 的。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
同时， go 提供了很容易创建的 <em style="color: #d75100; font-style: normal;">goroutine</em> ，但是“并行同步”都是传统那一套，加锁。“通道”不加锁，但它本身也是阻塞的。应用层开发几乎用不到了“并行编程”的，但是 go 的机制却很可能给很多人提供了一个犯错的机会——并行编程真的很难很难， go 没有把它变得简单。
</p>
<p style="line-height: 1.8em; margin: 25px auto; word-break: break-word; word-wrap: break-word;">
所以，我认为 go 适合做计算密集偏向的那些网络服务，比如，各种底层基础设施的服务端。但是不适合应用层开发。
</p>

<style type="text/css">
body.z { background-color: #eff3fa; }
body.z > .content { background-color: white; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
body.z > .content > h1 { background-color: #0184b7; color: white; border-bottom: none; padding-left: 10px; border-radius: 5px; text-shadow: 0 2px 5px rgba(0, 0, 0, 0.9); }
body.z > .content > .toc a:hover { background-color: #ddd; }
body.z > .content > table th { background-color: rgba(223, 151, 27, 0.3);}
body.z > .content > .quote:before { content: '引'; font-size: 30px; color: #ddd; font-family: "'Microsoft YaHei','WenQuanYi Micro Hei',SimHei,tahoma,sans-serif"; }
body.z > .content ul > li, body.z > .content ol > li  { text-indent: -1em; }
body.z > .content  > .toc ul > li, body.z > .content  > .toc ol > li  { text-indent: 0; }
</style>
    

<script type="text/javascript" src="https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js"></script>
<script type="text/javascript">

$(function(){
    function bind_scroll(){
        $('body.z > .content > .toc ol').css({listStyle: 'none'})
        $('body.z > .content > .toc ul').css({listStyle: 'none'})
        $('body.z > .content > .toc a').css({display: 'block', paddingLeft: '10px'})

        var anchor_list = $.map($('.anchor'), function(n){
            return $(n).offset().top;
        });
        var item = $('body.z > .content > .toc a');
        var last = 0;
        var flag = 0;

        $(window).on('scroll', function(eventObj){
            _set_item();
        });

        function set_item(){
            var top = $(window).scrollTop();
            if(top < anchor_list[0]){
                item.eq(last).css({backgroundColor: '', color: '#0184b7'});
                last = 0;
                return;
            }

            for(var i = 0, l = anchor_list.length; i < l; i++){
                if(top < anchor_list[i]){break}
                flag = i;
            }
            item.eq(last).css({backgroundColor: '', color: '#0184b7'});
            item.eq(flag).css({backgroundColor: '#ddd', color: '#333'});
            last = flag;
        }

        var timer = null;
        function _set_item(){
            if(timer){
                clearTimeout(timer);
            }
            timer = setTimeout(set_item, 100);
        }
    }

    function create_toc(){
        if($('body.z > .content > .toc').length == 0){
            $('body.z > .content > .header').css('min-height', '200px');
            return;
        }
        if($('body.z > .content > .toc').height() < 50){return}

        //至少200空间
        var space = ($(window).width() - $('body.z > .content').outerWidth());
        if( space < 200 ){return}

        $('body.z > .content > .header').css('min-height', '200px');

        var toc_width = (space > 400 ? 400 : space);
        var content_left = (space - toc_width - 20) / 2;

        $('body.z > .content > .toc ol').css({
            paddingLeft: '20px'
        });
        $('body.z > .content > .toc ul').css({
            paddingLeft: '20px'
        });

        $('body.z > .content').css({
            marginLeft: content_left + 'px'
        });

        $('body.z > .content > .toc').css({
            fontSize: '12px',
            width: toc_width + 'px',
            backgroundColor: 'white',
            border: '1px solid #ccc',
            boxShadow: '0 2px 5px rgba(0, 0, 0, 0.3)',
            position: 'fixed',
            zIndex: 9999,
            padding: '10px',
            boxSizing: 'border-box',
            top: '50px',
            right: content_left + 'px',
            overflow: 'auto',
            maxHeight: $(window).height() - 100 + 'px'
        });

        bind_scroll();
    }

    function is_mobile(){
        if(navigator.userAgent.indexOf('iPhone') >= 0 || navigator.userAgent.indexOf('Android') >= 0){
            return true;
        }
        return false;
    }

    function mobile_meta(){
        var ua=navigator.userAgent;
        var meta = '';
        if(ua.indexOf('Android')!=-1){
            var isUC= /UC /.test(ua) || /UCBrowser/.test(ua) || /baidubrowser/.test(ua)|| /qq/i.test(ua);
            if(isUC){
                meta='<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0,target-densitydpi=device-dpi,user-scalable=no" />';
            } else {
                meta='<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5,target-densitydpi=320,user-scalable=no" />';
            }
        }else{
            meta='<meta name="viewport" content="width=device-width, initial-scale=0.5, maximum-scale=0.5,target-densitydpi=device-dpi,user-scalable=no,minimal-ui" />';
        }
        $('head').append(meta);
    }

    function mobile_adjust(){
        $('body.z > .content').css({ width: '100%', padding: '15px' });
        $('#qr').hide();
        $('#disqus_thread').css({ width: '100%' });
        $('body.z').css({ letterSpacing: 0 });
        $('body.z p, body.z ul, body.z ol').css({ lineHeight: '1.5em' });
        $('body.z ul > li, body.z ol > li').css({ textIndent: '-2em' });
        $('body.z > .content > .toc ul > li, body.z > .content > .toc ol > li').css({ textIndent: 0, margin: 0 });
        $('body.z pre').css({ whiteSpace: 'pre-wrap', wordWrap: 'break-word' });
    }

    function normal_adjust(){
        $('body.z > .content > .toc ul > li, body.z > .content > .toc ol > li').css({ textIndent: 0, margin: 0 });
    }

    function code_view(){

        $('pre').click(function(eventObj){
            var $node = $($.clone(this));
            $node.attr('style', '');
            $node.css({
                fontSize: '24px',
                fontFamily: 'monospace',
                whiteSpace: 'pre-wrap',
                wordWrap: 'break-word',
                lineHeight: '1.5em',
                width: $(window).height(),
                height: $(window).width(),
                boxSizing: 'border-box',
                padding: '10px',
                paddingBottom: '30px',
                overflow: 'hidden'
            });
            var $wrapper = $('<div></div>').css({
                position: 'fixed',
                padding: 0,
                margin: 0,
                boxSizing: 'border-box',
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                width: $(window).height(),
                height: $(window).width(),
                overflow: 'hidden',
                top: ($(window).height() - $(window).width()) / 2,
                left: ($(window).width() - $(window).height()) / 2,
                transform: 'rotate(90deg)',
                zIndex: 999999
            });

            var $close = $('<div>&times;</div>').css({
                position: 'absolute',
                right: 0,
                top: 0,
                width: '100px',
                height: '100px',
                lineHeight: '80px',
                fontSize: '80px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)'
            });

            var $up = $('<div>△</div>').css({
                position: 'absolute',
                right: 0,
                bottom: '300px',
                width: '100px',
                height: '100px',
                lineHeight: '50px',
                fontSize: '50px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)',
                userSelect: 'none',
                '-webkit-user-select': 'none'
            });

            var $down = $('<div>▽</div>').css({
                position: 'absolute',
                right: 0,
                bottom: '100px',
                width: '100px',
                height: '100px',
                lineHeight: '150px',
                fontSize: '50px',
                textAlign: 'center',
                backgroundColor: 'rgba(204, 204, 204, 0.5)',
                userSelect: 'none',
                '-webkit-user-select': 'none'
            });

            $wrapper.append($node);
            $wrapper.append($close);
            $wrapper.append($up);
            $wrapper.append($down);

            $wrapper.on('touchstart', function(){
                return false;
            });

            $close.on('touchstart', function(){
                $close.css({ backgroundColor: '#0184b7' });
                return false;
            });
            $close.on('touchend', function(){

                $wrapper.off('touchend');
                $close.off('touchstart');
                $close.off('touchend');
                $up.off('touchstart');
                $up.off('touchend');
                $down.off('touchstart');
                $down.off('touchend');
                $wrapper.remove();

                return false;
            });

            var up_timer = null;
            $up.on('touchstart', function(eventObj){
                var start = $node.scrollTop();
                var dx = 0;
                $up.css({ backgroundColor: '#0184b7' });
                up_timer = setInterval(function(){
                    dx += 20;
                    $node.scrollTop(start - dx);
                }, 25);
                return false;
            });
            $up.on('touchend', function(eventObj){
                if(up_timer){clearInterval(up_timer)};
                $up.css({ backgroundColor: 'rgba(204, 204, 204, 0.5)' });
                return false;
            });

            var down_timer = null;
            $down.on('touchstart', function(eventObj){
                var start = $node.scrollTop();
                var dx = 0;
                $down.css({ backgroundColor: '#0184b7' });
                down_timer = setInterval(function(){
                    dx += 20;
                    $node.scrollTop(start + dx);
                }, 25);
                return false;
            });
            $down.on('touchend', function(eventObj){
                if(down_timer){clearInterval(down_timer)};
                $down.css({ backgroundColor: 'rgba(204, 204, 204, 0.5)' });
                return false;
            });

            $(this).before($wrapper);
        });
    
    }

    if(is_mobile()){
        mobile_meta();
        mobile_adjust();
        code_view();
    } else {
        create_toc();
        normal_adjust();
    }
});
</script>
    

    <div style="padding: 4px; line-height: 1.4em; font-size: 22px; margin-top: 100px; margin-bottom: 20px; clear: both; text-align: center; font-weight: bold; ">评论</div>
<div id="disqus_thread" style="width: 800px; margin: auto; "></div>
<script type="text/javascript">
  var disqus_shortname = 'zys';
  var disqus_identifier = 'go';
  var disqus_url = 'https://www.zouyesheng.com/go.html';
  var disqus_title = 'Go学习笔记';

  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>评论功能需要javascript的支持</noscript>
    

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-29492100-1', {siteSpeedSampleRate: 100});
ga('require', 'linkid');
ga('set', 'dimension1', (new Date()).getDay().toString());
ga('send', 'pageview');
</script>
    

<div id="qr" style="position: absolute; right: 30px; top: 80px;"><img style="border: 1px solid gray;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKUAAAClAQAAAAAVUAB3AAABmUlEQVR4nN1XMW7cQAwcngTsdXs/
oD6S030lT0gvQzIu/4rol+z9YLfbBWRNCsWFYaczi4TNAixIkJwZjYT4GO30SRL497ImIucXPA/t
VJ4GEZHBsZuQBGV7xF8XIJCb32ygZWhghgKYGVZMWt33O6ewe9R9F/3x2K373m7u3UAjGYx31msk
A7l5bpIiApQ2xPvjaWgivedsJEnLUEiGkiTdZgNXzCmsmFMwboBw8dvkgZJyBoBvlx/A9Wvq/j37
OpyFvZYud6lSXNnNPGm9RiZanhSIvneLZNjjAhoXxejJAJB5QhVuWhEXDfRECcgMPbT4GhelK7vB
PS5aAWiwPCeMvnxj7oiRTMHypN7KhdiGirKgjdo/2q24KteKjpDcsQrvDHv0xSTviZbnRMtdqs53
WwGEFUAduQCId79upwOEwk3xAijX0vxc0J/ZeMj/psF8MSkkYZefGvbSo35Z3U/j8Fx7ZAp23M1R
ud6yZUEbL12qKP5+0g6+bUrzVWUjGVbMqYr79+3Nc+F5CCuAYPnVjwHyH/9R/QZaURvZjk86GAAA
AABJRU5ErkJggg==
" title="本文二维码网址" /></div>
    

<div style="font-size: 10px; text-align: right; margin-top: 50px; letter-spacing: 0;">
&copy;2010-2021 zouyesheng.com All rights reserved. Powered by <a href="https://github.com/" target="_blank">GitHub</a> , <a href="http://txt2tags.org/" target="_blank">txt2tags</a> , <a href="https://www.mathjax.org/" target="_blank">MathJax</a>
</div>
    
<!-- xhtml code generated by txt2tags 2.6 (http://txt2tags.org) -->
</div></body></html>
